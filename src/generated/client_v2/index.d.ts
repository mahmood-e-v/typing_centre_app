
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model DailyClosing
 * 
 */
export type DailyClosing = $Result.DefaultSelection<Prisma.$DailyClosingPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ApprovalRequest
 * 
 */
export type ApprovalRequest = $Result.DefaultSelection<Prisma.$ApprovalRequestPayload>
/**
 * Model FinancialPeriod
 * 
 */
export type FinancialPeriod = $Result.DefaultSelection<Prisma.$FinancialPeriodPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model WorkType
 * 
 */
export type WorkType = $Result.DefaultSelection<Prisma.$WorkTypePayload>
/**
 * Model Beneficiary
 * 
 */
export type Beneficiary = $Result.DefaultSelection<Prisma.$BeneficiaryPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model ExpenseCategory
 * 
 */
export type ExpenseCategory = $Result.DefaultSelection<Prisma.$ExpenseCategoryPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model JournalEntry
 * 
 */
export type JournalEntry = $Result.DefaultSelection<Prisma.$JournalEntryPayload>
/**
 * Model LedgerTransaction
 * 
 */
export type LedgerTransaction = $Result.DefaultSelection<Prisma.$LedgerTransactionPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model VoucherItem
 * 
 */
export type VoucherItem = $Result.DefaultSelection<Prisma.$VoucherItemPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model VoucherPayment
 * 
 */
export type VoucherPayment = $Result.DefaultSelection<Prisma.$VoucherPaymentPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model BusinessCard
 * 
 */
export type BusinessCard = $Result.DefaultSelection<Prisma.$BusinessCardPayload>
/**
 * Model Quotation
 * 
 */
export type Quotation = $Result.DefaultSelection<Prisma.$QuotationPayload>
/**
 * Model QuotationItem
 * 
 */
export type QuotationItem = $Result.DefaultSelection<Prisma.$QuotationItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AccountingMethod: {
  ACCRUAL: 'ACCRUAL',
  CASH: 'CASH'
};

export type AccountingMethod = (typeof AccountingMethod)[keyof typeof AccountingMethod]


export const AccountingModel: {
  CONSOLIDATED: 'CONSOLIDATED',
  BRANCH_WISE: 'BRANCH_WISE'
};

export type AccountingModel = (typeof AccountingModel)[keyof typeof AccountingModel]


export const Emirate: {
  DUBAI: 'DUBAI',
  ABU_DHABI: 'ABU_DHABI',
  SHARJAH: 'SHARJAH',
  AJMAN: 'AJMAN',
  UMM_AL_QUWAIN: 'UMM_AL_QUWAIN',
  RAS_AL_KHAIMAH: 'RAS_AL_KHAIMAH',
  FUJAIRAH: 'FUJAIRAH'
};

export type Emirate = (typeof Emirate)[keyof typeof Emirate]


export const LegalType: {
  SOLE_ESTABLISHMENT: 'SOLE_ESTABLISHMENT',
  LLC: 'LLC',
  CIVIL_COMPANY: 'CIVIL_COMPANY',
  FREEZONE_ENTITY: 'FREEZONE_ENTITY',
  BRANCH_OF_FOREIGN: 'BRANCH_OF_FOREIGN'
};

export type LegalType = (typeof LegalType)[keyof typeof LegalType]


export const VatFrequency: {
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY'
};

export type VatFrequency = (typeof VatFrequency)[keyof typeof VatFrequency]


export const ClosingStatus: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED'
};

export type ClosingStatus = (typeof ClosingStatus)[keyof typeof ClosingStatus]


export const BranchType: {
  MAIN: 'MAIN',
  SUB: 'SUB'
};

export type BranchType = (typeof BranchType)[keyof typeof BranchType]


export const UserRole_Legacy: {
  ADMIN: 'ADMIN',
  EMPLOYEE: 'EMPLOYEE',
  BRANCH_MANAGER: 'BRANCH_MANAGER',
  OWNER: 'OWNER',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole_Legacy = (typeof UserRole_Legacy)[keyof typeof UserRole_Legacy]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CARD: 'CARD',
  ONLINE: 'ONLINE',
  WALLET: 'WALLET'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  PAID: 'PAID',
  PARTIAL: 'PARTIAL',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const TransactionType: {
  SERVICE: 'SERVICE',
  PAYMENT: 'PAYMENT',
  OPENING_BALANCE: 'OPENING_BALANCE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PaymentStatus: {
  PAID: 'PAID',
  NOT_PAID: 'NOT_PAID',
  PARTIAL: 'PARTIAL'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const AdvanceStatus: {
  NONE: 'NONE',
  PARTIAL: 'PARTIAL',
  FULL: 'FULL'
};

export type AdvanceStatus = (typeof AdvanceStatus)[keyof typeof AdvanceStatus]


export const PartnerType: {
  PRO: 'PRO',
  CORPORATE: 'CORPORATE',
  INDIVIDUAL: 'INDIVIDUAL'
};

export type PartnerType = (typeof PartnerType)[keyof typeof PartnerType]


export const AccountType: {
  CASH: 'CASH',
  BANK: 'BANK',
  CREDIT_CARD: 'CREDIT_CARD'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const AccountCategory: {
  ASSET: 'ASSET',
  LIABILITY: 'LIABILITY',
  EQUITY: 'EQUITY',
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type AccountCategory = (typeof AccountCategory)[keyof typeof AccountCategory]


export const JournalEntryType: {
  INVOICE: 'INVOICE',
  PAYMENT: 'PAYMENT',
  EXPENSE: 'EXPENSE',
  GOVT_FEE: 'GOVT_FEE',
  ADJUSTMENT: 'ADJUSTMENT',
  REVERSAL: 'REVERSAL'
};

export type JournalEntryType = (typeof JournalEntryType)[keyof typeof JournalEntryType]


export const VoucherStatus: {
  DRAFT: 'DRAFT',
  OPEN: 'OPEN',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED'
};

export type VoucherStatus = (typeof VoucherStatus)[keyof typeof VoucherStatus]


export const VoucherType: {
  PAYMENT: 'PAYMENT',
  RECEIPT: 'RECEIPT'
};

export type VoucherType = (typeof VoucherType)[keyof typeof VoucherType]


export const CardType: {
  CREDIT: 'CREDIT',
  DEBIT: 'DEBIT'
};

export type CardType = (typeof CardType)[keyof typeof CardType]


export const QuotationStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  ACCEPTED: 'ACCEPTED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED',
  CONVERTED: 'CONVERTED',
  PARTIALLY_INVOICED: 'PARTIALLY_INVOICED'
};

export type QuotationStatus = (typeof QuotationStatus)[keyof typeof QuotationStatus]

}

export type AccountingMethod = $Enums.AccountingMethod

export const AccountingMethod: typeof $Enums.AccountingMethod

export type AccountingModel = $Enums.AccountingModel

export const AccountingModel: typeof $Enums.AccountingModel

export type Emirate = $Enums.Emirate

export const Emirate: typeof $Enums.Emirate

export type LegalType = $Enums.LegalType

export const LegalType: typeof $Enums.LegalType

export type VatFrequency = $Enums.VatFrequency

export const VatFrequency: typeof $Enums.VatFrequency

export type ClosingStatus = $Enums.ClosingStatus

export const ClosingStatus: typeof $Enums.ClosingStatus

export type BranchType = $Enums.BranchType

export const BranchType: typeof $Enums.BranchType

export type UserRole_Legacy = $Enums.UserRole_Legacy

export const UserRole_Legacy: typeof $Enums.UserRole_Legacy

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type AdvanceStatus = $Enums.AdvanceStatus

export const AdvanceStatus: typeof $Enums.AdvanceStatus

export type PartnerType = $Enums.PartnerType

export const PartnerType: typeof $Enums.PartnerType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type AccountCategory = $Enums.AccountCategory

export const AccountCategory: typeof $Enums.AccountCategory

export type JournalEntryType = $Enums.JournalEntryType

export const JournalEntryType: typeof $Enums.JournalEntryType

export type VoucherStatus = $Enums.VoucherStatus

export const VoucherStatus: typeof $Enums.VoucherStatus

export type VoucherType = $Enums.VoucherType

export const VoucherType: typeof $Enums.VoucherType

export type CardType = $Enums.CardType

export const CardType: typeof $Enums.CardType

export type QuotationStatus = $Enums.QuotationStatus

export const QuotationStatus: typeof $Enums.QuotationStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.dailyClosing`: Exposes CRUD operations for the **DailyClosing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyClosings
    * const dailyClosings = await prisma.dailyClosing.findMany()
    * ```
    */
  get dailyClosing(): Prisma.DailyClosingDelegate<ExtArgs>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.approvalRequest`: Exposes CRUD operations for the **ApprovalRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalRequests
    * const approvalRequests = await prisma.approvalRequest.findMany()
    * ```
    */
  get approvalRequest(): Prisma.ApprovalRequestDelegate<ExtArgs>;

  /**
   * `prisma.financialPeriod`: Exposes CRUD operations for the **FinancialPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialPeriods
    * const financialPeriods = await prisma.financialPeriod.findMany()
    * ```
    */
  get financialPeriod(): Prisma.FinancialPeriodDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.workType`: Exposes CRUD operations for the **WorkType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkTypes
    * const workTypes = await prisma.workType.findMany()
    * ```
    */
  get workType(): Prisma.WorkTypeDelegate<ExtArgs>;

  /**
   * `prisma.beneficiary`: Exposes CRUD operations for the **Beneficiary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beneficiaries
    * const beneficiaries = await prisma.beneficiary.findMany()
    * ```
    */
  get beneficiary(): Prisma.BeneficiaryDelegate<ExtArgs>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.expenseCategory`: Exposes CRUD operations for the **ExpenseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseCategories
    * const expenseCategories = await prisma.expenseCategory.findMany()
    * ```
    */
  get expenseCategory(): Prisma.ExpenseCategoryDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<ExtArgs>;

  /**
   * `prisma.ledgerTransaction`: Exposes CRUD operations for the **LedgerTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerTransactions
    * const ledgerTransactions = await prisma.ledgerTransaction.findMany()
    * ```
    */
  get ledgerTransaction(): Prisma.LedgerTransactionDelegate<ExtArgs>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs>;

  /**
   * `prisma.voucherItem`: Exposes CRUD operations for the **VoucherItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherItems
    * const voucherItems = await prisma.voucherItem.findMany()
    * ```
    */
  get voucherItem(): Prisma.VoucherItemDelegate<ExtArgs>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs>;

  /**
   * `prisma.voucherPayment`: Exposes CRUD operations for the **VoucherPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherPayments
    * const voucherPayments = await prisma.voucherPayment.findMany()
    * ```
    */
  get voucherPayment(): Prisma.VoucherPaymentDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.businessCard`: Exposes CRUD operations for the **BusinessCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessCards
    * const businessCards = await prisma.businessCard.findMany()
    * ```
    */
  get businessCard(): Prisma.BusinessCardDelegate<ExtArgs>;

  /**
   * `prisma.quotation`: Exposes CRUD operations for the **Quotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotations
    * const quotations = await prisma.quotation.findMany()
    * ```
    */
  get quotation(): Prisma.QuotationDelegate<ExtArgs>;

  /**
   * `prisma.quotationItem`: Exposes CRUD operations for the **QuotationItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotationItems
    * const quotationItems = await prisma.quotationItem.findMany()
    * ```
    */
  get quotationItem(): Prisma.QuotationItemDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    DailyClosing: 'DailyClosing',
    Branch: 'Branch',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    UserRole: 'UserRole',
    User: 'User',
    Session: 'Session',
    AuditLog: 'AuditLog',
    ApprovalRequest: 'ApprovalRequest',
    FinancialPeriod: 'FinancialPeriod',
    Invoice: 'Invoice',
    Transaction: 'Transaction',
    WorkType: 'WorkType',
    Beneficiary: 'Beneficiary',
    Partner: 'Partner',
    Expense: 'Expense',
    ExpenseCategory: 'ExpenseCategory',
    Account: 'Account',
    JournalEntry: 'JournalEntry',
    LedgerTransaction: 'LedgerTransaction',
    Voucher: 'Voucher',
    VoucherItem: 'VoucherItem',
    Vendor: 'Vendor',
    VoucherPayment: 'VoucherPayment',
    PasswordResetToken: 'PasswordResetToken',
    BusinessCard: 'BusinessCard',
    Quotation: 'Quotation',
    QuotationItem: 'QuotationItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "company" | "dailyClosing" | "branch" | "role" | "permission" | "rolePermission" | "userRole" | "user" | "session" | "auditLog" | "approvalRequest" | "financialPeriod" | "invoice" | "transaction" | "workType" | "beneficiary" | "partner" | "expense" | "expenseCategory" | "account" | "journalEntry" | "ledgerTransaction" | "voucher" | "voucherItem" | "vendor" | "voucherPayment" | "passwordResetToken" | "businessCard" | "quotation" | "quotationItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      DailyClosing: {
        payload: Prisma.$DailyClosingPayload<ExtArgs>
        fields: Prisma.DailyClosingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyClosingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyClosingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload>
          }
          findFirst: {
            args: Prisma.DailyClosingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyClosingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload>
          }
          findMany: {
            args: Prisma.DailyClosingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload>[]
          }
          create: {
            args: Prisma.DailyClosingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload>
          }
          createMany: {
            args: Prisma.DailyClosingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyClosingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload>[]
          }
          delete: {
            args: Prisma.DailyClosingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload>
          }
          update: {
            args: Prisma.DailyClosingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload>
          }
          deleteMany: {
            args: Prisma.DailyClosingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyClosingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyClosingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyClosingPayload>
          }
          aggregate: {
            args: Prisma.DailyClosingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyClosing>
          }
          groupBy: {
            args: Prisma.DailyClosingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyClosingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyClosingCountArgs<ExtArgs>
            result: $Utils.Optional<DailyClosingCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ApprovalRequest: {
        payload: Prisma.$ApprovalRequestPayload<ExtArgs>
        fields: Prisma.ApprovalRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          findFirst: {
            args: Prisma.ApprovalRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          findMany: {
            args: Prisma.ApprovalRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>[]
          }
          create: {
            args: Prisma.ApprovalRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          createMany: {
            args: Prisma.ApprovalRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>[]
          }
          delete: {
            args: Prisma.ApprovalRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          update: {
            args: Prisma.ApprovalRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          aggregate: {
            args: Prisma.ApprovalRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalRequest>
          }
          groupBy: {
            args: Prisma.ApprovalRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalRequestCountAggregateOutputType> | number
          }
        }
      }
      FinancialPeriod: {
        payload: Prisma.$FinancialPeriodPayload<ExtArgs>
        fields: Prisma.FinancialPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          findFirst: {
            args: Prisma.FinancialPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          findMany: {
            args: Prisma.FinancialPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>[]
          }
          create: {
            args: Prisma.FinancialPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          createMany: {
            args: Prisma.FinancialPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>[]
          }
          delete: {
            args: Prisma.FinancialPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          update: {
            args: Prisma.FinancialPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          deleteMany: {
            args: Prisma.FinancialPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancialPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialPeriodPayload>
          }
          aggregate: {
            args: Prisma.FinancialPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialPeriod>
          }
          groupBy: {
            args: Prisma.FinancialPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialPeriodCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      WorkType: {
        payload: Prisma.$WorkTypePayload<ExtArgs>
        fields: Prisma.WorkTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload>
          }
          findFirst: {
            args: Prisma.WorkTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload>
          }
          findMany: {
            args: Prisma.WorkTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload>[]
          }
          create: {
            args: Prisma.WorkTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload>
          }
          createMany: {
            args: Prisma.WorkTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload>[]
          }
          delete: {
            args: Prisma.WorkTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload>
          }
          update: {
            args: Prisma.WorkTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload>
          }
          deleteMany: {
            args: Prisma.WorkTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkTypePayload>
          }
          aggregate: {
            args: Prisma.WorkTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkType>
          }
          groupBy: {
            args: Prisma.WorkTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkTypeCountArgs<ExtArgs>
            result: $Utils.Optional<WorkTypeCountAggregateOutputType> | number
          }
        }
      }
      Beneficiary: {
        payload: Prisma.$BeneficiaryPayload<ExtArgs>
        fields: Prisma.BeneficiaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BeneficiaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BeneficiaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          findFirst: {
            args: Prisma.BeneficiaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BeneficiaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          findMany: {
            args: Prisma.BeneficiaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>[]
          }
          create: {
            args: Prisma.BeneficiaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          createMany: {
            args: Prisma.BeneficiaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BeneficiaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>[]
          }
          delete: {
            args: Prisma.BeneficiaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          update: {
            args: Prisma.BeneficiaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          deleteMany: {
            args: Prisma.BeneficiaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BeneficiaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BeneficiaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeneficiaryPayload>
          }
          aggregate: {
            args: Prisma.BeneficiaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeneficiary>
          }
          groupBy: {
            args: Prisma.BeneficiaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeneficiaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BeneficiaryCountArgs<ExtArgs>
            result: $Utils.Optional<BeneficiaryCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      ExpenseCategory: {
        payload: Prisma.$ExpenseCategoryPayload<ExtArgs>
        fields: Prisma.ExpenseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          update: {
            args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseCategory>
          }
          groupBy: {
            args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: Prisma.$JournalEntryPayload<ExtArgs>
        fields: Prisma.JournalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      LedgerTransaction: {
        payload: Prisma.$LedgerTransactionPayload<ExtArgs>
        fields: Prisma.LedgerTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          findFirst: {
            args: Prisma.LedgerTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          findMany: {
            args: Prisma.LedgerTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>[]
          }
          create: {
            args: Prisma.LedgerTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          createMany: {
            args: Prisma.LedgerTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>[]
          }
          delete: {
            args: Prisma.LedgerTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          update: {
            args: Prisma.LedgerTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          deleteMany: {
            args: Prisma.LedgerTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerTransactionPayload>
          }
          aggregate: {
            args: Prisma.LedgerTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerTransaction>
          }
          groupBy: {
            args: Prisma.LedgerTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerTransactionCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      VoucherItem: {
        payload: Prisma.$VoucherItemPayload<ExtArgs>
        fields: Prisma.VoucherItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload>
          }
          findFirst: {
            args: Prisma.VoucherItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload>
          }
          findMany: {
            args: Prisma.VoucherItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload>[]
          }
          create: {
            args: Prisma.VoucherItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload>
          }
          createMany: {
            args: Prisma.VoucherItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload>[]
          }
          delete: {
            args: Prisma.VoucherItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload>
          }
          update: {
            args: Prisma.VoucherItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload>
          }
          deleteMany: {
            args: Prisma.VoucherItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VoucherItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherItemPayload>
          }
          aggregate: {
            args: Prisma.VoucherItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucherItem>
          }
          groupBy: {
            args: Prisma.VoucherItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherItemCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherItemCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      VoucherPayment: {
        payload: Prisma.$VoucherPaymentPayload<ExtArgs>
        fields: Prisma.VoucherPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload>
          }
          findFirst: {
            args: Prisma.VoucherPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload>
          }
          findMany: {
            args: Prisma.VoucherPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload>[]
          }
          create: {
            args: Prisma.VoucherPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload>
          }
          createMany: {
            args: Prisma.VoucherPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload>[]
          }
          delete: {
            args: Prisma.VoucherPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload>
          }
          update: {
            args: Prisma.VoucherPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload>
          }
          deleteMany: {
            args: Prisma.VoucherPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VoucherPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPaymentPayload>
          }
          aggregate: {
            args: Prisma.VoucherPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucherPayment>
          }
          groupBy: {
            args: Prisma.VoucherPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherPaymentCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      BusinessCard: {
        payload: Prisma.$BusinessCardPayload<ExtArgs>
        fields: Prisma.BusinessCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload>
          }
          findFirst: {
            args: Prisma.BusinessCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload>
          }
          findMany: {
            args: Prisma.BusinessCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload>[]
          }
          create: {
            args: Prisma.BusinessCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload>
          }
          createMany: {
            args: Prisma.BusinessCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload>[]
          }
          delete: {
            args: Prisma.BusinessCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload>
          }
          update: {
            args: Prisma.BusinessCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload>
          }
          deleteMany: {
            args: Prisma.BusinessCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessCardPayload>
          }
          aggregate: {
            args: Prisma.BusinessCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessCard>
          }
          groupBy: {
            args: Prisma.BusinessCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCardCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCardCountAggregateOutputType> | number
          }
        }
      }
      Quotation: {
        payload: Prisma.$QuotationPayload<ExtArgs>
        fields: Prisma.QuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findFirst: {
            args: Prisma.QuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findMany: {
            args: Prisma.QuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          create: {
            args: Prisma.QuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          createMany: {
            args: Prisma.QuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          delete: {
            args: Prisma.QuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          update: {
            args: Prisma.QuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          deleteMany: {
            args: Prisma.QuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          aggregate: {
            args: Prisma.QuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotation>
          }
          groupBy: {
            args: Prisma.QuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationCountAggregateOutputType> | number
          }
        }
      }
      QuotationItem: {
        payload: Prisma.$QuotationItemPayload<ExtArgs>
        fields: Prisma.QuotationItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          findFirst: {
            args: Prisma.QuotationItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          findMany: {
            args: Prisma.QuotationItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>[]
          }
          create: {
            args: Prisma.QuotationItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          createMany: {
            args: Prisma.QuotationItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>[]
          }
          delete: {
            args: Prisma.QuotationItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          update: {
            args: Prisma.QuotationItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          deleteMany: {
            args: Prisma.QuotationItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuotationItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          aggregate: {
            args: Prisma.QuotationItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotationItem>
          }
          groupBy: {
            args: Prisma.QuotationItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    accounts: number
    auditLogs: number
    beneficiaries: number
    branches: number
    dailyClosings: number
    expenses: number
    expenseCategories: number
    financialPeriods: number
    invoices: number
    journalEntries: number
    partners: number
    transactions: number
    users: number
    vendors: number
    vouchers: number
    voucherPayments: number
    workTypes: number
    businessCards: number
    quotations: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | CompanyCountOutputTypeCountAccountsArgs
    auditLogs?: boolean | CompanyCountOutputTypeCountAuditLogsArgs
    beneficiaries?: boolean | CompanyCountOutputTypeCountBeneficiariesArgs
    branches?: boolean | CompanyCountOutputTypeCountBranchesArgs
    dailyClosings?: boolean | CompanyCountOutputTypeCountDailyClosingsArgs
    expenses?: boolean | CompanyCountOutputTypeCountExpensesArgs
    expenseCategories?: boolean | CompanyCountOutputTypeCountExpenseCategoriesArgs
    financialPeriods?: boolean | CompanyCountOutputTypeCountFinancialPeriodsArgs
    invoices?: boolean | CompanyCountOutputTypeCountInvoicesArgs
    journalEntries?: boolean | CompanyCountOutputTypeCountJournalEntriesArgs
    partners?: boolean | CompanyCountOutputTypeCountPartnersArgs
    transactions?: boolean | CompanyCountOutputTypeCountTransactionsArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    vendors?: boolean | CompanyCountOutputTypeCountVendorsArgs
    vouchers?: boolean | CompanyCountOutputTypeCountVouchersArgs
    voucherPayments?: boolean | CompanyCountOutputTypeCountVoucherPaymentsArgs
    workTypes?: boolean | CompanyCountOutputTypeCountWorkTypesArgs
    businessCards?: boolean | CompanyCountOutputTypeCountBusinessCardsArgs
    quotations?: boolean | CompanyCountOutputTypeCountQuotationsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeneficiaryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDailyClosingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyClosingWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountExpenseCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFinancialPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialPeriodWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVoucherPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherPaymentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWorkTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkTypeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBusinessCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessCardWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    dailyClosings: number
    expenses: number
    invoices: number
    journalEntries: number
    ledgerTransactions: number
    transactions: number
    users: number
    vouchers: number
    quotations: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyClosings?: boolean | BranchCountOutputTypeCountDailyClosingsArgs
    expenses?: boolean | BranchCountOutputTypeCountExpensesArgs
    invoices?: boolean | BranchCountOutputTypeCountInvoicesArgs
    journalEntries?: boolean | BranchCountOutputTypeCountJournalEntriesArgs
    ledgerTransactions?: boolean | BranchCountOutputTypeCountLedgerTransactionsArgs
    transactions?: boolean | BranchCountOutputTypeCountTransactionsArgs
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    vouchers?: boolean | BranchCountOutputTypeCountVouchersArgs
    quotations?: boolean | BranchCountOutputTypeCountQuotationsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDailyClosingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyClosingWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountLedgerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerTransactionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    userRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    approvalActions: number
    approvalRequests: number
    auditLogs: number
    managedBranches: number
    dailyClosings: number
    expenses: number
    accountingLockedPeriods: number
    unlockedPeriods: number
    vatLockedPeriods: number
    yearEndClosedPeriods: number
    invoices: number
    passwordResetTokens: number
    sessions: number
    transactions: number
    userRoles: number
    vouchers: number
    voucherPayments: number
    quotations: number
    approvedQuotations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvalActions?: boolean | UserCountOutputTypeCountApprovalActionsArgs
    approvalRequests?: boolean | UserCountOutputTypeCountApprovalRequestsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    managedBranches?: boolean | UserCountOutputTypeCountManagedBranchesArgs
    dailyClosings?: boolean | UserCountOutputTypeCountDailyClosingsArgs
    expenses?: boolean | UserCountOutputTypeCountExpensesArgs
    accountingLockedPeriods?: boolean | UserCountOutputTypeCountAccountingLockedPeriodsArgs
    unlockedPeriods?: boolean | UserCountOutputTypeCountUnlockedPeriodsArgs
    vatLockedPeriods?: boolean | UserCountOutputTypeCountVatLockedPeriodsArgs
    yearEndClosedPeriods?: boolean | UserCountOutputTypeCountYearEndClosedPeriodsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    vouchers?: boolean | UserCountOutputTypeCountVouchersArgs
    voucherPayments?: boolean | UserCountOutputTypeCountVoucherPaymentsArgs
    quotations?: boolean | UserCountOutputTypeCountQuotationsArgs
    approvedQuotations?: boolean | UserCountOutputTypeCountApprovedQuotationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyClosingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyClosingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountingLockedPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialPeriodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUnlockedPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialPeriodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVatLockedPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialPeriodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountYearEndClosedPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialPeriodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoucherPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherPaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    transactions: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | InvoiceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type WorkTypeCountOutputType
   */

  export type WorkTypeCountOutputType = {
    transactions: number
    quotationItems: number
  }

  export type WorkTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WorkTypeCountOutputTypeCountTransactionsArgs
    quotationItems?: boolean | WorkTypeCountOutputTypeCountQuotationItemsArgs
  }

  // Custom InputTypes
  /**
   * WorkTypeCountOutputType without action
   */
  export type WorkTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkTypeCountOutputType
     */
    select?: WorkTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkTypeCountOutputType without action
   */
  export type WorkTypeCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * WorkTypeCountOutputType without action
   */
  export type WorkTypeCountOutputTypeCountQuotationItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
  }


  /**
   * Count Type BeneficiaryCountOutputType
   */

  export type BeneficiaryCountOutputType = {
    transactions: number
  }

  export type BeneficiaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BeneficiaryCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BeneficiaryCountOutputType without action
   */
  export type BeneficiaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeneficiaryCountOutputType
     */
    select?: BeneficiaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BeneficiaryCountOutputType without action
   */
  export type BeneficiaryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    beneficiaries: number
    ledgerTransactions: number
    transactions: number
    quotations: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beneficiaries?: boolean | PartnerCountOutputTypeCountBeneficiariesArgs
    ledgerTransactions?: boolean | PartnerCountOutputTypeCountLedgerTransactionsArgs
    transactions?: boolean | PartnerCountOutputTypeCountTransactionsArgs
    quotations?: boolean | PartnerCountOutputTypeCountQuotationsArgs
  }

  // Custom InputTypes
  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountBeneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeneficiaryWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountLedgerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerTransactionWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }


  /**
   * Count Type ExpenseCategoryCountOutputType
   */

  export type ExpenseCategoryCountOutputType = {
    expenses: number
    voucherItems: number
  }

  export type ExpenseCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategoryCountOutputTypeCountExpensesArgs
    voucherItems?: boolean | ExpenseCategoryCountOutputTypeCountVoucherItemsArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategoryCountOutputType
     */
    select?: ExpenseCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountVoucherItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherItemWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    childAccounts: number
    expenses: number
    expenseCategories: number
    invoicesGovtFee: number
    ledgerTransactions: number
    transactions: number
    transactionsGovtFee: number
    vouchers: number
    voucherPayments: number
    businessCards: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childAccounts?: boolean | AccountCountOutputTypeCountChildAccountsArgs
    expenses?: boolean | AccountCountOutputTypeCountExpensesArgs
    expenseCategories?: boolean | AccountCountOutputTypeCountExpenseCategoriesArgs
    invoicesGovtFee?: boolean | AccountCountOutputTypeCountInvoicesGovtFeeArgs
    ledgerTransactions?: boolean | AccountCountOutputTypeCountLedgerTransactionsArgs
    transactions?: boolean | AccountCountOutputTypeCountTransactionsArgs
    transactionsGovtFee?: boolean | AccountCountOutputTypeCountTransactionsGovtFeeArgs
    vouchers?: boolean | AccountCountOutputTypeCountVouchersArgs
    voucherPayments?: boolean | AccountCountOutputTypeCountVoucherPaymentsArgs
    businessCards?: boolean | AccountCountOutputTypeCountBusinessCardsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountChildAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountExpenseCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountInvoicesGovtFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountLedgerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerTransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTransactionsGovtFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountVoucherPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherPaymentWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountBusinessCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessCardWhereInput
  }


  /**
   * Count Type JournalEntryCountOutputType
   */

  export type JournalEntryCountOutputType = {
    transactions: number
  }

  export type JournalEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | JournalEntryCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntryCountOutputType
     */
    select?: JournalEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerTransactionWhereInput
  }


  /**
   * Count Type VoucherCountOutputType
   */

  export type VoucherCountOutputType = {
    items: number
    payments: number
  }

  export type VoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | VoucherCountOutputTypeCountItemsArgs
    payments?: boolean | VoucherCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherCountOutputType
     */
    select?: VoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherItemWhereInput
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherPaymentWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    vouchers: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vouchers?: boolean | VendorCountOutputTypeCountVouchersArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }


  /**
   * Count Type BusinessCardCountOutputType
   */

  export type BusinessCardCountOutputType = {
    ledgerTransactions: number
  }

  export type BusinessCardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerTransactions?: boolean | BusinessCardCountOutputTypeCountLedgerTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BusinessCardCountOutputType without action
   */
  export type BusinessCardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCardCountOutputType
     */
    select?: BusinessCardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCardCountOutputType without action
   */
  export type BusinessCardCountOutputTypeCountLedgerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerTransactionWhereInput
  }


  /**
   * Count Type QuotationCountOutputType
   */

  export type QuotationCountOutputType = {
    items: number
    invoices: number
  }

  export type QuotationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | QuotationCountOutputTypeCountItemsArgs
    invoices?: boolean | QuotationCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationCountOutputType
     */
    select?: QuotationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    auditRetentionDays: number | null
    decimalPrecision: number | null
    fiscalYearStart: number | null
    vatRate: number | null
  }

  export type CompanySumAggregateOutputType = {
    auditRetentionDays: number | null
    decimalPrecision: number | null
    fiscalYearStart: number | null
    vatRate: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    email: string | null
    phone: string | null
    address: string | null
    trn: string | null
    isActive: boolean | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    accountingMethod: $Enums.AccountingMethod | null
    accountingModel: $Enums.AccountingModel | null
    allowBackDated: boolean | null
    auditRetentionDays: number | null
    baseCurrency: string | null
    decimalPrecision: number | null
    emirate: $Enums.Emirate | null
    establishmentCard: string | null
    fiscalYearStart: number | null
    invoiceFooter: string | null
    invoiceHeader: string | null
    legalType: $Enums.LegalType | null
    logo: string | null
    nameAr: string | null
    stampImage: string | null
    startDate: Date | null
    tradeLicense: string | null
    vatFilingStart: Date | null
    vatRate: number | null
    vatRegistered: boolean | null
    vatRegistrationDate: Date | null
    vatReturnFreq: $Enums.VatFrequency | null
    website: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    email: string | null
    phone: string | null
    address: string | null
    trn: string | null
    isActive: boolean | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    accountingMethod: $Enums.AccountingMethod | null
    accountingModel: $Enums.AccountingModel | null
    allowBackDated: boolean | null
    auditRetentionDays: number | null
    baseCurrency: string | null
    decimalPrecision: number | null
    emirate: $Enums.Emirate | null
    establishmentCard: string | null
    fiscalYearStart: number | null
    invoiceFooter: string | null
    invoiceHeader: string | null
    legalType: $Enums.LegalType | null
    logo: string | null
    nameAr: string | null
    stampImage: string | null
    startDate: Date | null
    tradeLicense: string | null
    vatFilingStart: Date | null
    vatRate: number | null
    vatRegistered: boolean | null
    vatRegistrationDate: Date | null
    vatReturnFreq: $Enums.VatFrequency | null
    website: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    code: number
    email: number
    phone: number
    address: number
    trn: number
    isActive: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    accountingMethod: number
    accountingModel: number
    allowBackDated: number
    auditRetentionDays: number
    baseCurrency: number
    decimalPrecision: number
    emirate: number
    establishmentCard: number
    fiscalYearStart: number
    invoiceFooter: number
    invoiceHeader: number
    legalType: number
    logo: number
    nameAr: number
    stampImage: number
    startDate: number
    tradeLicense: number
    vatFilingStart: number
    vatRate: number
    vatRegistered: number
    vatRegistrationDate: number
    vatReturnFreq: number
    website: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    auditRetentionDays?: true
    decimalPrecision?: true
    fiscalYearStart?: true
    vatRate?: true
  }

  export type CompanySumAggregateInputType = {
    auditRetentionDays?: true
    decimalPrecision?: true
    fiscalYearStart?: true
    vatRate?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    email?: true
    phone?: true
    address?: true
    trn?: true
    isActive?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    accountingMethod?: true
    accountingModel?: true
    allowBackDated?: true
    auditRetentionDays?: true
    baseCurrency?: true
    decimalPrecision?: true
    emirate?: true
    establishmentCard?: true
    fiscalYearStart?: true
    invoiceFooter?: true
    invoiceHeader?: true
    legalType?: true
    logo?: true
    nameAr?: true
    stampImage?: true
    startDate?: true
    tradeLicense?: true
    vatFilingStart?: true
    vatRate?: true
    vatRegistered?: true
    vatRegistrationDate?: true
    vatReturnFreq?: true
    website?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    email?: true
    phone?: true
    address?: true
    trn?: true
    isActive?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    accountingMethod?: true
    accountingModel?: true
    allowBackDated?: true
    auditRetentionDays?: true
    baseCurrency?: true
    decimalPrecision?: true
    emirate?: true
    establishmentCard?: true
    fiscalYearStart?: true
    invoiceFooter?: true
    invoiceHeader?: true
    legalType?: true
    logo?: true
    nameAr?: true
    stampImage?: true
    startDate?: true
    tradeLicense?: true
    vatFilingStart?: true
    vatRate?: true
    vatRegistered?: true
    vatRegistrationDate?: true
    vatReturnFreq?: true
    website?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    email?: true
    phone?: true
    address?: true
    trn?: true
    isActive?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    accountingMethod?: true
    accountingModel?: true
    allowBackDated?: true
    auditRetentionDays?: true
    baseCurrency?: true
    decimalPrecision?: true
    emirate?: true
    establishmentCard?: true
    fiscalYearStart?: true
    invoiceFooter?: true
    invoiceHeader?: true
    legalType?: true
    logo?: true
    nameAr?: true
    stampImage?: true
    startDate?: true
    tradeLicense?: true
    vatFilingStart?: true
    vatRate?: true
    vatRegistered?: true
    vatRegistrationDate?: true
    vatReturnFreq?: true
    website?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    code: string
    email: string | null
    phone: string | null
    address: string | null
    trn: string | null
    isActive: boolean
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    accountingMethod: $Enums.AccountingMethod
    accountingModel: $Enums.AccountingModel
    allowBackDated: boolean
    auditRetentionDays: number
    baseCurrency: string
    decimalPrecision: number
    emirate: $Enums.Emirate
    establishmentCard: string | null
    fiscalYearStart: number
    invoiceFooter: string | null
    invoiceHeader: string | null
    legalType: $Enums.LegalType
    logo: string | null
    nameAr: string | null
    stampImage: string | null
    startDate: Date
    tradeLicense: string | null
    vatFilingStart: Date | null
    vatRate: number
    vatRegistered: boolean
    vatRegistrationDate: Date | null
    vatReturnFreq: $Enums.VatFrequency
    website: string | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    trn?: boolean
    isActive?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountingMethod?: boolean
    accountingModel?: boolean
    allowBackDated?: boolean
    auditRetentionDays?: boolean
    baseCurrency?: boolean
    decimalPrecision?: boolean
    emirate?: boolean
    establishmentCard?: boolean
    fiscalYearStart?: boolean
    invoiceFooter?: boolean
    invoiceHeader?: boolean
    legalType?: boolean
    logo?: boolean
    nameAr?: boolean
    stampImage?: boolean
    startDate?: boolean
    tradeLicense?: boolean
    vatFilingStart?: boolean
    vatRate?: boolean
    vatRegistered?: boolean
    vatRegistrationDate?: boolean
    vatReturnFreq?: boolean
    website?: boolean
    accounts?: boolean | Company$accountsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    beneficiaries?: boolean | Company$beneficiariesArgs<ExtArgs>
    branches?: boolean | Company$branchesArgs<ExtArgs>
    dailyClosings?: boolean | Company$dailyClosingsArgs<ExtArgs>
    expenses?: boolean | Company$expensesArgs<ExtArgs>
    expenseCategories?: boolean | Company$expenseCategoriesArgs<ExtArgs>
    financialPeriods?: boolean | Company$financialPeriodsArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    journalEntries?: boolean | Company$journalEntriesArgs<ExtArgs>
    partners?: boolean | Company$partnersArgs<ExtArgs>
    transactions?: boolean | Company$transactionsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    vendors?: boolean | Company$vendorsArgs<ExtArgs>
    vouchers?: boolean | Company$vouchersArgs<ExtArgs>
    voucherPayments?: boolean | Company$voucherPaymentsArgs<ExtArgs>
    workTypes?: boolean | Company$workTypesArgs<ExtArgs>
    businessCards?: boolean | Company$businessCardsArgs<ExtArgs>
    quotations?: boolean | Company$quotationsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    trn?: boolean
    isActive?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountingMethod?: boolean
    accountingModel?: boolean
    allowBackDated?: boolean
    auditRetentionDays?: boolean
    baseCurrency?: boolean
    decimalPrecision?: boolean
    emirate?: boolean
    establishmentCard?: boolean
    fiscalYearStart?: boolean
    invoiceFooter?: boolean
    invoiceHeader?: boolean
    legalType?: boolean
    logo?: boolean
    nameAr?: boolean
    stampImage?: boolean
    startDate?: boolean
    tradeLicense?: boolean
    vatFilingStart?: boolean
    vatRate?: boolean
    vatRegistered?: boolean
    vatRegistrationDate?: boolean
    vatReturnFreq?: boolean
    website?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    trn?: boolean
    isActive?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountingMethod?: boolean
    accountingModel?: boolean
    allowBackDated?: boolean
    auditRetentionDays?: boolean
    baseCurrency?: boolean
    decimalPrecision?: boolean
    emirate?: boolean
    establishmentCard?: boolean
    fiscalYearStart?: boolean
    invoiceFooter?: boolean
    invoiceHeader?: boolean
    legalType?: boolean
    logo?: boolean
    nameAr?: boolean
    stampImage?: boolean
    startDate?: boolean
    tradeLicense?: boolean
    vatFilingStart?: boolean
    vatRate?: boolean
    vatRegistered?: boolean
    vatRegistrationDate?: boolean
    vatReturnFreq?: boolean
    website?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | Company$accountsArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    beneficiaries?: boolean | Company$beneficiariesArgs<ExtArgs>
    branches?: boolean | Company$branchesArgs<ExtArgs>
    dailyClosings?: boolean | Company$dailyClosingsArgs<ExtArgs>
    expenses?: boolean | Company$expensesArgs<ExtArgs>
    expenseCategories?: boolean | Company$expenseCategoriesArgs<ExtArgs>
    financialPeriods?: boolean | Company$financialPeriodsArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    journalEntries?: boolean | Company$journalEntriesArgs<ExtArgs>
    partners?: boolean | Company$partnersArgs<ExtArgs>
    transactions?: boolean | Company$transactionsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    vendors?: boolean | Company$vendorsArgs<ExtArgs>
    vouchers?: boolean | Company$vouchersArgs<ExtArgs>
    voucherPayments?: boolean | Company$voucherPaymentsArgs<ExtArgs>
    workTypes?: boolean | Company$workTypesArgs<ExtArgs>
    businessCards?: boolean | Company$businessCardsArgs<ExtArgs>
    quotations?: boolean | Company$quotationsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      beneficiaries: Prisma.$BeneficiaryPayload<ExtArgs>[]
      branches: Prisma.$BranchPayload<ExtArgs>[]
      dailyClosings: Prisma.$DailyClosingPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      expenseCategories: Prisma.$ExpenseCategoryPayload<ExtArgs>[]
      financialPeriods: Prisma.$FinancialPeriodPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
      partners: Prisma.$PartnerPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      vendors: Prisma.$VendorPayload<ExtArgs>[]
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
      voucherPayments: Prisma.$VoucherPaymentPayload<ExtArgs>[]
      workTypes: Prisma.$WorkTypePayload<ExtArgs>[]
      businessCards: Prisma.$BusinessCardPayload<ExtArgs>[]
      quotations: Prisma.$QuotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      email: string | null
      phone: string | null
      address: string | null
      trn: string | null
      isActive: boolean
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
      accountingMethod: $Enums.AccountingMethod
      accountingModel: $Enums.AccountingModel
      allowBackDated: boolean
      auditRetentionDays: number
      baseCurrency: string
      decimalPrecision: number
      emirate: $Enums.Emirate
      establishmentCard: string | null
      fiscalYearStart: number
      invoiceFooter: string | null
      invoiceHeader: string | null
      legalType: $Enums.LegalType
      logo: string | null
      nameAr: string | null
      stampImage: string | null
      startDate: Date
      tradeLicense: string | null
      vatFilingStart: Date | null
      vatRate: number
      vatRegistered: boolean
      vatRegistrationDate: Date | null
      vatReturnFreq: $Enums.VatFrequency
      website: string | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends Company$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Company$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Company$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    beneficiaries<T extends Company$beneficiariesArgs<ExtArgs> = {}>(args?: Subset<T, Company$beneficiariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findMany"> | Null>
    branches<T extends Company$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Company$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany"> | Null>
    dailyClosings<T extends Company$dailyClosingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$dailyClosingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Company$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Company$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    expenseCategories<T extends Company$expenseCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$expenseCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    financialPeriods<T extends Company$financialPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, Company$financialPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Company$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    journalEntries<T extends Company$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Company$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany"> | Null>
    partners<T extends Company$partnersArgs<ExtArgs> = {}>(args?: Subset<T, Company$partnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Company$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    vendors<T extends Company$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Company$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany"> | Null>
    vouchers<T extends Company$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Company$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany"> | Null>
    voucherPayments<T extends Company$voucherPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$voucherPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    workTypes<T extends Company$workTypesArgs<ExtArgs> = {}>(args?: Subset<T, Company$workTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "findMany"> | Null>
    businessCards<T extends Company$businessCardsArgs<ExtArgs> = {}>(args?: Subset<T, Company$businessCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "findMany"> | Null>
    quotations<T extends Company$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, Company$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly code: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly trn: FieldRef<"Company", 'String'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly lockedUntil: FieldRef<"Company", 'DateTime'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly accountingMethod: FieldRef<"Company", 'AccountingMethod'>
    readonly accountingModel: FieldRef<"Company", 'AccountingModel'>
    readonly allowBackDated: FieldRef<"Company", 'Boolean'>
    readonly auditRetentionDays: FieldRef<"Company", 'Int'>
    readonly baseCurrency: FieldRef<"Company", 'String'>
    readonly decimalPrecision: FieldRef<"Company", 'Int'>
    readonly emirate: FieldRef<"Company", 'Emirate'>
    readonly establishmentCard: FieldRef<"Company", 'String'>
    readonly fiscalYearStart: FieldRef<"Company", 'Int'>
    readonly invoiceFooter: FieldRef<"Company", 'String'>
    readonly invoiceHeader: FieldRef<"Company", 'String'>
    readonly legalType: FieldRef<"Company", 'LegalType'>
    readonly logo: FieldRef<"Company", 'String'>
    readonly nameAr: FieldRef<"Company", 'String'>
    readonly stampImage: FieldRef<"Company", 'String'>
    readonly startDate: FieldRef<"Company", 'DateTime'>
    readonly tradeLicense: FieldRef<"Company", 'String'>
    readonly vatFilingStart: FieldRef<"Company", 'DateTime'>
    readonly vatRate: FieldRef<"Company", 'Float'>
    readonly vatRegistered: FieldRef<"Company", 'Boolean'>
    readonly vatRegistrationDate: FieldRef<"Company", 'DateTime'>
    readonly vatReturnFreq: FieldRef<"Company", 'VatFrequency'>
    readonly website: FieldRef<"Company", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.accounts
   */
  export type Company$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Company.auditLogs
   */
  export type Company$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Company.beneficiaries
   */
  export type Company$beneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    cursor?: BeneficiaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Company.branches
   */
  export type Company$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Company.dailyClosings
   */
  export type Company$dailyClosingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    where?: DailyClosingWhereInput
    orderBy?: DailyClosingOrderByWithRelationInput | DailyClosingOrderByWithRelationInput[]
    cursor?: DailyClosingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyClosingScalarFieldEnum | DailyClosingScalarFieldEnum[]
  }

  /**
   * Company.expenses
   */
  export type Company$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Company.expenseCategories
   */
  export type Company$expenseCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    cursor?: ExpenseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * Company.financialPeriods
   */
  export type Company$financialPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    where?: FinancialPeriodWhereInput
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    cursor?: FinancialPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * Company.invoices
   */
  export type Company$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Company.journalEntries
   */
  export type Company$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * Company.partners
   */
  export type Company$partnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    cursor?: PartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Company.transactions
   */
  export type Company$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.vendors
   */
  export type Company$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Company.vouchers
   */
  export type Company$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Company.voucherPayments
   */
  export type Company$voucherPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    where?: VoucherPaymentWhereInput
    orderBy?: VoucherPaymentOrderByWithRelationInput | VoucherPaymentOrderByWithRelationInput[]
    cursor?: VoucherPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherPaymentScalarFieldEnum | VoucherPaymentScalarFieldEnum[]
  }

  /**
   * Company.workTypes
   */
  export type Company$workTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    where?: WorkTypeWhereInput
    orderBy?: WorkTypeOrderByWithRelationInput | WorkTypeOrderByWithRelationInput[]
    cursor?: WorkTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkTypeScalarFieldEnum | WorkTypeScalarFieldEnum[]
  }

  /**
   * Company.businessCards
   */
  export type Company$businessCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    where?: BusinessCardWhereInput
    orderBy?: BusinessCardOrderByWithRelationInput | BusinessCardOrderByWithRelationInput[]
    cursor?: BusinessCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessCardScalarFieldEnum | BusinessCardScalarFieldEnum[]
  }

  /**
   * Company.quotations
   */
  export type Company$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model DailyClosing
   */

  export type AggregateDailyClosing = {
    _count: DailyClosingCountAggregateOutputType | null
    _avg: DailyClosingAvgAggregateOutputType | null
    _sum: DailyClosingSumAggregateOutputType | null
    _min: DailyClosingMinAggregateOutputType | null
    _max: DailyClosingMaxAggregateOutputType | null
  }

  export type DailyClosingAvgAggregateOutputType = {
    openingCash: Decimal | null
    cashIn: Decimal | null
    cashOut: Decimal | null
    closingCash: Decimal | null
    bankIn: Decimal | null
    posIn: Decimal | null
    totalSales: Decimal | null
    totalVat: Decimal | null
    totalGovFee: Decimal | null
  }

  export type DailyClosingSumAggregateOutputType = {
    openingCash: Decimal | null
    cashIn: Decimal | null
    cashOut: Decimal | null
    closingCash: Decimal | null
    bankIn: Decimal | null
    posIn: Decimal | null
    totalSales: Decimal | null
    totalVat: Decimal | null
    totalGovFee: Decimal | null
  }

  export type DailyClosingMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    branchId: string | null
    date: Date | null
    status: $Enums.ClosingStatus | null
    openingCash: Decimal | null
    cashIn: Decimal | null
    cashOut: Decimal | null
    closingCash: Decimal | null
    bankIn: Decimal | null
    posIn: Decimal | null
    totalSales: Decimal | null
    totalVat: Decimal | null
    totalGovFee: Decimal | null
    closedById: string | null
    closedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyClosingMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    branchId: string | null
    date: Date | null
    status: $Enums.ClosingStatus | null
    openingCash: Decimal | null
    cashIn: Decimal | null
    cashOut: Decimal | null
    closingCash: Decimal | null
    bankIn: Decimal | null
    posIn: Decimal | null
    totalSales: Decimal | null
    totalVat: Decimal | null
    totalGovFee: Decimal | null
    closedById: string | null
    closedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyClosingCountAggregateOutputType = {
    id: number
    companyId: number
    branchId: number
    date: number
    status: number
    openingCash: number
    cashIn: number
    cashOut: number
    closingCash: number
    bankIn: number
    posIn: number
    totalSales: number
    totalVat: number
    totalGovFee: number
    closedById: number
    closedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyClosingAvgAggregateInputType = {
    openingCash?: true
    cashIn?: true
    cashOut?: true
    closingCash?: true
    bankIn?: true
    posIn?: true
    totalSales?: true
    totalVat?: true
    totalGovFee?: true
  }

  export type DailyClosingSumAggregateInputType = {
    openingCash?: true
    cashIn?: true
    cashOut?: true
    closingCash?: true
    bankIn?: true
    posIn?: true
    totalSales?: true
    totalVat?: true
    totalGovFee?: true
  }

  export type DailyClosingMinAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    date?: true
    status?: true
    openingCash?: true
    cashIn?: true
    cashOut?: true
    closingCash?: true
    bankIn?: true
    posIn?: true
    totalSales?: true
    totalVat?: true
    totalGovFee?: true
    closedById?: true
    closedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyClosingMaxAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    date?: true
    status?: true
    openingCash?: true
    cashIn?: true
    cashOut?: true
    closingCash?: true
    bankIn?: true
    posIn?: true
    totalSales?: true
    totalVat?: true
    totalGovFee?: true
    closedById?: true
    closedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyClosingCountAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    date?: true
    status?: true
    openingCash?: true
    cashIn?: true
    cashOut?: true
    closingCash?: true
    bankIn?: true
    posIn?: true
    totalSales?: true
    totalVat?: true
    totalGovFee?: true
    closedById?: true
    closedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyClosingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyClosing to aggregate.
     */
    where?: DailyClosingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyClosings to fetch.
     */
    orderBy?: DailyClosingOrderByWithRelationInput | DailyClosingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyClosingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyClosings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyClosings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyClosings
    **/
    _count?: true | DailyClosingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyClosingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyClosingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyClosingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyClosingMaxAggregateInputType
  }

  export type GetDailyClosingAggregateType<T extends DailyClosingAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyClosing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyClosing[P]>
      : GetScalarType<T[P], AggregateDailyClosing[P]>
  }




  export type DailyClosingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyClosingWhereInput
    orderBy?: DailyClosingOrderByWithAggregationInput | DailyClosingOrderByWithAggregationInput[]
    by: DailyClosingScalarFieldEnum[] | DailyClosingScalarFieldEnum
    having?: DailyClosingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyClosingCountAggregateInputType | true
    _avg?: DailyClosingAvgAggregateInputType
    _sum?: DailyClosingSumAggregateInputType
    _min?: DailyClosingMinAggregateInputType
    _max?: DailyClosingMaxAggregateInputType
  }

  export type DailyClosingGroupByOutputType = {
    id: string
    companyId: string
    branchId: string
    date: Date
    status: $Enums.ClosingStatus
    openingCash: Decimal
    cashIn: Decimal
    cashOut: Decimal
    closingCash: Decimal
    bankIn: Decimal
    posIn: Decimal
    totalSales: Decimal
    totalVat: Decimal
    totalGovFee: Decimal
    closedById: string | null
    closedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DailyClosingCountAggregateOutputType | null
    _avg: DailyClosingAvgAggregateOutputType | null
    _sum: DailyClosingSumAggregateOutputType | null
    _min: DailyClosingMinAggregateOutputType | null
    _max: DailyClosingMaxAggregateOutputType | null
  }

  type GetDailyClosingGroupByPayload<T extends DailyClosingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyClosingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyClosingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyClosingGroupByOutputType[P]>
            : GetScalarType<T[P], DailyClosingGroupByOutputType[P]>
        }
      >
    >


  export type DailyClosingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    date?: boolean
    status?: boolean
    openingCash?: boolean
    cashIn?: boolean
    cashOut?: boolean
    closingCash?: boolean
    bankIn?: boolean
    posIn?: boolean
    totalSales?: boolean
    totalVat?: boolean
    totalGovFee?: boolean
    closedById?: boolean
    closedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    closedBy?: boolean | DailyClosing$closedByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyClosing"]>

  export type DailyClosingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    date?: boolean
    status?: boolean
    openingCash?: boolean
    cashIn?: boolean
    cashOut?: boolean
    closingCash?: boolean
    bankIn?: boolean
    posIn?: boolean
    totalSales?: boolean
    totalVat?: boolean
    totalGovFee?: boolean
    closedById?: boolean
    closedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    closedBy?: boolean | DailyClosing$closedByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyClosing"]>

  export type DailyClosingSelectScalar = {
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    date?: boolean
    status?: boolean
    openingCash?: boolean
    cashIn?: boolean
    cashOut?: boolean
    closingCash?: boolean
    bankIn?: boolean
    posIn?: boolean
    totalSales?: boolean
    totalVat?: boolean
    totalGovFee?: boolean
    closedById?: boolean
    closedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyClosingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    closedBy?: boolean | DailyClosing$closedByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DailyClosingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    closedBy?: boolean | DailyClosing$closedByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DailyClosingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyClosing"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      closedBy: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      branchId: string
      date: Date
      status: $Enums.ClosingStatus
      openingCash: Prisma.Decimal
      cashIn: Prisma.Decimal
      cashOut: Prisma.Decimal
      closingCash: Prisma.Decimal
      bankIn: Prisma.Decimal
      posIn: Prisma.Decimal
      totalSales: Prisma.Decimal
      totalVat: Prisma.Decimal
      totalGovFee: Prisma.Decimal
      closedById: string | null
      closedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyClosing"]>
    composites: {}
  }

  type DailyClosingGetPayload<S extends boolean | null | undefined | DailyClosingDefaultArgs> = $Result.GetResult<Prisma.$DailyClosingPayload, S>

  type DailyClosingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyClosingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyClosingCountAggregateInputType | true
    }

  export interface DailyClosingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyClosing'], meta: { name: 'DailyClosing' } }
    /**
     * Find zero or one DailyClosing that matches the filter.
     * @param {DailyClosingFindUniqueArgs} args - Arguments to find a DailyClosing
     * @example
     * // Get one DailyClosing
     * const dailyClosing = await prisma.dailyClosing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyClosingFindUniqueArgs>(args: SelectSubset<T, DailyClosingFindUniqueArgs<ExtArgs>>): Prisma__DailyClosingClient<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyClosing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyClosingFindUniqueOrThrowArgs} args - Arguments to find a DailyClosing
     * @example
     * // Get one DailyClosing
     * const dailyClosing = await prisma.dailyClosing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyClosingFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyClosingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyClosingClient<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyClosing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyClosingFindFirstArgs} args - Arguments to find a DailyClosing
     * @example
     * // Get one DailyClosing
     * const dailyClosing = await prisma.dailyClosing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyClosingFindFirstArgs>(args?: SelectSubset<T, DailyClosingFindFirstArgs<ExtArgs>>): Prisma__DailyClosingClient<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyClosing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyClosingFindFirstOrThrowArgs} args - Arguments to find a DailyClosing
     * @example
     * // Get one DailyClosing
     * const dailyClosing = await prisma.dailyClosing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyClosingFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyClosingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyClosingClient<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyClosings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyClosingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyClosings
     * const dailyClosings = await prisma.dailyClosing.findMany()
     * 
     * // Get first 10 DailyClosings
     * const dailyClosings = await prisma.dailyClosing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyClosingWithIdOnly = await prisma.dailyClosing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyClosingFindManyArgs>(args?: SelectSubset<T, DailyClosingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyClosing.
     * @param {DailyClosingCreateArgs} args - Arguments to create a DailyClosing.
     * @example
     * // Create one DailyClosing
     * const DailyClosing = await prisma.dailyClosing.create({
     *   data: {
     *     // ... data to create a DailyClosing
     *   }
     * })
     * 
     */
    create<T extends DailyClosingCreateArgs>(args: SelectSubset<T, DailyClosingCreateArgs<ExtArgs>>): Prisma__DailyClosingClient<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyClosings.
     * @param {DailyClosingCreateManyArgs} args - Arguments to create many DailyClosings.
     * @example
     * // Create many DailyClosings
     * const dailyClosing = await prisma.dailyClosing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyClosingCreateManyArgs>(args?: SelectSubset<T, DailyClosingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyClosings and returns the data saved in the database.
     * @param {DailyClosingCreateManyAndReturnArgs} args - Arguments to create many DailyClosings.
     * @example
     * // Create many DailyClosings
     * const dailyClosing = await prisma.dailyClosing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyClosings and only return the `id`
     * const dailyClosingWithIdOnly = await prisma.dailyClosing.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyClosingCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyClosingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyClosing.
     * @param {DailyClosingDeleteArgs} args - Arguments to delete one DailyClosing.
     * @example
     * // Delete one DailyClosing
     * const DailyClosing = await prisma.dailyClosing.delete({
     *   where: {
     *     // ... filter to delete one DailyClosing
     *   }
     * })
     * 
     */
    delete<T extends DailyClosingDeleteArgs>(args: SelectSubset<T, DailyClosingDeleteArgs<ExtArgs>>): Prisma__DailyClosingClient<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyClosing.
     * @param {DailyClosingUpdateArgs} args - Arguments to update one DailyClosing.
     * @example
     * // Update one DailyClosing
     * const dailyClosing = await prisma.dailyClosing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyClosingUpdateArgs>(args: SelectSubset<T, DailyClosingUpdateArgs<ExtArgs>>): Prisma__DailyClosingClient<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyClosings.
     * @param {DailyClosingDeleteManyArgs} args - Arguments to filter DailyClosings to delete.
     * @example
     * // Delete a few DailyClosings
     * const { count } = await prisma.dailyClosing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyClosingDeleteManyArgs>(args?: SelectSubset<T, DailyClosingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyClosings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyClosingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyClosings
     * const dailyClosing = await prisma.dailyClosing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyClosingUpdateManyArgs>(args: SelectSubset<T, DailyClosingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyClosing.
     * @param {DailyClosingUpsertArgs} args - Arguments to update or create a DailyClosing.
     * @example
     * // Update or create a DailyClosing
     * const dailyClosing = await prisma.dailyClosing.upsert({
     *   create: {
     *     // ... data to create a DailyClosing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyClosing we want to update
     *   }
     * })
     */
    upsert<T extends DailyClosingUpsertArgs>(args: SelectSubset<T, DailyClosingUpsertArgs<ExtArgs>>): Prisma__DailyClosingClient<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyClosings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyClosingCountArgs} args - Arguments to filter DailyClosings to count.
     * @example
     * // Count the number of DailyClosings
     * const count = await prisma.dailyClosing.count({
     *   where: {
     *     // ... the filter for the DailyClosings we want to count
     *   }
     * })
    **/
    count<T extends DailyClosingCountArgs>(
      args?: Subset<T, DailyClosingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyClosingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyClosing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyClosingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyClosingAggregateArgs>(args: Subset<T, DailyClosingAggregateArgs>): Prisma.PrismaPromise<GetDailyClosingAggregateType<T>>

    /**
     * Group by DailyClosing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyClosingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyClosingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyClosingGroupByArgs['orderBy'] }
        : { orderBy?: DailyClosingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyClosingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyClosingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyClosing model
   */
  readonly fields: DailyClosingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyClosing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyClosingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    closedBy<T extends DailyClosing$closedByArgs<ExtArgs> = {}>(args?: Subset<T, DailyClosing$closedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyClosing model
   */ 
  interface DailyClosingFieldRefs {
    readonly id: FieldRef<"DailyClosing", 'String'>
    readonly companyId: FieldRef<"DailyClosing", 'String'>
    readonly branchId: FieldRef<"DailyClosing", 'String'>
    readonly date: FieldRef<"DailyClosing", 'DateTime'>
    readonly status: FieldRef<"DailyClosing", 'ClosingStatus'>
    readonly openingCash: FieldRef<"DailyClosing", 'Decimal'>
    readonly cashIn: FieldRef<"DailyClosing", 'Decimal'>
    readonly cashOut: FieldRef<"DailyClosing", 'Decimal'>
    readonly closingCash: FieldRef<"DailyClosing", 'Decimal'>
    readonly bankIn: FieldRef<"DailyClosing", 'Decimal'>
    readonly posIn: FieldRef<"DailyClosing", 'Decimal'>
    readonly totalSales: FieldRef<"DailyClosing", 'Decimal'>
    readonly totalVat: FieldRef<"DailyClosing", 'Decimal'>
    readonly totalGovFee: FieldRef<"DailyClosing", 'Decimal'>
    readonly closedById: FieldRef<"DailyClosing", 'String'>
    readonly closedAt: FieldRef<"DailyClosing", 'DateTime'>
    readonly notes: FieldRef<"DailyClosing", 'String'>
    readonly createdAt: FieldRef<"DailyClosing", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyClosing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyClosing findUnique
   */
  export type DailyClosingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * Filter, which DailyClosing to fetch.
     */
    where: DailyClosingWhereUniqueInput
  }

  /**
   * DailyClosing findUniqueOrThrow
   */
  export type DailyClosingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * Filter, which DailyClosing to fetch.
     */
    where: DailyClosingWhereUniqueInput
  }

  /**
   * DailyClosing findFirst
   */
  export type DailyClosingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * Filter, which DailyClosing to fetch.
     */
    where?: DailyClosingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyClosings to fetch.
     */
    orderBy?: DailyClosingOrderByWithRelationInput | DailyClosingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyClosings.
     */
    cursor?: DailyClosingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyClosings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyClosings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyClosings.
     */
    distinct?: DailyClosingScalarFieldEnum | DailyClosingScalarFieldEnum[]
  }

  /**
   * DailyClosing findFirstOrThrow
   */
  export type DailyClosingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * Filter, which DailyClosing to fetch.
     */
    where?: DailyClosingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyClosings to fetch.
     */
    orderBy?: DailyClosingOrderByWithRelationInput | DailyClosingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyClosings.
     */
    cursor?: DailyClosingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyClosings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyClosings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyClosings.
     */
    distinct?: DailyClosingScalarFieldEnum | DailyClosingScalarFieldEnum[]
  }

  /**
   * DailyClosing findMany
   */
  export type DailyClosingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * Filter, which DailyClosings to fetch.
     */
    where?: DailyClosingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyClosings to fetch.
     */
    orderBy?: DailyClosingOrderByWithRelationInput | DailyClosingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyClosings.
     */
    cursor?: DailyClosingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyClosings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyClosings.
     */
    skip?: number
    distinct?: DailyClosingScalarFieldEnum | DailyClosingScalarFieldEnum[]
  }

  /**
   * DailyClosing create
   */
  export type DailyClosingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyClosing.
     */
    data: XOR<DailyClosingCreateInput, DailyClosingUncheckedCreateInput>
  }

  /**
   * DailyClosing createMany
   */
  export type DailyClosingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyClosings.
     */
    data: DailyClosingCreateManyInput | DailyClosingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyClosing createManyAndReturn
   */
  export type DailyClosingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyClosings.
     */
    data: DailyClosingCreateManyInput | DailyClosingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyClosing update
   */
  export type DailyClosingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyClosing.
     */
    data: XOR<DailyClosingUpdateInput, DailyClosingUncheckedUpdateInput>
    /**
     * Choose, which DailyClosing to update.
     */
    where: DailyClosingWhereUniqueInput
  }

  /**
   * DailyClosing updateMany
   */
  export type DailyClosingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyClosings.
     */
    data: XOR<DailyClosingUpdateManyMutationInput, DailyClosingUncheckedUpdateManyInput>
    /**
     * Filter which DailyClosings to update
     */
    where?: DailyClosingWhereInput
  }

  /**
   * DailyClosing upsert
   */
  export type DailyClosingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyClosing to update in case it exists.
     */
    where: DailyClosingWhereUniqueInput
    /**
     * In case the DailyClosing found by the `where` argument doesn't exist, create a new DailyClosing with this data.
     */
    create: XOR<DailyClosingCreateInput, DailyClosingUncheckedCreateInput>
    /**
     * In case the DailyClosing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyClosingUpdateInput, DailyClosingUncheckedUpdateInput>
  }

  /**
   * DailyClosing delete
   */
  export type DailyClosingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    /**
     * Filter which DailyClosing to delete.
     */
    where: DailyClosingWhereUniqueInput
  }

  /**
   * DailyClosing deleteMany
   */
  export type DailyClosingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyClosings to delete
     */
    where?: DailyClosingWhereInput
  }

  /**
   * DailyClosing.closedBy
   */
  export type DailyClosing$closedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DailyClosing without action
   */
  export type DailyClosingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    nextInvoiceNumber: number | null
    openingCashBalance: number | null
  }

  export type BranchSumAggregateOutputType = {
    nextInvoiceNumber: number | null
    openingCashBalance: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    code: string | null
    location: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    address: string | null
    allowCrossBranch: boolean | null
    cashCounterEnabled: boolean | null
    email: string | null
    emirate: $Enums.Emirate | null
    googleMapLink: string | null
    invoicePrefix: string | null
    managerId: string | null
    nextInvoiceNumber: number | null
    openingCashBalance: number | null
    receiptPrefix: string | null
    separateNumbering: boolean | null
    type: $Enums.BranchType | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    code: string | null
    location: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    address: string | null
    allowCrossBranch: boolean | null
    cashCounterEnabled: boolean | null
    email: string | null
    emirate: $Enums.Emirate | null
    googleMapLink: string | null
    invoicePrefix: string | null
    managerId: string | null
    nextInvoiceNumber: number | null
    openingCashBalance: number | null
    receiptPrefix: string | null
    separateNumbering: boolean | null
    type: $Enums.BranchType | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    code: number
    location: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    address: number
    allowCrossBranch: number
    cashCounterEnabled: number
    email: number
    emirate: number
    googleMapLink: number
    invoicePrefix: number
    managerId: number
    nextInvoiceNumber: number
    openingCashBalance: number
    receiptPrefix: number
    separateNumbering: number
    type: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    nextInvoiceNumber?: true
    openingCashBalance?: true
  }

  export type BranchSumAggregateInputType = {
    nextInvoiceNumber?: true
    openingCashBalance?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    location?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    address?: true
    allowCrossBranch?: true
    cashCounterEnabled?: true
    email?: true
    emirate?: true
    googleMapLink?: true
    invoicePrefix?: true
    managerId?: true
    nextInvoiceNumber?: true
    openingCashBalance?: true
    receiptPrefix?: true
    separateNumbering?: true
    type?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    location?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    address?: true
    allowCrossBranch?: true
    cashCounterEnabled?: true
    email?: true
    emirate?: true
    googleMapLink?: true
    invoicePrefix?: true
    managerId?: true
    nextInvoiceNumber?: true
    openingCashBalance?: true
    receiptPrefix?: true
    separateNumbering?: true
    type?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    location?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    address?: true
    allowCrossBranch?: true
    cashCounterEnabled?: true
    email?: true
    emirate?: true
    googleMapLink?: true
    invoicePrefix?: true
    managerId?: true
    nextInvoiceNumber?: true
    openingCashBalance?: true
    receiptPrefix?: true
    separateNumbering?: true
    type?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    companyId: string
    name: string
    code: string
    location: string | null
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    address: string | null
    allowCrossBranch: boolean
    cashCounterEnabled: boolean
    email: string | null
    emirate: $Enums.Emirate
    googleMapLink: string | null
    invoicePrefix: string | null
    managerId: string | null
    nextInvoiceNumber: number
    openingCashBalance: number
    receiptPrefix: string | null
    separateNumbering: boolean
    type: $Enums.BranchType
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    location?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: boolean
    emirate?: boolean
    googleMapLink?: boolean
    invoicePrefix?: boolean
    managerId?: boolean
    nextInvoiceNumber?: boolean
    openingCashBalance?: boolean
    receiptPrefix?: boolean
    separateNumbering?: boolean
    type?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    manager?: boolean | Branch$managerArgs<ExtArgs>
    dailyClosings?: boolean | Branch$dailyClosingsArgs<ExtArgs>
    expenses?: boolean | Branch$expensesArgs<ExtArgs>
    invoices?: boolean | Branch$invoicesArgs<ExtArgs>
    journalEntries?: boolean | Branch$journalEntriesArgs<ExtArgs>
    ledgerTransactions?: boolean | Branch$ledgerTransactionsArgs<ExtArgs>
    transactions?: boolean | Branch$transactionsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    vouchers?: boolean | Branch$vouchersArgs<ExtArgs>
    quotations?: boolean | Branch$quotationsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    location?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: boolean
    emirate?: boolean
    googleMapLink?: boolean
    invoicePrefix?: boolean
    managerId?: boolean
    nextInvoiceNumber?: boolean
    openingCashBalance?: boolean
    receiptPrefix?: boolean
    separateNumbering?: boolean
    type?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    manager?: boolean | Branch$managerArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    location?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: boolean
    emirate?: boolean
    googleMapLink?: boolean
    invoicePrefix?: boolean
    managerId?: boolean
    nextInvoiceNumber?: boolean
    openingCashBalance?: boolean
    receiptPrefix?: boolean
    separateNumbering?: boolean
    type?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    manager?: boolean | Branch$managerArgs<ExtArgs>
    dailyClosings?: boolean | Branch$dailyClosingsArgs<ExtArgs>
    expenses?: boolean | Branch$expensesArgs<ExtArgs>
    invoices?: boolean | Branch$invoicesArgs<ExtArgs>
    journalEntries?: boolean | Branch$journalEntriesArgs<ExtArgs>
    ledgerTransactions?: boolean | Branch$ledgerTransactionsArgs<ExtArgs>
    transactions?: boolean | Branch$transactionsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    vouchers?: boolean | Branch$vouchersArgs<ExtArgs>
    quotations?: boolean | Branch$quotationsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    manager?: boolean | Branch$managerArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      manager: Prisma.$UserPayload<ExtArgs> | null
      dailyClosings: Prisma.$DailyClosingPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
      ledgerTransactions: Prisma.$LedgerTransactionPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
      quotations: Prisma.$QuotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      code: string
      location: string | null
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      address: string | null
      allowCrossBranch: boolean
      cashCounterEnabled: boolean
      email: string | null
      emirate: $Enums.Emirate
      googleMapLink: string | null
      invoicePrefix: string | null
      managerId: string | null
      nextInvoiceNumber: number
      openingCashBalance: number
      receiptPrefix: string | null
      separateNumbering: boolean
      type: $Enums.BranchType
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    manager<T extends Branch$managerArgs<ExtArgs> = {}>(args?: Subset<T, Branch$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dailyClosings<T extends Branch$dailyClosingsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$dailyClosingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Branch$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Branch$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    journalEntries<T extends Branch$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany"> | Null>
    ledgerTransactions<T extends Branch$ledgerTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$ledgerTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Branch$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    vouchers<T extends Branch$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany"> | Null>
    quotations<T extends Branch$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly companyId: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly code: FieldRef<"Branch", 'String'>
    readonly location: FieldRef<"Branch", 'String'>
    readonly phone: FieldRef<"Branch", 'String'>
    readonly isActive: FieldRef<"Branch", 'Boolean'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly allowCrossBranch: FieldRef<"Branch", 'Boolean'>
    readonly cashCounterEnabled: FieldRef<"Branch", 'Boolean'>
    readonly email: FieldRef<"Branch", 'String'>
    readonly emirate: FieldRef<"Branch", 'Emirate'>
    readonly googleMapLink: FieldRef<"Branch", 'String'>
    readonly invoicePrefix: FieldRef<"Branch", 'String'>
    readonly managerId: FieldRef<"Branch", 'String'>
    readonly nextInvoiceNumber: FieldRef<"Branch", 'Int'>
    readonly openingCashBalance: FieldRef<"Branch", 'Float'>
    readonly receiptPrefix: FieldRef<"Branch", 'String'>
    readonly separateNumbering: FieldRef<"Branch", 'Boolean'>
    readonly type: FieldRef<"Branch", 'BranchType'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.manager
   */
  export type Branch$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Branch.dailyClosings
   */
  export type Branch$dailyClosingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    where?: DailyClosingWhereInput
    orderBy?: DailyClosingOrderByWithRelationInput | DailyClosingOrderByWithRelationInput[]
    cursor?: DailyClosingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyClosingScalarFieldEnum | DailyClosingScalarFieldEnum[]
  }

  /**
   * Branch.expenses
   */
  export type Branch$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Branch.invoices
   */
  export type Branch$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Branch.journalEntries
   */
  export type Branch$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * Branch.ledgerTransactions
   */
  export type Branch$ledgerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    where?: LedgerTransactionWhereInput
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    cursor?: LedgerTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * Branch.transactions
   */
  export type Branch$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.vouchers
   */
  export type Branch$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Branch.quotations
   */
  export type Branch$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly code: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    module: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    module: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    module: number
    action: number
    description: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    module?: true
    action?: true
    description?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    module?: true
    action?: true
    description?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    module?: true
    action?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    module: string
    action: string
    description: string | null
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    module?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    module?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    module?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      module: string
      action: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly module: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      permission: Prisma.$PermissionPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    createdAt: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    createdAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      createdAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly createdAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLoginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    companyId: string | null
    branchId: string | null
    role: $Enums.UserRole_Legacy | null
    isActive: boolean | null
    forcePasswordChange: boolean | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    lastLoginUserAgent: string | null
    passwordChangedAt: Date | null
    failedLoginAttempts: number | null
    failedLoginResetAt: Date | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    companyId: string | null
    branchId: string | null
    role: $Enums.UserRole_Legacy | null
    isActive: boolean | null
    forcePasswordChange: boolean | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    lastLoginUserAgent: string | null
    passwordChangedAt: Date | null
    failedLoginAttempts: number | null
    failedLoginResetAt: Date | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    firstName: number
    lastName: number
    phone: number
    companyId: number
    branchId: number
    role: number
    isActive: number
    forcePasswordChange: number
    lastLoginAt: number
    lastLoginIp: number
    lastLoginUserAgent: number
    passwordChangedAt: number
    failedLoginAttempts: number
    failedLoginResetAt: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    failedLoginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    companyId?: true
    branchId?: true
    role?: true
    isActive?: true
    forcePasswordChange?: true
    lastLoginAt?: true
    lastLoginIp?: true
    lastLoginUserAgent?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    failedLoginResetAt?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    companyId?: true
    branchId?: true
    role?: true
    isActive?: true
    forcePasswordChange?: true
    lastLoginAt?: true
    lastLoginIp?: true
    lastLoginUserAgent?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    failedLoginResetAt?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    companyId?: true
    branchId?: true
    role?: true
    isActive?: true
    forcePasswordChange?: true
    lastLoginAt?: true
    lastLoginIp?: true
    lastLoginUserAgent?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    failedLoginResetAt?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password: string
    firstName: string | null
    lastName: string | null
    phone: string | null
    companyId: string
    branchId: string | null
    role: $Enums.UserRole_Legacy
    isActive: boolean
    forcePasswordChange: boolean
    lastLoginAt: Date | null
    lastLoginIp: string | null
    lastLoginUserAgent: string | null
    passwordChangedAt: Date | null
    failedLoginAttempts: number
    failedLoginResetAt: Date | null
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    companyId?: boolean
    branchId?: boolean
    role?: boolean
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    lastLoginUserAgent?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    failedLoginResetAt?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvalActions?: boolean | User$approvalActionsArgs<ExtArgs>
    approvalRequests?: boolean | User$approvalRequestsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    managedBranches?: boolean | User$managedBranchesArgs<ExtArgs>
    dailyClosings?: boolean | User$dailyClosingsArgs<ExtArgs>
    expenses?: boolean | User$expensesArgs<ExtArgs>
    accountingLockedPeriods?: boolean | User$accountingLockedPeriodsArgs<ExtArgs>
    unlockedPeriods?: boolean | User$unlockedPeriodsArgs<ExtArgs>
    vatLockedPeriods?: boolean | User$vatLockedPeriodsArgs<ExtArgs>
    yearEndClosedPeriods?: boolean | User$yearEndClosedPeriodsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    vouchers?: boolean | User$vouchersArgs<ExtArgs>
    voucherPayments?: boolean | User$voucherPaymentsArgs<ExtArgs>
    quotations?: boolean | User$quotationsArgs<ExtArgs>
    approvedQuotations?: boolean | User$approvedQuotationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    companyId?: boolean
    branchId?: boolean
    role?: boolean
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    lastLoginUserAgent?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    failedLoginResetAt?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    companyId?: boolean
    branchId?: boolean
    role?: boolean
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    lastLoginUserAgent?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    failedLoginResetAt?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvalActions?: boolean | User$approvalActionsArgs<ExtArgs>
    approvalRequests?: boolean | User$approvalRequestsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    managedBranches?: boolean | User$managedBranchesArgs<ExtArgs>
    dailyClosings?: boolean | User$dailyClosingsArgs<ExtArgs>
    expenses?: boolean | User$expensesArgs<ExtArgs>
    accountingLockedPeriods?: boolean | User$accountingLockedPeriodsArgs<ExtArgs>
    unlockedPeriods?: boolean | User$unlockedPeriodsArgs<ExtArgs>
    vatLockedPeriods?: boolean | User$vatLockedPeriodsArgs<ExtArgs>
    yearEndClosedPeriods?: boolean | User$yearEndClosedPeriodsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    vouchers?: boolean | User$vouchersArgs<ExtArgs>
    voucherPayments?: boolean | User$voucherPaymentsArgs<ExtArgs>
    quotations?: boolean | User$quotationsArgs<ExtArgs>
    approvedQuotations?: boolean | User$approvedQuotationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      approvalActions: Prisma.$ApprovalRequestPayload<ExtArgs>[]
      approvalRequests: Prisma.$ApprovalRequestPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      managedBranches: Prisma.$BranchPayload<ExtArgs>[]
      dailyClosings: Prisma.$DailyClosingPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      accountingLockedPeriods: Prisma.$FinancialPeriodPayload<ExtArgs>[]
      unlockedPeriods: Prisma.$FinancialPeriodPayload<ExtArgs>[]
      vatLockedPeriods: Prisma.$FinancialPeriodPayload<ExtArgs>[]
      yearEndClosedPeriods: Prisma.$FinancialPeriodPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      branch: Prisma.$BranchPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
      voucherPayments: Prisma.$VoucherPaymentPayload<ExtArgs>[]
      quotations: Prisma.$QuotationPayload<ExtArgs>[]
      approvedQuotations: Prisma.$QuotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      password: string
      firstName: string | null
      lastName: string | null
      phone: string | null
      companyId: string
      branchId: string | null
      role: $Enums.UserRole_Legacy
      isActive: boolean
      forcePasswordChange: boolean
      lastLoginAt: Date | null
      lastLoginIp: string | null
      lastLoginUserAgent: string | null
      passwordChangedAt: Date | null
      failedLoginAttempts: number
      failedLoginResetAt: Date | null
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approvalActions<T extends User$approvalActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    approvalRequests<T extends User$approvalRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    managedBranches<T extends User$managedBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$managedBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany"> | Null>
    dailyClosings<T extends User$dailyClosingsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyClosingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyClosingPayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends User$expensesArgs<ExtArgs> = {}>(args?: Subset<T, User$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    accountingLockedPeriods<T extends User$accountingLockedPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountingLockedPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findMany"> | Null>
    unlockedPeriods<T extends User$unlockedPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, User$unlockedPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findMany"> | Null>
    vatLockedPeriods<T extends User$vatLockedPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, User$vatLockedPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findMany"> | Null>
    yearEndClosedPeriods<T extends User$yearEndClosedPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, User$yearEndClosedPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    vouchers<T extends User$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, User$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany"> | Null>
    voucherPayments<T extends User$voucherPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$voucherPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    quotations<T extends User$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, User$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany"> | Null>
    approvedQuotations<T extends User$approvedQuotationsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedQuotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly companyId: FieldRef<"User", 'String'>
    readonly branchId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole_Legacy'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly forcePasswordChange: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginIp: FieldRef<"User", 'String'>
    readonly lastLoginUserAgent: FieldRef<"User", 'String'>
    readonly passwordChangedAt: FieldRef<"User", 'DateTime'>
    readonly failedLoginAttempts: FieldRef<"User", 'Int'>
    readonly failedLoginResetAt: FieldRef<"User", 'DateTime'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.approvalActions
   */
  export type User$approvalActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * User.approvalRequests
   */
  export type User$approvalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.managedBranches
   */
  export type User$managedBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * User.dailyClosings
   */
  export type User$dailyClosingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyClosing
     */
    select?: DailyClosingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyClosingInclude<ExtArgs> | null
    where?: DailyClosingWhereInput
    orderBy?: DailyClosingOrderByWithRelationInput | DailyClosingOrderByWithRelationInput[]
    cursor?: DailyClosingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyClosingScalarFieldEnum | DailyClosingScalarFieldEnum[]
  }

  /**
   * User.expenses
   */
  export type User$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * User.accountingLockedPeriods
   */
  export type User$accountingLockedPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    where?: FinancialPeriodWhereInput
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    cursor?: FinancialPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * User.unlockedPeriods
   */
  export type User$unlockedPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    where?: FinancialPeriodWhereInput
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    cursor?: FinancialPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * User.vatLockedPeriods
   */
  export type User$vatLockedPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    where?: FinancialPeriodWhereInput
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    cursor?: FinancialPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * User.yearEndClosedPeriods
   */
  export type User$yearEndClosedPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    where?: FinancialPeriodWhereInput
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    cursor?: FinancialPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.vouchers
   */
  export type User$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * User.voucherPayments
   */
  export type User$voucherPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    where?: VoucherPaymentWhereInput
    orderBy?: VoucherPaymentOrderByWithRelationInput | VoucherPaymentOrderByWithRelationInput[]
    cursor?: VoucherPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherPaymentScalarFieldEnum | VoucherPaymentScalarFieldEnum[]
  }

  /**
   * User.quotations
   */
  export type User$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * User.approvedQuotations
   */
  export type User$approvedQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    lastActivity: Date | null
    createdAt: Date | null
    isValid: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    lastActivity: Date | null
    createdAt: Date | null
    isValid: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    lastActivity: number
    createdAt: number
    isValid: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    lastActivity?: true
    createdAt?: true
    isValid?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    lastActivity?: true
    createdAt?: true
    isValid?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    lastActivity?: true
    createdAt?: true
    isValid?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    lastActivity: Date
    createdAt: Date
    isValid: boolean
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    isValid?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    isValid?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    isValid?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      lastActivity: Date
      createdAt: Date
      isValid: boolean
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly lastActivity: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly isValid: FieldRef<"Session", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    action: string | null
    module: string | null
    recordId: string | null
    recordType: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    action: string | null
    module: string | null
    recordId: string | null
    recordType: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    companyId: number
    userId: number
    action: number
    module: number
    recordId: number
    recordType: number
    oldValue: number
    newValue: number
    ipAddress: number
    userAgent: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    action?: true
    module?: true
    recordId?: true
    recordType?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    action?: true
    module?: true
    recordId?: true
    recordType?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    action?: true
    module?: true
    recordId?: true
    recordType?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    companyId: string
    userId: string | null
    action: string
    module: string
    recordId: string | null
    recordType: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    recordId?: boolean
    recordType?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    recordId?: boolean
    recordType?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    companyId?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    recordId?: boolean
    recordType?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      userId: string | null
      action: string
      module: string
      recordId: string | null
      recordType: string | null
      oldValue: string | null
      newValue: string | null
      ipAddress: string | null
      userAgent: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly companyId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly module: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly recordType: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'String'>
    readonly newValue: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalRequest
   */

  export type AggregateApprovalRequest = {
    _count: ApprovalRequestCountAggregateOutputType | null
    _min: ApprovalRequestMinAggregateOutputType | null
    _max: ApprovalRequestMaxAggregateOutputType | null
  }

  export type ApprovalRequestMinAggregateOutputType = {
    id: string | null
    requesterId: string | null
    approverId: string | null
    module: string | null
    action: string | null
    recordId: string | null
    recordType: string | null
    reason: string | null
    status: $Enums.ApprovalStatus | null
    approvedAt: Date | null
    rejectedAt: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalRequestMaxAggregateOutputType = {
    id: string | null
    requesterId: string | null
    approverId: string | null
    module: string | null
    action: string | null
    recordId: string | null
    recordType: string | null
    reason: string | null
    status: $Enums.ApprovalStatus | null
    approvedAt: Date | null
    rejectedAt: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalRequestCountAggregateOutputType = {
    id: number
    requesterId: number
    approverId: number
    module: number
    action: number
    recordId: number
    recordType: number
    reason: number
    status: number
    approvedAt: number
    rejectedAt: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalRequestMinAggregateInputType = {
    id?: true
    requesterId?: true
    approverId?: true
    module?: true
    action?: true
    recordId?: true
    recordType?: true
    reason?: true
    status?: true
    approvedAt?: true
    rejectedAt?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalRequestMaxAggregateInputType = {
    id?: true
    requesterId?: true
    approverId?: true
    module?: true
    action?: true
    recordId?: true
    recordType?: true
    reason?: true
    status?: true
    approvedAt?: true
    rejectedAt?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalRequestCountAggregateInputType = {
    id?: true
    requesterId?: true
    approverId?: true
    module?: true
    action?: true
    recordId?: true
    recordType?: true
    reason?: true
    status?: true
    approvedAt?: true
    rejectedAt?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalRequest to aggregate.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalRequests
    **/
    _count?: true | ApprovalRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalRequestMaxAggregateInputType
  }

  export type GetApprovalRequestAggregateType<T extends ApprovalRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalRequest[P]>
      : GetScalarType<T[P], AggregateApprovalRequest[P]>
  }




  export type ApprovalRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithAggregationInput | ApprovalRequestOrderByWithAggregationInput[]
    by: ApprovalRequestScalarFieldEnum[] | ApprovalRequestScalarFieldEnum
    having?: ApprovalRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalRequestCountAggregateInputType | true
    _min?: ApprovalRequestMinAggregateInputType
    _max?: ApprovalRequestMaxAggregateInputType
  }

  export type ApprovalRequestGroupByOutputType = {
    id: string
    requesterId: string
    approverId: string | null
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status: $Enums.ApprovalStatus
    approvedAt: Date | null
    rejectedAt: Date | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: ApprovalRequestCountAggregateOutputType | null
    _min: ApprovalRequestMinAggregateOutputType | null
    _max: ApprovalRequestMaxAggregateOutputType | null
  }

  type GetApprovalRequestGroupByPayload<T extends ApprovalRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalRequestGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    approverId?: boolean
    module?: boolean
    action?: boolean
    recordId?: boolean
    recordType?: boolean
    reason?: boolean
    status?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approver?: boolean | ApprovalRequest$approverArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalRequest"]>

  export type ApprovalRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    approverId?: boolean
    module?: boolean
    action?: boolean
    recordId?: boolean
    recordType?: boolean
    reason?: boolean
    status?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approver?: boolean | ApprovalRequest$approverArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalRequest"]>

  export type ApprovalRequestSelectScalar = {
    id?: boolean
    requesterId?: boolean
    approverId?: boolean
    module?: boolean
    action?: boolean
    recordId?: boolean
    recordType?: boolean
    reason?: boolean
    status?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | ApprovalRequest$approverArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApprovalRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | ApprovalRequest$approverArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApprovalRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalRequest"
    objects: {
      approver: Prisma.$UserPayload<ExtArgs> | null
      requester: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requesterId: string
      approverId: string | null
      module: string
      action: string
      recordId: string
      recordType: string
      reason: string
      status: $Enums.ApprovalStatus
      approvedAt: Date | null
      rejectedAt: Date | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvalRequest"]>
    composites: {}
  }

  type ApprovalRequestGetPayload<S extends boolean | null | undefined | ApprovalRequestDefaultArgs> = $Result.GetResult<Prisma.$ApprovalRequestPayload, S>

  type ApprovalRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalRequestCountAggregateInputType | true
    }

  export interface ApprovalRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalRequest'], meta: { name: 'ApprovalRequest' } }
    /**
     * Find zero or one ApprovalRequest that matches the filter.
     * @param {ApprovalRequestFindUniqueArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalRequestFindUniqueArgs>(args: SelectSubset<T, ApprovalRequestFindUniqueArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApprovalRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalRequestFindUniqueOrThrowArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApprovalRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindFirstArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalRequestFindFirstArgs>(args?: SelectSubset<T, ApprovalRequestFindFirstArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApprovalRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindFirstOrThrowArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApprovalRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalRequests
     * const approvalRequests = await prisma.approvalRequest.findMany()
     * 
     * // Get first 10 ApprovalRequests
     * const approvalRequests = await prisma.approvalRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalRequestWithIdOnly = await prisma.approvalRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalRequestFindManyArgs>(args?: SelectSubset<T, ApprovalRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApprovalRequest.
     * @param {ApprovalRequestCreateArgs} args - Arguments to create a ApprovalRequest.
     * @example
     * // Create one ApprovalRequest
     * const ApprovalRequest = await prisma.approvalRequest.create({
     *   data: {
     *     // ... data to create a ApprovalRequest
     *   }
     * })
     * 
     */
    create<T extends ApprovalRequestCreateArgs>(args: SelectSubset<T, ApprovalRequestCreateArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApprovalRequests.
     * @param {ApprovalRequestCreateManyArgs} args - Arguments to create many ApprovalRequests.
     * @example
     * // Create many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalRequestCreateManyArgs>(args?: SelectSubset<T, ApprovalRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalRequests and returns the data saved in the database.
     * @param {ApprovalRequestCreateManyAndReturnArgs} args - Arguments to create many ApprovalRequests.
     * @example
     * // Create many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalRequests and only return the `id`
     * const approvalRequestWithIdOnly = await prisma.approvalRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApprovalRequest.
     * @param {ApprovalRequestDeleteArgs} args - Arguments to delete one ApprovalRequest.
     * @example
     * // Delete one ApprovalRequest
     * const ApprovalRequest = await prisma.approvalRequest.delete({
     *   where: {
     *     // ... filter to delete one ApprovalRequest
     *   }
     * })
     * 
     */
    delete<T extends ApprovalRequestDeleteArgs>(args: SelectSubset<T, ApprovalRequestDeleteArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApprovalRequest.
     * @param {ApprovalRequestUpdateArgs} args - Arguments to update one ApprovalRequest.
     * @example
     * // Update one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalRequestUpdateArgs>(args: SelectSubset<T, ApprovalRequestUpdateArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApprovalRequests.
     * @param {ApprovalRequestDeleteManyArgs} args - Arguments to filter ApprovalRequests to delete.
     * @example
     * // Delete a few ApprovalRequests
     * const { count } = await prisma.approvalRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalRequestDeleteManyArgs>(args?: SelectSubset<T, ApprovalRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalRequestUpdateManyArgs>(args: SelectSubset<T, ApprovalRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovalRequest.
     * @param {ApprovalRequestUpsertArgs} args - Arguments to update or create a ApprovalRequest.
     * @example
     * // Update or create a ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.upsert({
     *   create: {
     *     // ... data to create a ApprovalRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalRequest we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalRequestUpsertArgs>(args: SelectSubset<T, ApprovalRequestUpsertArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApprovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestCountArgs} args - Arguments to filter ApprovalRequests to count.
     * @example
     * // Count the number of ApprovalRequests
     * const count = await prisma.approvalRequest.count({
     *   where: {
     *     // ... the filter for the ApprovalRequests we want to count
     *   }
     * })
    **/
    count<T extends ApprovalRequestCountArgs>(
      args?: Subset<T, ApprovalRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalRequestAggregateArgs>(args: Subset<T, ApprovalRequestAggregateArgs>): Prisma.PrismaPromise<GetApprovalRequestAggregateType<T>>

    /**
     * Group by ApprovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalRequestGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalRequest model
   */
  readonly fields: ApprovalRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approver<T extends ApprovalRequest$approverArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalRequest$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalRequest model
   */ 
  interface ApprovalRequestFieldRefs {
    readonly id: FieldRef<"ApprovalRequest", 'String'>
    readonly requesterId: FieldRef<"ApprovalRequest", 'String'>
    readonly approverId: FieldRef<"ApprovalRequest", 'String'>
    readonly module: FieldRef<"ApprovalRequest", 'String'>
    readonly action: FieldRef<"ApprovalRequest", 'String'>
    readonly recordId: FieldRef<"ApprovalRequest", 'String'>
    readonly recordType: FieldRef<"ApprovalRequest", 'String'>
    readonly reason: FieldRef<"ApprovalRequest", 'String'>
    readonly status: FieldRef<"ApprovalRequest", 'ApprovalStatus'>
    readonly approvedAt: FieldRef<"ApprovalRequest", 'DateTime'>
    readonly rejectedAt: FieldRef<"ApprovalRequest", 'DateTime'>
    readonly comments: FieldRef<"ApprovalRequest", 'String'>
    readonly createdAt: FieldRef<"ApprovalRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalRequest findUnique
   */
  export type ApprovalRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest findUniqueOrThrow
   */
  export type ApprovalRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest findFirst
   */
  export type ApprovalRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalRequests.
     */
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest findFirstOrThrow
   */
  export type ApprovalRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalRequests.
     */
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest findMany
   */
  export type ApprovalRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequests to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest create
   */
  export type ApprovalRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalRequest.
     */
    data: XOR<ApprovalRequestCreateInput, ApprovalRequestUncheckedCreateInput>
  }

  /**
   * ApprovalRequest createMany
   */
  export type ApprovalRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalRequests.
     */
    data: ApprovalRequestCreateManyInput | ApprovalRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalRequest createManyAndReturn
   */
  export type ApprovalRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApprovalRequests.
     */
    data: ApprovalRequestCreateManyInput | ApprovalRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalRequest update
   */
  export type ApprovalRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalRequest.
     */
    data: XOR<ApprovalRequestUpdateInput, ApprovalRequestUncheckedUpdateInput>
    /**
     * Choose, which ApprovalRequest to update.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest updateMany
   */
  export type ApprovalRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalRequests.
     */
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalRequests to update
     */
    where?: ApprovalRequestWhereInput
  }

  /**
   * ApprovalRequest upsert
   */
  export type ApprovalRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalRequest to update in case it exists.
     */
    where: ApprovalRequestWhereUniqueInput
    /**
     * In case the ApprovalRequest found by the `where` argument doesn't exist, create a new ApprovalRequest with this data.
     */
    create: XOR<ApprovalRequestCreateInput, ApprovalRequestUncheckedCreateInput>
    /**
     * In case the ApprovalRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalRequestUpdateInput, ApprovalRequestUncheckedUpdateInput>
  }

  /**
   * ApprovalRequest delete
   */
  export type ApprovalRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter which ApprovalRequest to delete.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest deleteMany
   */
  export type ApprovalRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalRequests to delete
     */
    where?: ApprovalRequestWhereInput
  }

  /**
   * ApprovalRequest.approver
   */
  export type ApprovalRequest$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ApprovalRequest without action
   */
  export type ApprovalRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
  }


  /**
   * Model FinancialPeriod
   */

  export type AggregateFinancialPeriod = {
    _count: FinancialPeriodCountAggregateOutputType | null
    _avg: FinancialPeriodAvgAggregateOutputType | null
    _sum: FinancialPeriodSumAggregateOutputType | null
    _min: FinancialPeriodMinAggregateOutputType | null
    _max: FinancialPeriodMaxAggregateOutputType | null
  }

  export type FinancialPeriodAvgAggregateOutputType = {
    year: number | null
    month: number | null
  }

  export type FinancialPeriodSumAggregateOutputType = {
    year: number | null
    month: number | null
  }

  export type FinancialPeriodMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    year: number | null
    month: number | null
    createdAt: Date | null
    updatedAt: Date | null
    accountingLocked: boolean | null
    accountingLockedAt: Date | null
    accountingLockedById: string | null
    isYearEndClosed: boolean | null
    lastUnlockReason: string | null
    lastUnlockedAt: Date | null
    lastUnlockedById: string | null
    periodEnd: Date | null
    periodStart: Date | null
    vatLocked: boolean | null
    vatLockedAt: Date | null
    vatLockedById: string | null
    yearEndClosedAt: Date | null
    yearEndClosedById: string | null
  }

  export type FinancialPeriodMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    year: number | null
    month: number | null
    createdAt: Date | null
    updatedAt: Date | null
    accountingLocked: boolean | null
    accountingLockedAt: Date | null
    accountingLockedById: string | null
    isYearEndClosed: boolean | null
    lastUnlockReason: string | null
    lastUnlockedAt: Date | null
    lastUnlockedById: string | null
    periodEnd: Date | null
    periodStart: Date | null
    vatLocked: boolean | null
    vatLockedAt: Date | null
    vatLockedById: string | null
    yearEndClosedAt: Date | null
    yearEndClosedById: string | null
  }

  export type FinancialPeriodCountAggregateOutputType = {
    id: number
    companyId: number
    year: number
    month: number
    createdAt: number
    updatedAt: number
    accountingLocked: number
    accountingLockedAt: number
    accountingLockedById: number
    isYearEndClosed: number
    lastUnlockReason: number
    lastUnlockedAt: number
    lastUnlockedById: number
    periodEnd: number
    periodStart: number
    vatLocked: number
    vatLockedAt: number
    vatLockedById: number
    yearEndClosedAt: number
    yearEndClosedById: number
    _all: number
  }


  export type FinancialPeriodAvgAggregateInputType = {
    year?: true
    month?: true
  }

  export type FinancialPeriodSumAggregateInputType = {
    year?: true
    month?: true
  }

  export type FinancialPeriodMinAggregateInputType = {
    id?: true
    companyId?: true
    year?: true
    month?: true
    createdAt?: true
    updatedAt?: true
    accountingLocked?: true
    accountingLockedAt?: true
    accountingLockedById?: true
    isYearEndClosed?: true
    lastUnlockReason?: true
    lastUnlockedAt?: true
    lastUnlockedById?: true
    periodEnd?: true
    periodStart?: true
    vatLocked?: true
    vatLockedAt?: true
    vatLockedById?: true
    yearEndClosedAt?: true
    yearEndClosedById?: true
  }

  export type FinancialPeriodMaxAggregateInputType = {
    id?: true
    companyId?: true
    year?: true
    month?: true
    createdAt?: true
    updatedAt?: true
    accountingLocked?: true
    accountingLockedAt?: true
    accountingLockedById?: true
    isYearEndClosed?: true
    lastUnlockReason?: true
    lastUnlockedAt?: true
    lastUnlockedById?: true
    periodEnd?: true
    periodStart?: true
    vatLocked?: true
    vatLockedAt?: true
    vatLockedById?: true
    yearEndClosedAt?: true
    yearEndClosedById?: true
  }

  export type FinancialPeriodCountAggregateInputType = {
    id?: true
    companyId?: true
    year?: true
    month?: true
    createdAt?: true
    updatedAt?: true
    accountingLocked?: true
    accountingLockedAt?: true
    accountingLockedById?: true
    isYearEndClosed?: true
    lastUnlockReason?: true
    lastUnlockedAt?: true
    lastUnlockedById?: true
    periodEnd?: true
    periodStart?: true
    vatLocked?: true
    vatLockedAt?: true
    vatLockedById?: true
    yearEndClosedAt?: true
    yearEndClosedById?: true
    _all?: true
  }

  export type FinancialPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialPeriod to aggregate.
     */
    where?: FinancialPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialPeriods to fetch.
     */
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialPeriods
    **/
    _count?: true | FinancialPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialPeriodMaxAggregateInputType
  }

  export type GetFinancialPeriodAggregateType<T extends FinancialPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialPeriod[P]>
      : GetScalarType<T[P], AggregateFinancialPeriod[P]>
  }




  export type FinancialPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialPeriodWhereInput
    orderBy?: FinancialPeriodOrderByWithAggregationInput | FinancialPeriodOrderByWithAggregationInput[]
    by: FinancialPeriodScalarFieldEnum[] | FinancialPeriodScalarFieldEnum
    having?: FinancialPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialPeriodCountAggregateInputType | true
    _avg?: FinancialPeriodAvgAggregateInputType
    _sum?: FinancialPeriodSumAggregateInputType
    _min?: FinancialPeriodMinAggregateInputType
    _max?: FinancialPeriodMaxAggregateInputType
  }

  export type FinancialPeriodGroupByOutputType = {
    id: string
    companyId: string
    year: number
    month: number
    createdAt: Date
    updatedAt: Date
    accountingLocked: boolean
    accountingLockedAt: Date | null
    accountingLockedById: string | null
    isYearEndClosed: boolean
    lastUnlockReason: string | null
    lastUnlockedAt: Date | null
    lastUnlockedById: string | null
    periodEnd: Date
    periodStart: Date
    vatLocked: boolean
    vatLockedAt: Date | null
    vatLockedById: string | null
    yearEndClosedAt: Date | null
    yearEndClosedById: string | null
    _count: FinancialPeriodCountAggregateOutputType | null
    _avg: FinancialPeriodAvgAggregateOutputType | null
    _sum: FinancialPeriodSumAggregateOutputType | null
    _min: FinancialPeriodMinAggregateOutputType | null
    _max: FinancialPeriodMaxAggregateOutputType | null
  }

  type GetFinancialPeriodGroupByPayload<T extends FinancialPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialPeriodGroupByOutputType[P]>
        }
      >
    >


  export type FinancialPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    year?: boolean
    month?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountingLocked?: boolean
    accountingLockedAt?: boolean
    accountingLockedById?: boolean
    isYearEndClosed?: boolean
    lastUnlockReason?: boolean
    lastUnlockedAt?: boolean
    lastUnlockedById?: boolean
    periodEnd?: boolean
    periodStart?: boolean
    vatLocked?: boolean
    vatLockedAt?: boolean
    vatLockedById?: boolean
    yearEndClosedAt?: boolean
    yearEndClosedById?: boolean
    accountingLockedBy?: boolean | FinancialPeriod$accountingLockedByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    lastUnlockedBy?: boolean | FinancialPeriod$lastUnlockedByArgs<ExtArgs>
    vatLockedBy?: boolean | FinancialPeriod$vatLockedByArgs<ExtArgs>
    yearEndClosedBy?: boolean | FinancialPeriod$yearEndClosedByArgs<ExtArgs>
  }, ExtArgs["result"]["financialPeriod"]>

  export type FinancialPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    year?: boolean
    month?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountingLocked?: boolean
    accountingLockedAt?: boolean
    accountingLockedById?: boolean
    isYearEndClosed?: boolean
    lastUnlockReason?: boolean
    lastUnlockedAt?: boolean
    lastUnlockedById?: boolean
    periodEnd?: boolean
    periodStart?: boolean
    vatLocked?: boolean
    vatLockedAt?: boolean
    vatLockedById?: boolean
    yearEndClosedAt?: boolean
    yearEndClosedById?: boolean
    accountingLockedBy?: boolean | FinancialPeriod$accountingLockedByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    lastUnlockedBy?: boolean | FinancialPeriod$lastUnlockedByArgs<ExtArgs>
    vatLockedBy?: boolean | FinancialPeriod$vatLockedByArgs<ExtArgs>
    yearEndClosedBy?: boolean | FinancialPeriod$yearEndClosedByArgs<ExtArgs>
  }, ExtArgs["result"]["financialPeriod"]>

  export type FinancialPeriodSelectScalar = {
    id?: boolean
    companyId?: boolean
    year?: boolean
    month?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountingLocked?: boolean
    accountingLockedAt?: boolean
    accountingLockedById?: boolean
    isYearEndClosed?: boolean
    lastUnlockReason?: boolean
    lastUnlockedAt?: boolean
    lastUnlockedById?: boolean
    periodEnd?: boolean
    periodStart?: boolean
    vatLocked?: boolean
    vatLockedAt?: boolean
    vatLockedById?: boolean
    yearEndClosedAt?: boolean
    yearEndClosedById?: boolean
  }

  export type FinancialPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountingLockedBy?: boolean | FinancialPeriod$accountingLockedByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    lastUnlockedBy?: boolean | FinancialPeriod$lastUnlockedByArgs<ExtArgs>
    vatLockedBy?: boolean | FinancialPeriod$vatLockedByArgs<ExtArgs>
    yearEndClosedBy?: boolean | FinancialPeriod$yearEndClosedByArgs<ExtArgs>
  }
  export type FinancialPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountingLockedBy?: boolean | FinancialPeriod$accountingLockedByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    lastUnlockedBy?: boolean | FinancialPeriod$lastUnlockedByArgs<ExtArgs>
    vatLockedBy?: boolean | FinancialPeriod$vatLockedByArgs<ExtArgs>
    yearEndClosedBy?: boolean | FinancialPeriod$yearEndClosedByArgs<ExtArgs>
  }

  export type $FinancialPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialPeriod"
    objects: {
      accountingLockedBy: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      lastUnlockedBy: Prisma.$UserPayload<ExtArgs> | null
      vatLockedBy: Prisma.$UserPayload<ExtArgs> | null
      yearEndClosedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      year: number
      month: number
      createdAt: Date
      updatedAt: Date
      accountingLocked: boolean
      accountingLockedAt: Date | null
      accountingLockedById: string | null
      isYearEndClosed: boolean
      lastUnlockReason: string | null
      lastUnlockedAt: Date | null
      lastUnlockedById: string | null
      periodEnd: Date
      periodStart: Date
      vatLocked: boolean
      vatLockedAt: Date | null
      vatLockedById: string | null
      yearEndClosedAt: Date | null
      yearEndClosedById: string | null
    }, ExtArgs["result"]["financialPeriod"]>
    composites: {}
  }

  type FinancialPeriodGetPayload<S extends boolean | null | undefined | FinancialPeriodDefaultArgs> = $Result.GetResult<Prisma.$FinancialPeriodPayload, S>

  type FinancialPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancialPeriodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancialPeriodCountAggregateInputType | true
    }

  export interface FinancialPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialPeriod'], meta: { name: 'FinancialPeriod' } }
    /**
     * Find zero or one FinancialPeriod that matches the filter.
     * @param {FinancialPeriodFindUniqueArgs} args - Arguments to find a FinancialPeriod
     * @example
     * // Get one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialPeriodFindUniqueArgs>(args: SelectSubset<T, FinancialPeriodFindUniqueArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinancialPeriod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancialPeriodFindUniqueOrThrowArgs} args - Arguments to find a FinancialPeriod
     * @example
     * // Get one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinancialPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodFindFirstArgs} args - Arguments to find a FinancialPeriod
     * @example
     * // Get one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialPeriodFindFirstArgs>(args?: SelectSubset<T, FinancialPeriodFindFirstArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinancialPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodFindFirstOrThrowArgs} args - Arguments to find a FinancialPeriod
     * @example
     * // Get one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinancialPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialPeriods
     * const financialPeriods = await prisma.financialPeriod.findMany()
     * 
     * // Get first 10 FinancialPeriods
     * const financialPeriods = await prisma.financialPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialPeriodWithIdOnly = await prisma.financialPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialPeriodFindManyArgs>(args?: SelectSubset<T, FinancialPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinancialPeriod.
     * @param {FinancialPeriodCreateArgs} args - Arguments to create a FinancialPeriod.
     * @example
     * // Create one FinancialPeriod
     * const FinancialPeriod = await prisma.financialPeriod.create({
     *   data: {
     *     // ... data to create a FinancialPeriod
     *   }
     * })
     * 
     */
    create<T extends FinancialPeriodCreateArgs>(args: SelectSubset<T, FinancialPeriodCreateArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinancialPeriods.
     * @param {FinancialPeriodCreateManyArgs} args - Arguments to create many FinancialPeriods.
     * @example
     * // Create many FinancialPeriods
     * const financialPeriod = await prisma.financialPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialPeriodCreateManyArgs>(args?: SelectSubset<T, FinancialPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialPeriods and returns the data saved in the database.
     * @param {FinancialPeriodCreateManyAndReturnArgs} args - Arguments to create many FinancialPeriods.
     * @example
     * // Create many FinancialPeriods
     * const financialPeriod = await prisma.financialPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialPeriods and only return the `id`
     * const financialPeriodWithIdOnly = await prisma.financialPeriod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FinancialPeriod.
     * @param {FinancialPeriodDeleteArgs} args - Arguments to delete one FinancialPeriod.
     * @example
     * // Delete one FinancialPeriod
     * const FinancialPeriod = await prisma.financialPeriod.delete({
     *   where: {
     *     // ... filter to delete one FinancialPeriod
     *   }
     * })
     * 
     */
    delete<T extends FinancialPeriodDeleteArgs>(args: SelectSubset<T, FinancialPeriodDeleteArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinancialPeriod.
     * @param {FinancialPeriodUpdateArgs} args - Arguments to update one FinancialPeriod.
     * @example
     * // Update one FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialPeriodUpdateArgs>(args: SelectSubset<T, FinancialPeriodUpdateArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinancialPeriods.
     * @param {FinancialPeriodDeleteManyArgs} args - Arguments to filter FinancialPeriods to delete.
     * @example
     * // Delete a few FinancialPeriods
     * const { count } = await prisma.financialPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialPeriodDeleteManyArgs>(args?: SelectSubset<T, FinancialPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialPeriods
     * const financialPeriod = await prisma.financialPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialPeriodUpdateManyArgs>(args: SelectSubset<T, FinancialPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancialPeriod.
     * @param {FinancialPeriodUpsertArgs} args - Arguments to update or create a FinancialPeriod.
     * @example
     * // Update or create a FinancialPeriod
     * const financialPeriod = await prisma.financialPeriod.upsert({
     *   create: {
     *     // ... data to create a FinancialPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialPeriod we want to update
     *   }
     * })
     */
    upsert<T extends FinancialPeriodUpsertArgs>(args: SelectSubset<T, FinancialPeriodUpsertArgs<ExtArgs>>): Prisma__FinancialPeriodClient<$Result.GetResult<Prisma.$FinancialPeriodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinancialPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodCountArgs} args - Arguments to filter FinancialPeriods to count.
     * @example
     * // Count the number of FinancialPeriods
     * const count = await prisma.financialPeriod.count({
     *   where: {
     *     // ... the filter for the FinancialPeriods we want to count
     *   }
     * })
    **/
    count<T extends FinancialPeriodCountArgs>(
      args?: Subset<T, FinancialPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialPeriodAggregateArgs>(args: Subset<T, FinancialPeriodAggregateArgs>): Prisma.PrismaPromise<GetFinancialPeriodAggregateType<T>>

    /**
     * Group by FinancialPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialPeriodGroupByArgs['orderBy'] }
        : { orderBy?: FinancialPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialPeriod model
   */
  readonly fields: FinancialPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountingLockedBy<T extends FinancialPeriod$accountingLockedByArgs<ExtArgs> = {}>(args?: Subset<T, FinancialPeriod$accountingLockedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lastUnlockedBy<T extends FinancialPeriod$lastUnlockedByArgs<ExtArgs> = {}>(args?: Subset<T, FinancialPeriod$lastUnlockedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vatLockedBy<T extends FinancialPeriod$vatLockedByArgs<ExtArgs> = {}>(args?: Subset<T, FinancialPeriod$vatLockedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    yearEndClosedBy<T extends FinancialPeriod$yearEndClosedByArgs<ExtArgs> = {}>(args?: Subset<T, FinancialPeriod$yearEndClosedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialPeriod model
   */ 
  interface FinancialPeriodFieldRefs {
    readonly id: FieldRef<"FinancialPeriod", 'String'>
    readonly companyId: FieldRef<"FinancialPeriod", 'String'>
    readonly year: FieldRef<"FinancialPeriod", 'Int'>
    readonly month: FieldRef<"FinancialPeriod", 'Int'>
    readonly createdAt: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly accountingLocked: FieldRef<"FinancialPeriod", 'Boolean'>
    readonly accountingLockedAt: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly accountingLockedById: FieldRef<"FinancialPeriod", 'String'>
    readonly isYearEndClosed: FieldRef<"FinancialPeriod", 'Boolean'>
    readonly lastUnlockReason: FieldRef<"FinancialPeriod", 'String'>
    readonly lastUnlockedAt: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly lastUnlockedById: FieldRef<"FinancialPeriod", 'String'>
    readonly periodEnd: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly periodStart: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly vatLocked: FieldRef<"FinancialPeriod", 'Boolean'>
    readonly vatLockedAt: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly vatLockedById: FieldRef<"FinancialPeriod", 'String'>
    readonly yearEndClosedAt: FieldRef<"FinancialPeriod", 'DateTime'>
    readonly yearEndClosedById: FieldRef<"FinancialPeriod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FinancialPeriod findUnique
   */
  export type FinancialPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriod to fetch.
     */
    where: FinancialPeriodWhereUniqueInput
  }

  /**
   * FinancialPeriod findUniqueOrThrow
   */
  export type FinancialPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriod to fetch.
     */
    where: FinancialPeriodWhereUniqueInput
  }

  /**
   * FinancialPeriod findFirst
   */
  export type FinancialPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriod to fetch.
     */
    where?: FinancialPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialPeriods to fetch.
     */
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialPeriods.
     */
    cursor?: FinancialPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialPeriods.
     */
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * FinancialPeriod findFirstOrThrow
   */
  export type FinancialPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriod to fetch.
     */
    where?: FinancialPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialPeriods to fetch.
     */
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialPeriods.
     */
    cursor?: FinancialPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialPeriods.
     */
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * FinancialPeriod findMany
   */
  export type FinancialPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FinancialPeriods to fetch.
     */
    where?: FinancialPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialPeriods to fetch.
     */
    orderBy?: FinancialPeriodOrderByWithRelationInput | FinancialPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialPeriods.
     */
    cursor?: FinancialPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialPeriods.
     */
    skip?: number
    distinct?: FinancialPeriodScalarFieldEnum | FinancialPeriodScalarFieldEnum[]
  }

  /**
   * FinancialPeriod create
   */
  export type FinancialPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialPeriod.
     */
    data: XOR<FinancialPeriodCreateInput, FinancialPeriodUncheckedCreateInput>
  }

  /**
   * FinancialPeriod createMany
   */
  export type FinancialPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialPeriods.
     */
    data: FinancialPeriodCreateManyInput | FinancialPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialPeriod createManyAndReturn
   */
  export type FinancialPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FinancialPeriods.
     */
    data: FinancialPeriodCreateManyInput | FinancialPeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialPeriod update
   */
  export type FinancialPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialPeriod.
     */
    data: XOR<FinancialPeriodUpdateInput, FinancialPeriodUncheckedUpdateInput>
    /**
     * Choose, which FinancialPeriod to update.
     */
    where: FinancialPeriodWhereUniqueInput
  }

  /**
   * FinancialPeriod updateMany
   */
  export type FinancialPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialPeriods.
     */
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyInput>
    /**
     * Filter which FinancialPeriods to update
     */
    where?: FinancialPeriodWhereInput
  }

  /**
   * FinancialPeriod upsert
   */
  export type FinancialPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialPeriod to update in case it exists.
     */
    where: FinancialPeriodWhereUniqueInput
    /**
     * In case the FinancialPeriod found by the `where` argument doesn't exist, create a new FinancialPeriod with this data.
     */
    create: XOR<FinancialPeriodCreateInput, FinancialPeriodUncheckedCreateInput>
    /**
     * In case the FinancialPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialPeriodUpdateInput, FinancialPeriodUncheckedUpdateInput>
  }

  /**
   * FinancialPeriod delete
   */
  export type FinancialPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
    /**
     * Filter which FinancialPeriod to delete.
     */
    where: FinancialPeriodWhereUniqueInput
  }

  /**
   * FinancialPeriod deleteMany
   */
  export type FinancialPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialPeriods to delete
     */
    where?: FinancialPeriodWhereInput
  }

  /**
   * FinancialPeriod.accountingLockedBy
   */
  export type FinancialPeriod$accountingLockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FinancialPeriod.lastUnlockedBy
   */
  export type FinancialPeriod$lastUnlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FinancialPeriod.vatLockedBy
   */
  export type FinancialPeriod$vatLockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FinancialPeriod.yearEndClosedBy
   */
  export type FinancialPeriod$yearEndClosedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FinancialPeriod without action
   */
  export type FinancialPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialPeriod
     */
    select?: FinancialPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialPeriodInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    balance: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    balance: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    date: Date | null
    companyId: string | null
    branchId: string | null
    customerId: string | null
    customerName: string | null
    agentId: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    balance: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentRef: string | null
    bankName: string | null
    status: $Enums.InvoiceStatus | null
    govtFeeAccountId: string | null
    govtFeeRef: string | null
    customerPhone: string | null
    customerEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
    quotationId: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    date: Date | null
    companyId: string | null
    branchId: string | null
    customerId: string | null
    customerName: string | null
    agentId: string | null
    subtotal: Decimal | null
    tax: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    balance: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentRef: string | null
    bankName: string | null
    status: $Enums.InvoiceStatus | null
    govtFeeAccountId: string | null
    govtFeeRef: string | null
    customerPhone: string | null
    customerEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
    quotationId: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNo: number
    date: number
    companyId: number
    branchId: number
    customerId: number
    customerName: number
    agentId: number
    subtotal: number
    tax: number
    discount: number
    total: number
    paidAmount: number
    balance: number
    paymentMethod: number
    paymentRef: number
    bankName: number
    status: number
    govtFeeAccountId: number
    govtFeeRef: number
    customerPhone: number
    customerEmail: number
    createdAt: number
    updatedAt: number
    quotationId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
    balance?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
    balance?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNo?: true
    date?: true
    companyId?: true
    branchId?: true
    customerId?: true
    customerName?: true
    agentId?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
    balance?: true
    paymentMethod?: true
    paymentRef?: true
    bankName?: true
    status?: true
    govtFeeAccountId?: true
    govtFeeRef?: true
    customerPhone?: true
    customerEmail?: true
    createdAt?: true
    updatedAt?: true
    quotationId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNo?: true
    date?: true
    companyId?: true
    branchId?: true
    customerId?: true
    customerName?: true
    agentId?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
    balance?: true
    paymentMethod?: true
    paymentRef?: true
    bankName?: true
    status?: true
    govtFeeAccountId?: true
    govtFeeRef?: true
    customerPhone?: true
    customerEmail?: true
    createdAt?: true
    updatedAt?: true
    quotationId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNo?: true
    date?: true
    companyId?: true
    branchId?: true
    customerId?: true
    customerName?: true
    agentId?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
    balance?: true
    paymentMethod?: true
    paymentRef?: true
    bankName?: true
    status?: true
    govtFeeAccountId?: true
    govtFeeRef?: true
    customerPhone?: true
    customerEmail?: true
    createdAt?: true
    updatedAt?: true
    quotationId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNo: string
    date: Date
    companyId: string
    branchId: string | null
    customerId: string | null
    customerName: string | null
    agentId: string | null
    subtotal: Decimal
    tax: Decimal
    discount: Decimal
    total: Decimal
    paidAmount: Decimal
    balance: Decimal
    paymentMethod: $Enums.PaymentMethod
    paymentRef: string | null
    bankName: string | null
    status: $Enums.InvoiceStatus
    govtFeeAccountId: string | null
    govtFeeRef: string | null
    customerPhone: string | null
    customerEmail: string | null
    createdAt: Date
    updatedAt: Date
    quotationId: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    date?: boolean
    companyId?: boolean
    branchId?: boolean
    customerId?: boolean
    customerName?: boolean
    agentId?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paidAmount?: boolean
    balance?: boolean
    paymentMethod?: boolean
    paymentRef?: boolean
    bankName?: boolean
    status?: boolean
    govtFeeAccountId?: boolean
    govtFeeRef?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotationId?: boolean
    agent?: boolean | Invoice$agentArgs<ExtArgs>
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    govtFeeAccount?: boolean | Invoice$govtFeeAccountArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    quotation?: boolean | Invoice$quotationArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    date?: boolean
    companyId?: boolean
    branchId?: boolean
    customerId?: boolean
    customerName?: boolean
    agentId?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paidAmount?: boolean
    balance?: boolean
    paymentMethod?: boolean
    paymentRef?: boolean
    bankName?: boolean
    status?: boolean
    govtFeeAccountId?: boolean
    govtFeeRef?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotationId?: boolean
    agent?: boolean | Invoice$agentArgs<ExtArgs>
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    govtFeeAccount?: boolean | Invoice$govtFeeAccountArgs<ExtArgs>
    quotation?: boolean | Invoice$quotationArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNo?: boolean
    date?: boolean
    companyId?: boolean
    branchId?: boolean
    customerId?: boolean
    customerName?: boolean
    agentId?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paidAmount?: boolean
    balance?: boolean
    paymentMethod?: boolean
    paymentRef?: boolean
    bankName?: boolean
    status?: boolean
    govtFeeAccountId?: boolean
    govtFeeRef?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotationId?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | Invoice$agentArgs<ExtArgs>
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    govtFeeAccount?: boolean | Invoice$govtFeeAccountArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    quotation?: boolean | Invoice$quotationArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | Invoice$agentArgs<ExtArgs>
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    govtFeeAccount?: boolean | Invoice$govtFeeAccountArgs<ExtArgs>
    quotation?: boolean | Invoice$quotationArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      agent: Prisma.$UserPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      govtFeeAccount: Prisma.$AccountPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      quotation: Prisma.$QuotationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNo: string
      date: Date
      companyId: string
      branchId: string | null
      customerId: string | null
      customerName: string | null
      agentId: string | null
      subtotal: Prisma.Decimal
      tax: Prisma.Decimal
      discount: Prisma.Decimal
      total: Prisma.Decimal
      paidAmount: Prisma.Decimal
      balance: Prisma.Decimal
      paymentMethod: $Enums.PaymentMethod
      paymentRef: string | null
      bankName: string | null
      status: $Enums.InvoiceStatus
      govtFeeAccountId: string | null
      govtFeeRef: string | null
      customerPhone: string | null
      customerEmail: string | null
      createdAt: Date
      updatedAt: Date
      quotationId: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends Invoice$agentArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$agentArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends Invoice$branchArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    govtFeeAccount<T extends Invoice$govtFeeAccountArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$govtFeeAccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactions<T extends Invoice$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    quotation<T extends Invoice$quotationArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$quotationArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNo: FieldRef<"Invoice", 'String'>
    readonly date: FieldRef<"Invoice", 'DateTime'>
    readonly companyId: FieldRef<"Invoice", 'String'>
    readonly branchId: FieldRef<"Invoice", 'String'>
    readonly customerId: FieldRef<"Invoice", 'String'>
    readonly customerName: FieldRef<"Invoice", 'String'>
    readonly agentId: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly tax: FieldRef<"Invoice", 'Decimal'>
    readonly discount: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly paidAmount: FieldRef<"Invoice", 'Decimal'>
    readonly balance: FieldRef<"Invoice", 'Decimal'>
    readonly paymentMethod: FieldRef<"Invoice", 'PaymentMethod'>
    readonly paymentRef: FieldRef<"Invoice", 'String'>
    readonly bankName: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly govtFeeAccountId: FieldRef<"Invoice", 'String'>
    readonly govtFeeRef: FieldRef<"Invoice", 'String'>
    readonly customerPhone: FieldRef<"Invoice", 'String'>
    readonly customerEmail: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly quotationId: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.agent
   */
  export type Invoice$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Invoice.branch
   */
  export type Invoice$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Invoice.govtFeeAccount
   */
  export type Invoice$govtFeeAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Invoice.transactions
   */
  export type Invoice$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Invoice.quotation
   */
  export type Invoice$quotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    govFee: Decimal | null
    typingCharge: Decimal | null
    vat: Decimal | null
    total: Decimal | null
    advanceAmount: Decimal | null
    vatRate: Decimal | null
    quantity: number | null
  }

  export type TransactionSumAggregateOutputType = {
    govFee: Decimal | null
    typingCharge: Decimal | null
    vat: Decimal | null
    total: Decimal | null
    advanceAmount: Decimal | null
    vatRate: Decimal | null
    quantity: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    branchId: string | null
    invoiceId: string | null
    invNo: string | null
    date: Date | null
    enteredById: string | null
    beneficiaryId: string | null
    partnerId: string | null
    workTypeId: string | null
    govFee: Decimal | null
    typingCharge: Decimal | null
    vat: Decimal | null
    total: Decimal | null
    type: $Enums.TransactionType | null
    receiptNo: string | null
    govtFeeAccountId: string | null
    govtFeeRef: string | null
    paymentMethod: $Enums.PaymentMethod | null
    cardId: string | null
    transactionId: string | null
    status: $Enums.PaymentStatus | null
    advanceStatus: $Enums.AdvanceStatus | null
    advanceAmount: Decimal | null
    customerName: string | null
    applicantName: string | null
    details: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isVatApplicable: boolean | null
    vatRate: Decimal | null
    quantity: number | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    branchId: string | null
    invoiceId: string | null
    invNo: string | null
    date: Date | null
    enteredById: string | null
    beneficiaryId: string | null
    partnerId: string | null
    workTypeId: string | null
    govFee: Decimal | null
    typingCharge: Decimal | null
    vat: Decimal | null
    total: Decimal | null
    type: $Enums.TransactionType | null
    receiptNo: string | null
    govtFeeAccountId: string | null
    govtFeeRef: string | null
    paymentMethod: $Enums.PaymentMethod | null
    cardId: string | null
    transactionId: string | null
    status: $Enums.PaymentStatus | null
    advanceStatus: $Enums.AdvanceStatus | null
    advanceAmount: Decimal | null
    customerName: string | null
    applicantName: string | null
    details: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isVatApplicable: boolean | null
    vatRate: Decimal | null
    quantity: number | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    companyId: number
    branchId: number
    invoiceId: number
    invNo: number
    date: number
    enteredById: number
    beneficiaryId: number
    partnerId: number
    workTypeId: number
    govFee: number
    typingCharge: number
    vat: number
    total: number
    type: number
    receiptNo: number
    govtFeeAccountId: number
    govtFeeRef: number
    paymentMethod: number
    cardId: number
    transactionId: number
    status: number
    advanceStatus: number
    advanceAmount: number
    customerName: number
    applicantName: number
    details: number
    createdAt: number
    updatedAt: number
    isVatApplicable: number
    vatRate: number
    quantity: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    govFee?: true
    typingCharge?: true
    vat?: true
    total?: true
    advanceAmount?: true
    vatRate?: true
    quantity?: true
  }

  export type TransactionSumAggregateInputType = {
    govFee?: true
    typingCharge?: true
    vat?: true
    total?: true
    advanceAmount?: true
    vatRate?: true
    quantity?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    invoiceId?: true
    invNo?: true
    date?: true
    enteredById?: true
    beneficiaryId?: true
    partnerId?: true
    workTypeId?: true
    govFee?: true
    typingCharge?: true
    vat?: true
    total?: true
    type?: true
    receiptNo?: true
    govtFeeAccountId?: true
    govtFeeRef?: true
    paymentMethod?: true
    cardId?: true
    transactionId?: true
    status?: true
    advanceStatus?: true
    advanceAmount?: true
    customerName?: true
    applicantName?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    isVatApplicable?: true
    vatRate?: true
    quantity?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    invoiceId?: true
    invNo?: true
    date?: true
    enteredById?: true
    beneficiaryId?: true
    partnerId?: true
    workTypeId?: true
    govFee?: true
    typingCharge?: true
    vat?: true
    total?: true
    type?: true
    receiptNo?: true
    govtFeeAccountId?: true
    govtFeeRef?: true
    paymentMethod?: true
    cardId?: true
    transactionId?: true
    status?: true
    advanceStatus?: true
    advanceAmount?: true
    customerName?: true
    applicantName?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    isVatApplicable?: true
    vatRate?: true
    quantity?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    invoiceId?: true
    invNo?: true
    date?: true
    enteredById?: true
    beneficiaryId?: true
    partnerId?: true
    workTypeId?: true
    govFee?: true
    typingCharge?: true
    vat?: true
    total?: true
    type?: true
    receiptNo?: true
    govtFeeAccountId?: true
    govtFeeRef?: true
    paymentMethod?: true
    cardId?: true
    transactionId?: true
    status?: true
    advanceStatus?: true
    advanceAmount?: true
    customerName?: true
    applicantName?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    isVatApplicable?: true
    vatRate?: true
    quantity?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    companyId: string
    branchId: string | null
    invoiceId: string | null
    invNo: string | null
    date: Date
    enteredById: string | null
    beneficiaryId: string | null
    partnerId: string | null
    workTypeId: string | null
    govFee: Decimal
    typingCharge: Decimal
    vat: Decimal
    total: Decimal
    type: $Enums.TransactionType
    receiptNo: string | null
    govtFeeAccountId: string | null
    govtFeeRef: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId: string | null
    transactionId: string | null
    status: $Enums.PaymentStatus
    advanceStatus: $Enums.AdvanceStatus
    advanceAmount: Decimal
    customerName: string | null
    applicantName: string | null
    details: string | null
    createdAt: Date
    updatedAt: Date
    isVatApplicable: boolean
    vatRate: Decimal
    quantity: number
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    invoiceId?: boolean
    invNo?: boolean
    date?: boolean
    enteredById?: boolean
    beneficiaryId?: boolean
    partnerId?: boolean
    workTypeId?: boolean
    govFee?: boolean
    typingCharge?: boolean
    vat?: boolean
    total?: boolean
    type?: boolean
    receiptNo?: boolean
    govtFeeAccountId?: boolean
    govtFeeRef?: boolean
    paymentMethod?: boolean
    cardId?: boolean
    transactionId?: boolean
    status?: boolean
    advanceStatus?: boolean
    advanceAmount?: boolean
    customerName?: boolean
    applicantName?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVatApplicable?: boolean
    vatRate?: boolean
    quantity?: boolean
    beneficiary?: boolean | Transaction$beneficiaryArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | Transaction$enteredByArgs<ExtArgs>
    govtFeeAccount?: boolean | Transaction$govtFeeAccountArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    partner?: boolean | Transaction$partnerArgs<ExtArgs>
    workType?: boolean | Transaction$workTypeArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    invoiceId?: boolean
    invNo?: boolean
    date?: boolean
    enteredById?: boolean
    beneficiaryId?: boolean
    partnerId?: boolean
    workTypeId?: boolean
    govFee?: boolean
    typingCharge?: boolean
    vat?: boolean
    total?: boolean
    type?: boolean
    receiptNo?: boolean
    govtFeeAccountId?: boolean
    govtFeeRef?: boolean
    paymentMethod?: boolean
    cardId?: boolean
    transactionId?: boolean
    status?: boolean
    advanceStatus?: boolean
    advanceAmount?: boolean
    customerName?: boolean
    applicantName?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVatApplicable?: boolean
    vatRate?: boolean
    quantity?: boolean
    beneficiary?: boolean | Transaction$beneficiaryArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | Transaction$enteredByArgs<ExtArgs>
    govtFeeAccount?: boolean | Transaction$govtFeeAccountArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    partner?: boolean | Transaction$partnerArgs<ExtArgs>
    workType?: boolean | Transaction$workTypeArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    invoiceId?: boolean
    invNo?: boolean
    date?: boolean
    enteredById?: boolean
    beneficiaryId?: boolean
    partnerId?: boolean
    workTypeId?: boolean
    govFee?: boolean
    typingCharge?: boolean
    vat?: boolean
    total?: boolean
    type?: boolean
    receiptNo?: boolean
    govtFeeAccountId?: boolean
    govtFeeRef?: boolean
    paymentMethod?: boolean
    cardId?: boolean
    transactionId?: boolean
    status?: boolean
    advanceStatus?: boolean
    advanceAmount?: boolean
    customerName?: boolean
    applicantName?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVatApplicable?: boolean
    vatRate?: boolean
    quantity?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beneficiary?: boolean | Transaction$beneficiaryArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | Transaction$enteredByArgs<ExtArgs>
    govtFeeAccount?: boolean | Transaction$govtFeeAccountArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    partner?: boolean | Transaction$partnerArgs<ExtArgs>
    workType?: boolean | Transaction$workTypeArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beneficiary?: boolean | Transaction$beneficiaryArgs<ExtArgs>
    branch?: boolean | Transaction$branchArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | Transaction$enteredByArgs<ExtArgs>
    govtFeeAccount?: boolean | Transaction$govtFeeAccountArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    partner?: boolean | Transaction$partnerArgs<ExtArgs>
    workType?: boolean | Transaction$workTypeArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      beneficiary: Prisma.$BeneficiaryPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      account: Prisma.$AccountPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      enteredBy: Prisma.$UserPayload<ExtArgs> | null
      govtFeeAccount: Prisma.$AccountPayload<ExtArgs> | null
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      workType: Prisma.$WorkTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      branchId: string | null
      invoiceId: string | null
      invNo: string | null
      date: Date
      enteredById: string | null
      beneficiaryId: string | null
      partnerId: string | null
      workTypeId: string | null
      govFee: Prisma.Decimal
      typingCharge: Prisma.Decimal
      vat: Prisma.Decimal
      total: Prisma.Decimal
      type: $Enums.TransactionType
      receiptNo: string | null
      govtFeeAccountId: string | null
      govtFeeRef: string | null
      paymentMethod: $Enums.PaymentMethod
      cardId: string | null
      transactionId: string | null
      status: $Enums.PaymentStatus
      advanceStatus: $Enums.AdvanceStatus
      advanceAmount: Prisma.Decimal
      customerName: string | null
      applicantName: string | null
      details: string | null
      createdAt: Date
      updatedAt: Date
      isVatApplicable: boolean
      vatRate: Prisma.Decimal
      quantity: number
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    beneficiary<T extends Transaction$beneficiaryArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$beneficiaryArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends Transaction$branchArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    account<T extends Transaction$accountArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enteredBy<T extends Transaction$enteredByArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$enteredByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    govtFeeAccount<T extends Transaction$govtFeeAccountArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$govtFeeAccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invoice<T extends Transaction$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    partner<T extends Transaction$partnerArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workType<T extends Transaction$workTypeArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$workTypeArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly companyId: FieldRef<"Transaction", 'String'>
    readonly branchId: FieldRef<"Transaction", 'String'>
    readonly invoiceId: FieldRef<"Transaction", 'String'>
    readonly invNo: FieldRef<"Transaction", 'String'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly enteredById: FieldRef<"Transaction", 'String'>
    readonly beneficiaryId: FieldRef<"Transaction", 'String'>
    readonly partnerId: FieldRef<"Transaction", 'String'>
    readonly workTypeId: FieldRef<"Transaction", 'String'>
    readonly govFee: FieldRef<"Transaction", 'Decimal'>
    readonly typingCharge: FieldRef<"Transaction", 'Decimal'>
    readonly vat: FieldRef<"Transaction", 'Decimal'>
    readonly total: FieldRef<"Transaction", 'Decimal'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly receiptNo: FieldRef<"Transaction", 'String'>
    readonly govtFeeAccountId: FieldRef<"Transaction", 'String'>
    readonly govtFeeRef: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly cardId: FieldRef<"Transaction", 'String'>
    readonly transactionId: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'PaymentStatus'>
    readonly advanceStatus: FieldRef<"Transaction", 'AdvanceStatus'>
    readonly advanceAmount: FieldRef<"Transaction", 'Decimal'>
    readonly customerName: FieldRef<"Transaction", 'String'>
    readonly applicantName: FieldRef<"Transaction", 'String'>
    readonly details: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly isVatApplicable: FieldRef<"Transaction", 'Boolean'>
    readonly vatRate: FieldRef<"Transaction", 'Decimal'>
    readonly quantity: FieldRef<"Transaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.beneficiary
   */
  export type Transaction$beneficiaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
  }

  /**
   * Transaction.branch
   */
  export type Transaction$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Transaction.account
   */
  export type Transaction$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Transaction.enteredBy
   */
  export type Transaction$enteredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transaction.govtFeeAccount
   */
  export type Transaction$govtFeeAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Transaction.invoice
   */
  export type Transaction$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Transaction.partner
   */
  export type Transaction$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * Transaction.workType
   */
  export type Transaction$workTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    where?: WorkTypeWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model WorkType
   */

  export type AggregateWorkType = {
    _count: WorkTypeCountAggregateOutputType | null
    _avg: WorkTypeAvgAggregateOutputType | null
    _sum: WorkTypeSumAggregateOutputType | null
    _min: WorkTypeMinAggregateOutputType | null
    _max: WorkTypeMaxAggregateOutputType | null
  }

  export type WorkTypeAvgAggregateOutputType = {
    presetGovFee: Decimal | null
    presetTypingCharge: Decimal | null
    vatRate: Decimal | null
  }

  export type WorkTypeSumAggregateOutputType = {
    presetGovFee: Decimal | null
    presetTypingCharge: Decimal | null
    vatRate: Decimal | null
  }

  export type WorkTypeMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    description: string | null
    presetGovFee: Decimal | null
    presetTypingCharge: Decimal | null
    vatApplicable: boolean | null
    vatRate: Decimal | null
  }

  export type WorkTypeMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    description: string | null
    presetGovFee: Decimal | null
    presetTypingCharge: Decimal | null
    vatApplicable: boolean | null
    vatRate: Decimal | null
  }

  export type WorkTypeCountAggregateOutputType = {
    id: number
    companyId: number
    description: number
    presetGovFee: number
    presetTypingCharge: number
    vatApplicable: number
    vatRate: number
    _all: number
  }


  export type WorkTypeAvgAggregateInputType = {
    presetGovFee?: true
    presetTypingCharge?: true
    vatRate?: true
  }

  export type WorkTypeSumAggregateInputType = {
    presetGovFee?: true
    presetTypingCharge?: true
    vatRate?: true
  }

  export type WorkTypeMinAggregateInputType = {
    id?: true
    companyId?: true
    description?: true
    presetGovFee?: true
    presetTypingCharge?: true
    vatApplicable?: true
    vatRate?: true
  }

  export type WorkTypeMaxAggregateInputType = {
    id?: true
    companyId?: true
    description?: true
    presetGovFee?: true
    presetTypingCharge?: true
    vatApplicable?: true
    vatRate?: true
  }

  export type WorkTypeCountAggregateInputType = {
    id?: true
    companyId?: true
    description?: true
    presetGovFee?: true
    presetTypingCharge?: true
    vatApplicable?: true
    vatRate?: true
    _all?: true
  }

  export type WorkTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkType to aggregate.
     */
    where?: WorkTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTypes to fetch.
     */
    orderBy?: WorkTypeOrderByWithRelationInput | WorkTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkTypes
    **/
    _count?: true | WorkTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkTypeMaxAggregateInputType
  }

  export type GetWorkTypeAggregateType<T extends WorkTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkType[P]>
      : GetScalarType<T[P], AggregateWorkType[P]>
  }




  export type WorkTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkTypeWhereInput
    orderBy?: WorkTypeOrderByWithAggregationInput | WorkTypeOrderByWithAggregationInput[]
    by: WorkTypeScalarFieldEnum[] | WorkTypeScalarFieldEnum
    having?: WorkTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkTypeCountAggregateInputType | true
    _avg?: WorkTypeAvgAggregateInputType
    _sum?: WorkTypeSumAggregateInputType
    _min?: WorkTypeMinAggregateInputType
    _max?: WorkTypeMaxAggregateInputType
  }

  export type WorkTypeGroupByOutputType = {
    id: string
    companyId: string
    description: string
    presetGovFee: Decimal
    presetTypingCharge: Decimal
    vatApplicable: boolean
    vatRate: Decimal
    _count: WorkTypeCountAggregateOutputType | null
    _avg: WorkTypeAvgAggregateOutputType | null
    _sum: WorkTypeSumAggregateOutputType | null
    _min: WorkTypeMinAggregateOutputType | null
    _max: WorkTypeMaxAggregateOutputType | null
  }

  type GetWorkTypeGroupByPayload<T extends WorkTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkTypeGroupByOutputType[P]>
            : GetScalarType<T[P], WorkTypeGroupByOutputType[P]>
        }
      >
    >


  export type WorkTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    description?: boolean
    presetGovFee?: boolean
    presetTypingCharge?: boolean
    vatApplicable?: boolean
    vatRate?: boolean
    transactions?: boolean | WorkType$transactionsArgs<ExtArgs>
    quotationItems?: boolean | WorkType$quotationItemsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | WorkTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workType"]>

  export type WorkTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    description?: boolean
    presetGovFee?: boolean
    presetTypingCharge?: boolean
    vatApplicable?: boolean
    vatRate?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workType"]>

  export type WorkTypeSelectScalar = {
    id?: boolean
    companyId?: boolean
    description?: boolean
    presetGovFee?: boolean
    presetTypingCharge?: boolean
    vatApplicable?: boolean
    vatRate?: boolean
  }

  export type WorkTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WorkType$transactionsArgs<ExtArgs>
    quotationItems?: boolean | WorkType$quotationItemsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | WorkTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $WorkTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkType"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      quotationItems: Prisma.$QuotationItemPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      description: string
      presetGovFee: Prisma.Decimal
      presetTypingCharge: Prisma.Decimal
      vatApplicable: boolean
      vatRate: Prisma.Decimal
    }, ExtArgs["result"]["workType"]>
    composites: {}
  }

  type WorkTypeGetPayload<S extends boolean | null | undefined | WorkTypeDefaultArgs> = $Result.GetResult<Prisma.$WorkTypePayload, S>

  type WorkTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkTypeCountAggregateInputType | true
    }

  export interface WorkTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkType'], meta: { name: 'WorkType' } }
    /**
     * Find zero or one WorkType that matches the filter.
     * @param {WorkTypeFindUniqueArgs} args - Arguments to find a WorkType
     * @example
     * // Get one WorkType
     * const workType = await prisma.workType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkTypeFindUniqueArgs>(args: SelectSubset<T, WorkTypeFindUniqueArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkTypeFindUniqueOrThrowArgs} args - Arguments to find a WorkType
     * @example
     * // Get one WorkType
     * const workType = await prisma.workType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTypeFindFirstArgs} args - Arguments to find a WorkType
     * @example
     * // Get one WorkType
     * const workType = await prisma.workType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkTypeFindFirstArgs>(args?: SelectSubset<T, WorkTypeFindFirstArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTypeFindFirstOrThrowArgs} args - Arguments to find a WorkType
     * @example
     * // Get one WorkType
     * const workType = await prisma.workType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkTypes
     * const workTypes = await prisma.workType.findMany()
     * 
     * // Get first 10 WorkTypes
     * const workTypes = await prisma.workType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workTypeWithIdOnly = await prisma.workType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkTypeFindManyArgs>(args?: SelectSubset<T, WorkTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkType.
     * @param {WorkTypeCreateArgs} args - Arguments to create a WorkType.
     * @example
     * // Create one WorkType
     * const WorkType = await prisma.workType.create({
     *   data: {
     *     // ... data to create a WorkType
     *   }
     * })
     * 
     */
    create<T extends WorkTypeCreateArgs>(args: SelectSubset<T, WorkTypeCreateArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkTypes.
     * @param {WorkTypeCreateManyArgs} args - Arguments to create many WorkTypes.
     * @example
     * // Create many WorkTypes
     * const workType = await prisma.workType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkTypeCreateManyArgs>(args?: SelectSubset<T, WorkTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkTypes and returns the data saved in the database.
     * @param {WorkTypeCreateManyAndReturnArgs} args - Arguments to create many WorkTypes.
     * @example
     * // Create many WorkTypes
     * const workType = await prisma.workType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkTypes and only return the `id`
     * const workTypeWithIdOnly = await prisma.workType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkType.
     * @param {WorkTypeDeleteArgs} args - Arguments to delete one WorkType.
     * @example
     * // Delete one WorkType
     * const WorkType = await prisma.workType.delete({
     *   where: {
     *     // ... filter to delete one WorkType
     *   }
     * })
     * 
     */
    delete<T extends WorkTypeDeleteArgs>(args: SelectSubset<T, WorkTypeDeleteArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkType.
     * @param {WorkTypeUpdateArgs} args - Arguments to update one WorkType.
     * @example
     * // Update one WorkType
     * const workType = await prisma.workType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkTypeUpdateArgs>(args: SelectSubset<T, WorkTypeUpdateArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkTypes.
     * @param {WorkTypeDeleteManyArgs} args - Arguments to filter WorkTypes to delete.
     * @example
     * // Delete a few WorkTypes
     * const { count } = await prisma.workType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkTypeDeleteManyArgs>(args?: SelectSubset<T, WorkTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkTypes
     * const workType = await prisma.workType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkTypeUpdateManyArgs>(args: SelectSubset<T, WorkTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkType.
     * @param {WorkTypeUpsertArgs} args - Arguments to update or create a WorkType.
     * @example
     * // Update or create a WorkType
     * const workType = await prisma.workType.upsert({
     *   create: {
     *     // ... data to create a WorkType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkType we want to update
     *   }
     * })
     */
    upsert<T extends WorkTypeUpsertArgs>(args: SelectSubset<T, WorkTypeUpsertArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTypeCountArgs} args - Arguments to filter WorkTypes to count.
     * @example
     * // Count the number of WorkTypes
     * const count = await prisma.workType.count({
     *   where: {
     *     // ... the filter for the WorkTypes we want to count
     *   }
     * })
    **/
    count<T extends WorkTypeCountArgs>(
      args?: Subset<T, WorkTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkTypeAggregateArgs>(args: Subset<T, WorkTypeAggregateArgs>): Prisma.PrismaPromise<GetWorkTypeAggregateType<T>>

    /**
     * Group by WorkType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkTypeGroupByArgs['orderBy'] }
        : { orderBy?: WorkTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkType model
   */
  readonly fields: WorkTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends WorkType$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, WorkType$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    quotationItems<T extends WorkType$quotationItemsArgs<ExtArgs> = {}>(args?: Subset<T, WorkType$quotationItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkType model
   */ 
  interface WorkTypeFieldRefs {
    readonly id: FieldRef<"WorkType", 'String'>
    readonly companyId: FieldRef<"WorkType", 'String'>
    readonly description: FieldRef<"WorkType", 'String'>
    readonly presetGovFee: FieldRef<"WorkType", 'Decimal'>
    readonly presetTypingCharge: FieldRef<"WorkType", 'Decimal'>
    readonly vatApplicable: FieldRef<"WorkType", 'Boolean'>
    readonly vatRate: FieldRef<"WorkType", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * WorkType findUnique
   */
  export type WorkTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * Filter, which WorkType to fetch.
     */
    where: WorkTypeWhereUniqueInput
  }

  /**
   * WorkType findUniqueOrThrow
   */
  export type WorkTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * Filter, which WorkType to fetch.
     */
    where: WorkTypeWhereUniqueInput
  }

  /**
   * WorkType findFirst
   */
  export type WorkTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * Filter, which WorkType to fetch.
     */
    where?: WorkTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTypes to fetch.
     */
    orderBy?: WorkTypeOrderByWithRelationInput | WorkTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkTypes.
     */
    cursor?: WorkTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkTypes.
     */
    distinct?: WorkTypeScalarFieldEnum | WorkTypeScalarFieldEnum[]
  }

  /**
   * WorkType findFirstOrThrow
   */
  export type WorkTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * Filter, which WorkType to fetch.
     */
    where?: WorkTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTypes to fetch.
     */
    orderBy?: WorkTypeOrderByWithRelationInput | WorkTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkTypes.
     */
    cursor?: WorkTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkTypes.
     */
    distinct?: WorkTypeScalarFieldEnum | WorkTypeScalarFieldEnum[]
  }

  /**
   * WorkType findMany
   */
  export type WorkTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * Filter, which WorkTypes to fetch.
     */
    where?: WorkTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkTypes to fetch.
     */
    orderBy?: WorkTypeOrderByWithRelationInput | WorkTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkTypes.
     */
    cursor?: WorkTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkTypes.
     */
    skip?: number
    distinct?: WorkTypeScalarFieldEnum | WorkTypeScalarFieldEnum[]
  }

  /**
   * WorkType create
   */
  export type WorkTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkType.
     */
    data: XOR<WorkTypeCreateInput, WorkTypeUncheckedCreateInput>
  }

  /**
   * WorkType createMany
   */
  export type WorkTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkTypes.
     */
    data: WorkTypeCreateManyInput | WorkTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkType createManyAndReturn
   */
  export type WorkTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkTypes.
     */
    data: WorkTypeCreateManyInput | WorkTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkType update
   */
  export type WorkTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkType.
     */
    data: XOR<WorkTypeUpdateInput, WorkTypeUncheckedUpdateInput>
    /**
     * Choose, which WorkType to update.
     */
    where: WorkTypeWhereUniqueInput
  }

  /**
   * WorkType updateMany
   */
  export type WorkTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkTypes.
     */
    data: XOR<WorkTypeUpdateManyMutationInput, WorkTypeUncheckedUpdateManyInput>
    /**
     * Filter which WorkTypes to update
     */
    where?: WorkTypeWhereInput
  }

  /**
   * WorkType upsert
   */
  export type WorkTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkType to update in case it exists.
     */
    where: WorkTypeWhereUniqueInput
    /**
     * In case the WorkType found by the `where` argument doesn't exist, create a new WorkType with this data.
     */
    create: XOR<WorkTypeCreateInput, WorkTypeUncheckedCreateInput>
    /**
     * In case the WorkType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkTypeUpdateInput, WorkTypeUncheckedUpdateInput>
  }

  /**
   * WorkType delete
   */
  export type WorkTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    /**
     * Filter which WorkType to delete.
     */
    where: WorkTypeWhereUniqueInput
  }

  /**
   * WorkType deleteMany
   */
  export type WorkTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkTypes to delete
     */
    where?: WorkTypeWhereInput
  }

  /**
   * WorkType.transactions
   */
  export type WorkType$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * WorkType.quotationItems
   */
  export type WorkType$quotationItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    cursor?: QuotationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * WorkType without action
   */
  export type WorkTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
  }


  /**
   * Model Beneficiary
   */

  export type AggregateBeneficiary = {
    _count: BeneficiaryCountAggregateOutputType | null
    _min: BeneficiaryMinAggregateOutputType | null
    _max: BeneficiaryMaxAggregateOutputType | null
  }

  export type BeneficiaryMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    details: string | null
    phone: string | null
    email: string | null
    partnerId: string | null
  }

  export type BeneficiaryMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    details: string | null
    phone: string | null
    email: string | null
    partnerId: string | null
  }

  export type BeneficiaryCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    details: number
    phone: number
    email: number
    partnerId: number
    _all: number
  }


  export type BeneficiaryMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    details?: true
    phone?: true
    email?: true
    partnerId?: true
  }

  export type BeneficiaryMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    details?: true
    phone?: true
    email?: true
    partnerId?: true
  }

  export type BeneficiaryCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    details?: true
    phone?: true
    email?: true
    partnerId?: true
    _all?: true
  }

  export type BeneficiaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beneficiary to aggregate.
     */
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beneficiaries to fetch.
     */
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beneficiaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beneficiaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Beneficiaries
    **/
    _count?: true | BeneficiaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeneficiaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeneficiaryMaxAggregateInputType
  }

  export type GetBeneficiaryAggregateType<T extends BeneficiaryAggregateArgs> = {
        [P in keyof T & keyof AggregateBeneficiary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeneficiary[P]>
      : GetScalarType<T[P], AggregateBeneficiary[P]>
  }




  export type BeneficiaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeneficiaryWhereInput
    orderBy?: BeneficiaryOrderByWithAggregationInput | BeneficiaryOrderByWithAggregationInput[]
    by: BeneficiaryScalarFieldEnum[] | BeneficiaryScalarFieldEnum
    having?: BeneficiaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeneficiaryCountAggregateInputType | true
    _min?: BeneficiaryMinAggregateInputType
    _max?: BeneficiaryMaxAggregateInputType
  }

  export type BeneficiaryGroupByOutputType = {
    id: string
    companyId: string
    name: string
    details: string | null
    phone: string | null
    email: string | null
    partnerId: string | null
    _count: BeneficiaryCountAggregateOutputType | null
    _min: BeneficiaryMinAggregateOutputType | null
    _max: BeneficiaryMaxAggregateOutputType | null
  }

  type GetBeneficiaryGroupByPayload<T extends BeneficiaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeneficiaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeneficiaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeneficiaryGroupByOutputType[P]>
            : GetScalarType<T[P], BeneficiaryGroupByOutputType[P]>
        }
      >
    >


  export type BeneficiarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    details?: boolean
    phone?: boolean
    email?: boolean
    partnerId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    partner?: boolean | Beneficiary$partnerArgs<ExtArgs>
    transactions?: boolean | Beneficiary$transactionsArgs<ExtArgs>
    _count?: boolean | BeneficiaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiary"]>

  export type BeneficiarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    details?: boolean
    phone?: boolean
    email?: boolean
    partnerId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    partner?: boolean | Beneficiary$partnerArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiary"]>

  export type BeneficiarySelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    details?: boolean
    phone?: boolean
    email?: boolean
    partnerId?: boolean
  }

  export type BeneficiaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    partner?: boolean | Beneficiary$partnerArgs<ExtArgs>
    transactions?: boolean | Beneficiary$transactionsArgs<ExtArgs>
    _count?: boolean | BeneficiaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BeneficiaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    partner?: boolean | Beneficiary$partnerArgs<ExtArgs>
  }

  export type $BeneficiaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Beneficiary"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      details: string | null
      phone: string | null
      email: string | null
      partnerId: string | null
    }, ExtArgs["result"]["beneficiary"]>
    composites: {}
  }

  type BeneficiaryGetPayload<S extends boolean | null | undefined | BeneficiaryDefaultArgs> = $Result.GetResult<Prisma.$BeneficiaryPayload, S>

  type BeneficiaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BeneficiaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BeneficiaryCountAggregateInputType | true
    }

  export interface BeneficiaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Beneficiary'], meta: { name: 'Beneficiary' } }
    /**
     * Find zero or one Beneficiary that matches the filter.
     * @param {BeneficiaryFindUniqueArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BeneficiaryFindUniqueArgs>(args: SelectSubset<T, BeneficiaryFindUniqueArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Beneficiary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BeneficiaryFindUniqueOrThrowArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BeneficiaryFindUniqueOrThrowArgs>(args: SelectSubset<T, BeneficiaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Beneficiary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryFindFirstArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BeneficiaryFindFirstArgs>(args?: SelectSubset<T, BeneficiaryFindFirstArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Beneficiary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryFindFirstOrThrowArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BeneficiaryFindFirstOrThrowArgs>(args?: SelectSubset<T, BeneficiaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Beneficiaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beneficiaries
     * const beneficiaries = await prisma.beneficiary.findMany()
     * 
     * // Get first 10 Beneficiaries
     * const beneficiaries = await prisma.beneficiary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beneficiaryWithIdOnly = await prisma.beneficiary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BeneficiaryFindManyArgs>(args?: SelectSubset<T, BeneficiaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Beneficiary.
     * @param {BeneficiaryCreateArgs} args - Arguments to create a Beneficiary.
     * @example
     * // Create one Beneficiary
     * const Beneficiary = await prisma.beneficiary.create({
     *   data: {
     *     // ... data to create a Beneficiary
     *   }
     * })
     * 
     */
    create<T extends BeneficiaryCreateArgs>(args: SelectSubset<T, BeneficiaryCreateArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Beneficiaries.
     * @param {BeneficiaryCreateManyArgs} args - Arguments to create many Beneficiaries.
     * @example
     * // Create many Beneficiaries
     * const beneficiary = await prisma.beneficiary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BeneficiaryCreateManyArgs>(args?: SelectSubset<T, BeneficiaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Beneficiaries and returns the data saved in the database.
     * @param {BeneficiaryCreateManyAndReturnArgs} args - Arguments to create many Beneficiaries.
     * @example
     * // Create many Beneficiaries
     * const beneficiary = await prisma.beneficiary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Beneficiaries and only return the `id`
     * const beneficiaryWithIdOnly = await prisma.beneficiary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BeneficiaryCreateManyAndReturnArgs>(args?: SelectSubset<T, BeneficiaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Beneficiary.
     * @param {BeneficiaryDeleteArgs} args - Arguments to delete one Beneficiary.
     * @example
     * // Delete one Beneficiary
     * const Beneficiary = await prisma.beneficiary.delete({
     *   where: {
     *     // ... filter to delete one Beneficiary
     *   }
     * })
     * 
     */
    delete<T extends BeneficiaryDeleteArgs>(args: SelectSubset<T, BeneficiaryDeleteArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Beneficiary.
     * @param {BeneficiaryUpdateArgs} args - Arguments to update one Beneficiary.
     * @example
     * // Update one Beneficiary
     * const beneficiary = await prisma.beneficiary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BeneficiaryUpdateArgs>(args: SelectSubset<T, BeneficiaryUpdateArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Beneficiaries.
     * @param {BeneficiaryDeleteManyArgs} args - Arguments to filter Beneficiaries to delete.
     * @example
     * // Delete a few Beneficiaries
     * const { count } = await prisma.beneficiary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BeneficiaryDeleteManyArgs>(args?: SelectSubset<T, BeneficiaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beneficiaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beneficiaries
     * const beneficiary = await prisma.beneficiary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BeneficiaryUpdateManyArgs>(args: SelectSubset<T, BeneficiaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Beneficiary.
     * @param {BeneficiaryUpsertArgs} args - Arguments to update or create a Beneficiary.
     * @example
     * // Update or create a Beneficiary
     * const beneficiary = await prisma.beneficiary.upsert({
     *   create: {
     *     // ... data to create a Beneficiary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Beneficiary we want to update
     *   }
     * })
     */
    upsert<T extends BeneficiaryUpsertArgs>(args: SelectSubset<T, BeneficiaryUpsertArgs<ExtArgs>>): Prisma__BeneficiaryClient<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Beneficiaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryCountArgs} args - Arguments to filter Beneficiaries to count.
     * @example
     * // Count the number of Beneficiaries
     * const count = await prisma.beneficiary.count({
     *   where: {
     *     // ... the filter for the Beneficiaries we want to count
     *   }
     * })
    **/
    count<T extends BeneficiaryCountArgs>(
      args?: Subset<T, BeneficiaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeneficiaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Beneficiary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeneficiaryAggregateArgs>(args: Subset<T, BeneficiaryAggregateArgs>): Prisma.PrismaPromise<GetBeneficiaryAggregateType<T>>

    /**
     * Group by Beneficiary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BeneficiaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BeneficiaryGroupByArgs['orderBy'] }
        : { orderBy?: BeneficiaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BeneficiaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeneficiaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Beneficiary model
   */
  readonly fields: BeneficiaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Beneficiary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BeneficiaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    partner<T extends Beneficiary$partnerArgs<ExtArgs> = {}>(args?: Subset<T, Beneficiary$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactions<T extends Beneficiary$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Beneficiary$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Beneficiary model
   */ 
  interface BeneficiaryFieldRefs {
    readonly id: FieldRef<"Beneficiary", 'String'>
    readonly companyId: FieldRef<"Beneficiary", 'String'>
    readonly name: FieldRef<"Beneficiary", 'String'>
    readonly details: FieldRef<"Beneficiary", 'String'>
    readonly phone: FieldRef<"Beneficiary", 'String'>
    readonly email: FieldRef<"Beneficiary", 'String'>
    readonly partnerId: FieldRef<"Beneficiary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Beneficiary findUnique
   */
  export type BeneficiaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiary to fetch.
     */
    where: BeneficiaryWhereUniqueInput
  }

  /**
   * Beneficiary findUniqueOrThrow
   */
  export type BeneficiaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiary to fetch.
     */
    where: BeneficiaryWhereUniqueInput
  }

  /**
   * Beneficiary findFirst
   */
  export type BeneficiaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiary to fetch.
     */
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beneficiaries to fetch.
     */
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beneficiaries.
     */
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beneficiaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beneficiaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beneficiaries.
     */
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Beneficiary findFirstOrThrow
   */
  export type BeneficiaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiary to fetch.
     */
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beneficiaries to fetch.
     */
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beneficiaries.
     */
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beneficiaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beneficiaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beneficiaries.
     */
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Beneficiary findMany
   */
  export type BeneficiaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter, which Beneficiaries to fetch.
     */
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beneficiaries to fetch.
     */
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Beneficiaries.
     */
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beneficiaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beneficiaries.
     */
    skip?: number
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Beneficiary create
   */
  export type BeneficiaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * The data needed to create a Beneficiary.
     */
    data: XOR<BeneficiaryCreateInput, BeneficiaryUncheckedCreateInput>
  }

  /**
   * Beneficiary createMany
   */
  export type BeneficiaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Beneficiaries.
     */
    data: BeneficiaryCreateManyInput | BeneficiaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Beneficiary createManyAndReturn
   */
  export type BeneficiaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Beneficiaries.
     */
    data: BeneficiaryCreateManyInput | BeneficiaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Beneficiary update
   */
  export type BeneficiaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * The data needed to update a Beneficiary.
     */
    data: XOR<BeneficiaryUpdateInput, BeneficiaryUncheckedUpdateInput>
    /**
     * Choose, which Beneficiary to update.
     */
    where: BeneficiaryWhereUniqueInput
  }

  /**
   * Beneficiary updateMany
   */
  export type BeneficiaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Beneficiaries.
     */
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyInput>
    /**
     * Filter which Beneficiaries to update
     */
    where?: BeneficiaryWhereInput
  }

  /**
   * Beneficiary upsert
   */
  export type BeneficiaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * The filter to search for the Beneficiary to update in case it exists.
     */
    where: BeneficiaryWhereUniqueInput
    /**
     * In case the Beneficiary found by the `where` argument doesn't exist, create a new Beneficiary with this data.
     */
    create: XOR<BeneficiaryCreateInput, BeneficiaryUncheckedCreateInput>
    /**
     * In case the Beneficiary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BeneficiaryUpdateInput, BeneficiaryUncheckedUpdateInput>
  }

  /**
   * Beneficiary delete
   */
  export type BeneficiaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    /**
     * Filter which Beneficiary to delete.
     */
    where: BeneficiaryWhereUniqueInput
  }

  /**
   * Beneficiary deleteMany
   */
  export type BeneficiaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beneficiaries to delete
     */
    where?: BeneficiaryWhereInput
  }

  /**
   * Beneficiary.partner
   */
  export type Beneficiary$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * Beneficiary.transactions
   */
  export type Beneficiary$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Beneficiary without action
   */
  export type BeneficiaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    type: $Enums.PartnerType | null
    email: string | null
    phone: string | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    type: $Enums.PartnerType | null
    email: string | null
    phone: string | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    type: number
    email: number
    phone: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    email?: true
    phone?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    email?: true
    phone?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    companyId: string
    name: string
    type: $Enums.PartnerType
    email: string | null
    phone: string | null
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    beneficiaries?: boolean | Partner$beneficiariesArgs<ExtArgs>
    ledgerTransactions?: boolean | Partner$ledgerTransactionsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | Partner$transactionsArgs<ExtArgs>
    quotations?: boolean | Partner$quotationsArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
  }

  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beneficiaries?: boolean | Partner$beneficiariesArgs<ExtArgs>
    ledgerTransactions?: boolean | Partner$ledgerTransactionsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | Partner$transactionsArgs<ExtArgs>
    quotations?: boolean | Partner$quotationsArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      beneficiaries: Prisma.$BeneficiaryPayload<ExtArgs>[]
      ledgerTransactions: Prisma.$LedgerTransactionPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      quotations: Prisma.$QuotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      type: $Enums.PartnerType
      email: string | null
      phone: string | null
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partners and returns the data saved in the database.
     * @param {PartnerCreateManyAndReturnArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    beneficiaries<T extends Partner$beneficiariesArgs<ExtArgs> = {}>(args?: Subset<T, Partner$beneficiariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeneficiaryPayload<ExtArgs>, T, "findMany"> | Null>
    ledgerTransactions<T extends Partner$ledgerTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$ledgerTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Partner$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    quotations<T extends Partner$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */ 
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly companyId: FieldRef<"Partner", 'String'>
    readonly name: FieldRef<"Partner", 'String'>
    readonly type: FieldRef<"Partner", 'PartnerType'>
    readonly email: FieldRef<"Partner", 'String'>
    readonly phone: FieldRef<"Partner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner createManyAndReturn
   */
  export type PartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
  }

  /**
   * Partner.beneficiaries
   */
  export type Partner$beneficiariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Beneficiary
     */
    select?: BeneficiarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeneficiaryInclude<ExtArgs> | null
    where?: BeneficiaryWhereInput
    orderBy?: BeneficiaryOrderByWithRelationInput | BeneficiaryOrderByWithRelationInput[]
    cursor?: BeneficiaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeneficiaryScalarFieldEnum | BeneficiaryScalarFieldEnum[]
  }

  /**
   * Partner.ledgerTransactions
   */
  export type Partner$ledgerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    where?: LedgerTransactionWhereInput
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    cursor?: LedgerTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * Partner.transactions
   */
  export type Partner$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Partner.quotations
   */
  export type Partner$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    branchId: string | null
    date: Date | null
    description: string | null
    amount: Decimal | null
    categoryId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    accountId: string | null
    enteredById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    branchId: string | null
    date: Date | null
    description: string | null
    amount: Decimal | null
    categoryId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    accountId: string | null
    enteredById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    companyId: number
    branchId: number
    date: number
    description: number
    amount: number
    categoryId: number
    paymentMethod: number
    accountId: number
    enteredById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    date?: true
    description?: true
    amount?: true
    categoryId?: true
    paymentMethod?: true
    accountId?: true
    enteredById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    date?: true
    description?: true
    amount?: true
    categoryId?: true
    paymentMethod?: true
    accountId?: true
    enteredById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    date?: true
    description?: true
    amount?: true
    categoryId?: true
    paymentMethod?: true
    accountId?: true
    enteredById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    companyId: string
    branchId: string | null
    date: Date
    description: string | null
    amount: Decimal
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId: string | null
    enteredById: string
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    categoryId?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    enteredById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | Expense$accountArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    categoryId?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    enteredById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | Expense$accountArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    categoryId?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    enteredById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Expense$accountArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Expense$accountArgs<ExtArgs>
    branch?: boolean | Expense$branchArgs<ExtArgs>
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      category: Prisma.$ExpenseCategoryPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      enteredBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      branchId: string | null
      date: Date
      description: string | null
      amount: Prisma.Decimal
      categoryId: string
      paymentMethod: $Enums.PaymentMethod
      accountId: string | null
      enteredById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends Expense$accountArgs<ExtArgs> = {}>(args?: Subset<T, Expense$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends Expense$branchArgs<ExtArgs> = {}>(args?: Subset<T, Expense$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    category<T extends ExpenseCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategoryDefaultArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enteredBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly companyId: FieldRef<"Expense", 'String'>
    readonly branchId: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly categoryId: FieldRef<"Expense", 'String'>
    readonly paymentMethod: FieldRef<"Expense", 'PaymentMethod'>
    readonly accountId: FieldRef<"Expense", 'String'>
    readonly enteredById: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense.account
   */
  export type Expense$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Expense.branch
   */
  export type Expense$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseCategory
   */

  export type AggregateExpenseCategory = {
    _count: ExpenseCategoryCountAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  export type ExpenseCategoryMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    description: string | null
    ledgerAccountId: string | null
  }

  export type ExpenseCategoryMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    description: string | null
    ledgerAccountId: string | null
  }

  export type ExpenseCategoryCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    description: number
    ledgerAccountId: number
    _all: number
  }


  export type ExpenseCategoryMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    ledgerAccountId?: true
  }

  export type ExpenseCategoryMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    ledgerAccountId?: true
  }

  export type ExpenseCategoryCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    description?: true
    ledgerAccountId?: true
    _all?: true
  }

  export type ExpenseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategory to aggregate.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseCategories
    **/
    _count?: true | ExpenseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type GetExpenseCategoryAggregateType<T extends ExpenseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseCategory[P]>
      : GetScalarType<T[P], AggregateExpenseCategory[P]>
  }




  export type ExpenseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithAggregationInput | ExpenseCategoryOrderByWithAggregationInput[]
    by: ExpenseCategoryScalarFieldEnum[] | ExpenseCategoryScalarFieldEnum
    having?: ExpenseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCategoryCountAggregateInputType | true
    _min?: ExpenseCategoryMinAggregateInputType
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type ExpenseCategoryGroupByOutputType = {
    id: string
    companyId: string
    name: string
    description: string | null
    ledgerAccountId: string | null
    _count: ExpenseCategoryCountAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  type GetExpenseCategoryGroupByPayload<T extends ExpenseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    ledgerAccountId?: boolean
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    ledgerAccount?: boolean | ExpenseCategory$ledgerAccountArgs<ExtArgs>
    voucherItems?: boolean | ExpenseCategory$voucherItemsArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    ledgerAccountId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    ledgerAccount?: boolean | ExpenseCategory$ledgerAccountArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    description?: boolean
    ledgerAccountId?: boolean
  }

  export type ExpenseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    ledgerAccount?: boolean | ExpenseCategory$ledgerAccountArgs<ExtArgs>
    voucherItems?: boolean | ExpenseCategory$voucherItemsArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    ledgerAccount?: boolean | ExpenseCategory$ledgerAccountArgs<ExtArgs>
  }

  export type $ExpenseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseCategory"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      ledgerAccount: Prisma.$AccountPayload<ExtArgs> | null
      voucherItems: Prisma.$VoucherItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      description: string | null
      ledgerAccountId: string | null
    }, ExtArgs["result"]["expenseCategory"]>
    composites: {}
  }

  type ExpenseCategoryGetPayload<S extends boolean | null | undefined | ExpenseCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseCategoryPayload, S>

  type ExpenseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCategoryCountAggregateInputType | true
    }

  export interface ExpenseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseCategory'], meta: { name: 'ExpenseCategory' } }
    /**
     * Find zero or one ExpenseCategory that matches the filter.
     * @param {ExpenseCategoryFindUniqueArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseCategoryFindUniqueArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExpenseCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExpenseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseCategoryFindFirstArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExpenseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExpenseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany()
     * 
     * // Get first 10 ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseCategoryFindManyArgs>(args?: SelectSubset<T, ExpenseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExpenseCategory.
     * @param {ExpenseCategoryCreateArgs} args - Arguments to create a ExpenseCategory.
     * @example
     * // Create one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.create({
     *   data: {
     *     // ... data to create a ExpenseCategory
     *   }
     * })
     * 
     */
    create<T extends ExpenseCategoryCreateArgs>(args: SelectSubset<T, ExpenseCategoryCreateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExpenseCategories.
     * @param {ExpenseCategoryCreateManyArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCategoryCreateManyArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseCategories and returns the data saved in the database.
     * @param {ExpenseCategoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExpenseCategory.
     * @param {ExpenseCategoryDeleteArgs} args - Arguments to delete one ExpenseCategory.
     * @example
     * // Delete one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseCategory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseCategoryDeleteArgs>(args: SelectSubset<T, ExpenseCategoryDeleteArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExpenseCategory.
     * @param {ExpenseCategoryUpdateArgs} args - Arguments to update one ExpenseCategory.
     * @example
     * // Update one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseCategoryUpdateArgs>(args: SelectSubset<T, ExpenseCategoryUpdateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExpenseCategories.
     * @param {ExpenseCategoryDeleteManyArgs} args - Arguments to filter ExpenseCategories to delete.
     * @example
     * // Delete a few ExpenseCategories
     * const { count } = await prisma.expenseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseCategoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseCategoryUpdateManyArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpenseCategory.
     * @param {ExpenseCategoryUpsertArgs} args - Arguments to update or create a ExpenseCategory.
     * @example
     * // Update or create a ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.upsert({
     *   create: {
     *     // ... data to create a ExpenseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseCategoryUpsertArgs>(args: SelectSubset<T, ExpenseCategoryUpsertArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryCountArgs} args - Arguments to filter ExpenseCategories to count.
     * @example
     * // Count the number of ExpenseCategories
     * const count = await prisma.expenseCategory.count({
     *   where: {
     *     // ... the filter for the ExpenseCategories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCategoryCountArgs>(
      args?: Subset<T, ExpenseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseCategoryAggregateArgs>(args: Subset<T, ExpenseCategoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseCategoryAggregateType<T>>

    /**
     * Group by ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseCategory model
   */
  readonly fields: ExpenseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends ExpenseCategory$expensesArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ledgerAccount<T extends ExpenseCategory$ledgerAccountArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$ledgerAccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    voucherItems<T extends ExpenseCategory$voucherItemsArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$voucherItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseCategory model
   */ 
  interface ExpenseCategoryFieldRefs {
    readonly id: FieldRef<"ExpenseCategory", 'String'>
    readonly companyId: FieldRef<"ExpenseCategory", 'String'>
    readonly name: FieldRef<"ExpenseCategory", 'String'>
    readonly description: FieldRef<"ExpenseCategory", 'String'>
    readonly ledgerAccountId: FieldRef<"ExpenseCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseCategory findUnique
   */
  export type ExpenseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findUniqueOrThrow
   */
  export type ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findFirst
   */
  export type ExpenseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findFirstOrThrow
   */
  export type ExpenseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findMany
   */
  export type ExpenseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategories to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory create
   */
  export type ExpenseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
  }

  /**
   * ExpenseCategory createMany
   */
  export type ExpenseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseCategory createManyAndReturn
   */
  export type ExpenseCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseCategory update
   */
  export type ExpenseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseCategory to update.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory updateMany
   */
  export type ExpenseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
  }

  /**
   * ExpenseCategory upsert
   */
  export type ExpenseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseCategory to update in case it exists.
     */
    where: ExpenseCategoryWhereUniqueInput
    /**
     * In case the ExpenseCategory found by the `where` argument doesn't exist, create a new ExpenseCategory with this data.
     */
    create: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
    /**
     * In case the ExpenseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
  }

  /**
   * ExpenseCategory delete
   */
  export type ExpenseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseCategory to delete.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory deleteMany
   */
  export type ExpenseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategories to delete
     */
    where?: ExpenseCategoryWhereInput
  }

  /**
   * ExpenseCategory.expenses
   */
  export type ExpenseCategory$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * ExpenseCategory.ledgerAccount
   */
  export type ExpenseCategory$ledgerAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * ExpenseCategory.voucherItems
   */
  export type ExpenseCategory$voucherItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    where?: VoucherItemWhereInput
    orderBy?: VoucherItemOrderByWithRelationInput | VoucherItemOrderByWithRelationInput[]
    cursor?: VoucherItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherItemScalarFieldEnum | VoucherItemScalarFieldEnum[]
  }

  /**
   * ExpenseCategory without action
   */
  export type ExpenseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type AccountSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    type: $Enums.AccountType | null
    balance: Decimal | null
    accountNumber: string | null
    bankName: string | null
    branchId: string | null
    category: $Enums.AccountCategory | null
    code: string | null
    iban: string | null
    isPostable: boolean | null
    isSystem: boolean | null
    merchantId: string | null
    parentAccountId: string | null
    swiftCode: string | null
    terminalId: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    type: $Enums.AccountType | null
    balance: Decimal | null
    accountNumber: string | null
    bankName: string | null
    branchId: string | null
    category: $Enums.AccountCategory | null
    code: string | null
    iban: string | null
    isPostable: boolean | null
    isSystem: boolean | null
    merchantId: string | null
    parentAccountId: string | null
    swiftCode: string | null
    terminalId: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    type: number
    balance: number
    accountNumber: number
    bankName: number
    branchId: number
    category: number
    code: number
    iban: number
    isPostable: number
    isSystem: number
    linkedBranchIds: number
    merchantId: number
    parentAccountId: number
    swiftCode: number
    terminalId: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    balance?: true
  }

  export type AccountSumAggregateInputType = {
    balance?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    balance?: true
    accountNumber?: true
    bankName?: true
    branchId?: true
    category?: true
    code?: true
    iban?: true
    isPostable?: true
    isSystem?: true
    merchantId?: true
    parentAccountId?: true
    swiftCode?: true
    terminalId?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    balance?: true
    accountNumber?: true
    bankName?: true
    branchId?: true
    category?: true
    code?: true
    iban?: true
    isPostable?: true
    isSystem?: true
    merchantId?: true
    parentAccountId?: true
    swiftCode?: true
    terminalId?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    balance?: true
    accountNumber?: true
    bankName?: true
    branchId?: true
    category?: true
    code?: true
    iban?: true
    isPostable?: true
    isSystem?: true
    linkedBranchIds?: true
    merchantId?: true
    parentAccountId?: true
    swiftCode?: true
    terminalId?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance: Decimal
    accountNumber: string | null
    bankName: string | null
    branchId: string | null
    category: $Enums.AccountCategory
    code: string
    iban: string | null
    isPostable: boolean
    isSystem: boolean
    linkedBranchIds: string[]
    merchantId: string | null
    parentAccountId: string | null
    swiftCode: string | null
    terminalId: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    balance?: boolean
    accountNumber?: boolean
    bankName?: boolean
    branchId?: boolean
    category?: boolean
    code?: boolean
    iban?: boolean
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: boolean
    merchantId?: boolean
    parentAccountId?: boolean
    swiftCode?: boolean
    terminalId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parentAccount?: boolean | Account$parentAccountArgs<ExtArgs>
    childAccounts?: boolean | Account$childAccountsArgs<ExtArgs>
    expenses?: boolean | Account$expensesArgs<ExtArgs>
    expenseCategories?: boolean | Account$expenseCategoriesArgs<ExtArgs>
    invoicesGovtFee?: boolean | Account$invoicesGovtFeeArgs<ExtArgs>
    ledgerTransactions?: boolean | Account$ledgerTransactionsArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    transactionsGovtFee?: boolean | Account$transactionsGovtFeeArgs<ExtArgs>
    vouchers?: boolean | Account$vouchersArgs<ExtArgs>
    voucherPayments?: boolean | Account$voucherPaymentsArgs<ExtArgs>
    businessCards?: boolean | Account$businessCardsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    balance?: boolean
    accountNumber?: boolean
    bankName?: boolean
    branchId?: boolean
    category?: boolean
    code?: boolean
    iban?: boolean
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: boolean
    merchantId?: boolean
    parentAccountId?: boolean
    swiftCode?: boolean
    terminalId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parentAccount?: boolean | Account$parentAccountArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    balance?: boolean
    accountNumber?: boolean
    bankName?: boolean
    branchId?: boolean
    category?: boolean
    code?: boolean
    iban?: boolean
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: boolean
    merchantId?: boolean
    parentAccountId?: boolean
    swiftCode?: boolean
    terminalId?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parentAccount?: boolean | Account$parentAccountArgs<ExtArgs>
    childAccounts?: boolean | Account$childAccountsArgs<ExtArgs>
    expenses?: boolean | Account$expensesArgs<ExtArgs>
    expenseCategories?: boolean | Account$expenseCategoriesArgs<ExtArgs>
    invoicesGovtFee?: boolean | Account$invoicesGovtFeeArgs<ExtArgs>
    ledgerTransactions?: boolean | Account$ledgerTransactionsArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    transactionsGovtFee?: boolean | Account$transactionsGovtFeeArgs<ExtArgs>
    vouchers?: boolean | Account$vouchersArgs<ExtArgs>
    voucherPayments?: boolean | Account$voucherPaymentsArgs<ExtArgs>
    businessCards?: boolean | Account$businessCardsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    parentAccount?: boolean | Account$parentAccountArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      parentAccount: Prisma.$AccountPayload<ExtArgs> | null
      childAccounts: Prisma.$AccountPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      expenseCategories: Prisma.$ExpenseCategoryPayload<ExtArgs>[]
      invoicesGovtFee: Prisma.$InvoicePayload<ExtArgs>[]
      ledgerTransactions: Prisma.$LedgerTransactionPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      transactionsGovtFee: Prisma.$TransactionPayload<ExtArgs>[]
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
      voucherPayments: Prisma.$VoucherPaymentPayload<ExtArgs>[]
      businessCards: Prisma.$BusinessCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      type: $Enums.AccountType
      balance: Prisma.Decimal
      accountNumber: string | null
      bankName: string | null
      branchId: string | null
      category: $Enums.AccountCategory
      code: string
      iban: string | null
      isPostable: boolean
      isSystem: boolean
      linkedBranchIds: string[]
      merchantId: string | null
      parentAccountId: string | null
      swiftCode: string | null
      terminalId: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parentAccount<T extends Account$parentAccountArgs<ExtArgs> = {}>(args?: Subset<T, Account$parentAccountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    childAccounts<T extends Account$childAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Account$childAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Account$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Account$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    expenseCategories<T extends Account$expenseCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Account$expenseCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    invoicesGovtFee<T extends Account$invoicesGovtFeeArgs<ExtArgs> = {}>(args?: Subset<T, Account$invoicesGovtFeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    ledgerTransactions<T extends Account$ledgerTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$ledgerTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Account$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    transactionsGovtFee<T extends Account$transactionsGovtFeeArgs<ExtArgs> = {}>(args?: Subset<T, Account$transactionsGovtFeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    vouchers<T extends Account$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Account$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany"> | Null>
    voucherPayments<T extends Account$voucherPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Account$voucherPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    businessCards<T extends Account$businessCardsArgs<ExtArgs> = {}>(args?: Subset<T, Account$businessCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly companyId: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'AccountType'>
    readonly balance: FieldRef<"Account", 'Decimal'>
    readonly accountNumber: FieldRef<"Account", 'String'>
    readonly bankName: FieldRef<"Account", 'String'>
    readonly branchId: FieldRef<"Account", 'String'>
    readonly category: FieldRef<"Account", 'AccountCategory'>
    readonly code: FieldRef<"Account", 'String'>
    readonly iban: FieldRef<"Account", 'String'>
    readonly isPostable: FieldRef<"Account", 'Boolean'>
    readonly isSystem: FieldRef<"Account", 'Boolean'>
    readonly linkedBranchIds: FieldRef<"Account", 'String[]'>
    readonly merchantId: FieldRef<"Account", 'String'>
    readonly parentAccountId: FieldRef<"Account", 'String'>
    readonly swiftCode: FieldRef<"Account", 'String'>
    readonly terminalId: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.parentAccount
   */
  export type Account$parentAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Account.childAccounts
   */
  export type Account$childAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account.expenses
   */
  export type Account$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Account.expenseCategories
   */
  export type Account$expenseCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    cursor?: ExpenseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * Account.invoicesGovtFee
   */
  export type Account$invoicesGovtFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Account.ledgerTransactions
   */
  export type Account$ledgerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    where?: LedgerTransactionWhereInput
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    cursor?: LedgerTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * Account.transactions
   */
  export type Account$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account.transactionsGovtFee
   */
  export type Account$transactionsGovtFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account.vouchers
   */
  export type Account$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Account.voucherPayments
   */
  export type Account$voucherPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    where?: VoucherPaymentWhereInput
    orderBy?: VoucherPaymentOrderByWithRelationInput | VoucherPaymentOrderByWithRelationInput[]
    cursor?: VoucherPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherPaymentScalarFieldEnum | VoucherPaymentScalarFieldEnum[]
  }

  /**
   * Account.businessCards
   */
  export type Account$businessCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    where?: BusinessCardWhereInput
    orderBy?: BusinessCardOrderByWithRelationInput | BusinessCardOrderByWithRelationInput[]
    cursor?: BusinessCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessCardScalarFieldEnum | BusinessCardScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model JournalEntry
   */

  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    branchId: string | null
    postingDate: Date | null
    createdAt: Date | null
    description: string | null
    type: $Enums.JournalEntryType | null
    referenceType: string | null
    referenceId: string | null
    reversedEntryId: string | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    branchId: string | null
    postingDate: Date | null
    createdAt: Date | null
    description: string | null
    type: $Enums.JournalEntryType | null
    referenceType: string | null
    referenceId: string | null
    reversedEntryId: string | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    companyId: number
    branchId: number
    postingDate: number
    createdAt: number
    description: number
    type: number
    referenceType: number
    referenceId: number
    reversedEntryId: number
    _all: number
  }


  export type JournalEntryMinAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    postingDate?: true
    createdAt?: true
    description?: true
    type?: true
    referenceType?: true
    referenceId?: true
    reversedEntryId?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    postingDate?: true
    createdAt?: true
    description?: true
    type?: true
    referenceType?: true
    referenceId?: true
    reversedEntryId?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    companyId?: true
    branchId?: true
    postingDate?: true
    createdAt?: true
    description?: true
    type?: true
    referenceType?: true
    referenceId?: true
    reversedEntryId?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithAggregationInput | JournalEntryOrderByWithAggregationInput[]
    by: JournalEntryScalarFieldEnum[] | JournalEntryScalarFieldEnum
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }

  export type JournalEntryGroupByOutputType = {
    id: string
    companyId: string
    branchId: string | null
    postingDate: Date
    createdAt: Date
    description: string | null
    type: $Enums.JournalEntryType
    referenceType: string | null
    referenceId: string | null
    reversedEntryId: string | null
    _count: JournalEntryCountAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    postingDate?: boolean
    createdAt?: boolean
    description?: boolean
    type?: boolean
    referenceType?: boolean
    referenceId?: boolean
    reversedEntryId?: boolean
    branch?: boolean | JournalEntry$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | JournalEntry$transactionsArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    postingDate?: boolean
    createdAt?: boolean
    description?: boolean
    type?: boolean
    referenceType?: boolean
    referenceId?: boolean
    reversedEntryId?: boolean
    branch?: boolean | JournalEntry$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    companyId?: boolean
    branchId?: boolean
    postingDate?: boolean
    createdAt?: boolean
    description?: boolean
    type?: boolean
    referenceType?: boolean
    referenceId?: boolean
    reversedEntryId?: boolean
  }

  export type JournalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | JournalEntry$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | JournalEntry$transactionsArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | JournalEntry$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $JournalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalEntry"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      transactions: Prisma.$LedgerTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      branchId: string | null
      postingDate: Date
      createdAt: Date
      description: string | null
      type: $Enums.JournalEntryType
      referenceType: string | null
      referenceId: string | null
      reversedEntryId: string | null
    }, ExtArgs["result"]["journalEntry"]>
    composites: {}
  }

  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryDefaultArgs> = $Result.GetResult<Prisma.$JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalEntryFindUniqueArgs>(args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JournalEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalEntryFindFirstArgs>(args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalEntryFindManyArgs>(args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
     */
    create<T extends JournalEntryCreateArgs>(args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JournalEntries.
     * @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalEntryCreateManyArgs>(args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalEntries and returns the data saved in the database.
     * @param {JournalEntryCreateManyAndReturnArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
     */
    delete<T extends JournalEntryDeleteArgs>(args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalEntryUpdateArgs>(args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalEntryDeleteManyArgs>(args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalEntryUpdateManyArgs>(args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
     */
    upsert<T extends JournalEntryUpsertArgs>(args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalEntry model
   */
  readonly fields: JournalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends JournalEntry$branchArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends JournalEntry$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalEntry model
   */ 
  interface JournalEntryFieldRefs {
    readonly id: FieldRef<"JournalEntry", 'String'>
    readonly companyId: FieldRef<"JournalEntry", 'String'>
    readonly branchId: FieldRef<"JournalEntry", 'String'>
    readonly postingDate: FieldRef<"JournalEntry", 'DateTime'>
    readonly createdAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly description: FieldRef<"JournalEntry", 'String'>
    readonly type: FieldRef<"JournalEntry", 'JournalEntryType'>
    readonly referenceType: FieldRef<"JournalEntry", 'String'>
    readonly referenceId: FieldRef<"JournalEntry", 'String'>
    readonly reversedEntryId: FieldRef<"JournalEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalEntry findUnique
   */
  export type JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findFirst
   */
  export type JournalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }

  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalEntry createManyAndReturn
   */
  export type JournalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
  }

  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }

  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
  }

  /**
   * JournalEntry.branch
   */
  export type JournalEntry$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * JournalEntry.transactions
   */
  export type JournalEntry$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    where?: LedgerTransactionWhereInput
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    cursor?: LedgerTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * JournalEntry without action
   */
  export type JournalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }


  /**
   * Model LedgerTransaction
   */

  export type AggregateLedgerTransaction = {
    _count: LedgerTransactionCountAggregateOutputType | null
    _avg: LedgerTransactionAvgAggregateOutputType | null
    _sum: LedgerTransactionSumAggregateOutputType | null
    _min: LedgerTransactionMinAggregateOutputType | null
    _max: LedgerTransactionMaxAggregateOutputType | null
  }

  export type LedgerTransactionAvgAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
  }

  export type LedgerTransactionSumAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
  }

  export type LedgerTransactionMinAggregateOutputType = {
    id: string | null
    journalEntryId: string | null
    accountId: string | null
    debit: Decimal | null
    credit: Decimal | null
    partnerId: string | null
    companyId: string | null
    branchId: string | null
    cardId: string | null
  }

  export type LedgerTransactionMaxAggregateOutputType = {
    id: string | null
    journalEntryId: string | null
    accountId: string | null
    debit: Decimal | null
    credit: Decimal | null
    partnerId: string | null
    companyId: string | null
    branchId: string | null
    cardId: string | null
  }

  export type LedgerTransactionCountAggregateOutputType = {
    id: number
    journalEntryId: number
    accountId: number
    debit: number
    credit: number
    partnerId: number
    companyId: number
    branchId: number
    cardId: number
    _all: number
  }


  export type LedgerTransactionAvgAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type LedgerTransactionSumAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type LedgerTransactionMinAggregateInputType = {
    id?: true
    journalEntryId?: true
    accountId?: true
    debit?: true
    credit?: true
    partnerId?: true
    companyId?: true
    branchId?: true
    cardId?: true
  }

  export type LedgerTransactionMaxAggregateInputType = {
    id?: true
    journalEntryId?: true
    accountId?: true
    debit?: true
    credit?: true
    partnerId?: true
    companyId?: true
    branchId?: true
    cardId?: true
  }

  export type LedgerTransactionCountAggregateInputType = {
    id?: true
    journalEntryId?: true
    accountId?: true
    debit?: true
    credit?: true
    partnerId?: true
    companyId?: true
    branchId?: true
    cardId?: true
    _all?: true
  }

  export type LedgerTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerTransaction to aggregate.
     */
    where?: LedgerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerTransactions to fetch.
     */
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerTransactions
    **/
    _count?: true | LedgerTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerTransactionMaxAggregateInputType
  }

  export type GetLedgerTransactionAggregateType<T extends LedgerTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerTransaction[P]>
      : GetScalarType<T[P], AggregateLedgerTransaction[P]>
  }




  export type LedgerTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerTransactionWhereInput
    orderBy?: LedgerTransactionOrderByWithAggregationInput | LedgerTransactionOrderByWithAggregationInput[]
    by: LedgerTransactionScalarFieldEnum[] | LedgerTransactionScalarFieldEnum
    having?: LedgerTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerTransactionCountAggregateInputType | true
    _avg?: LedgerTransactionAvgAggregateInputType
    _sum?: LedgerTransactionSumAggregateInputType
    _min?: LedgerTransactionMinAggregateInputType
    _max?: LedgerTransactionMaxAggregateInputType
  }

  export type LedgerTransactionGroupByOutputType = {
    id: string
    journalEntryId: string
    accountId: string
    debit: Decimal
    credit: Decimal
    partnerId: string | null
    companyId: string
    branchId: string | null
    cardId: string | null
    _count: LedgerTransactionCountAggregateOutputType | null
    _avg: LedgerTransactionAvgAggregateOutputType | null
    _sum: LedgerTransactionSumAggregateOutputType | null
    _min: LedgerTransactionMinAggregateOutputType | null
    _max: LedgerTransactionMaxAggregateOutputType | null
  }

  type GetLedgerTransactionGroupByPayload<T extends LedgerTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerTransactionGroupByOutputType[P]>
        }
      >
    >


  export type LedgerTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalEntryId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    partnerId?: boolean
    companyId?: boolean
    branchId?: boolean
    cardId?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | LedgerTransaction$branchArgs<ExtArgs>
    journalEntry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    partner?: boolean | LedgerTransaction$partnerArgs<ExtArgs>
    card?: boolean | LedgerTransaction$cardArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerTransaction"]>

  export type LedgerTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalEntryId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    partnerId?: boolean
    companyId?: boolean
    branchId?: boolean
    cardId?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | LedgerTransaction$branchArgs<ExtArgs>
    journalEntry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    partner?: boolean | LedgerTransaction$partnerArgs<ExtArgs>
    card?: boolean | LedgerTransaction$cardArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerTransaction"]>

  export type LedgerTransactionSelectScalar = {
    id?: boolean
    journalEntryId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    partnerId?: boolean
    companyId?: boolean
    branchId?: boolean
    cardId?: boolean
  }

  export type LedgerTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | LedgerTransaction$branchArgs<ExtArgs>
    journalEntry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    partner?: boolean | LedgerTransaction$partnerArgs<ExtArgs>
    card?: boolean | LedgerTransaction$cardArgs<ExtArgs>
  }
  export type LedgerTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    branch?: boolean | LedgerTransaction$branchArgs<ExtArgs>
    journalEntry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    partner?: boolean | LedgerTransaction$partnerArgs<ExtArgs>
    card?: boolean | LedgerTransaction$cardArgs<ExtArgs>
  }

  export type $LedgerTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerTransaction"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      journalEntry: Prisma.$JournalEntryPayload<ExtArgs>
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      card: Prisma.$BusinessCardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalEntryId: string
      accountId: string
      debit: Prisma.Decimal
      credit: Prisma.Decimal
      partnerId: string | null
      companyId: string
      branchId: string | null
      cardId: string | null
    }, ExtArgs["result"]["ledgerTransaction"]>
    composites: {}
  }

  type LedgerTransactionGetPayload<S extends boolean | null | undefined | LedgerTransactionDefaultArgs> = $Result.GetResult<Prisma.$LedgerTransactionPayload, S>

  type LedgerTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LedgerTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LedgerTransactionCountAggregateInputType | true
    }

  export interface LedgerTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerTransaction'], meta: { name: 'LedgerTransaction' } }
    /**
     * Find zero or one LedgerTransaction that matches the filter.
     * @param {LedgerTransactionFindUniqueArgs} args - Arguments to find a LedgerTransaction
     * @example
     * // Get one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerTransactionFindUniqueArgs>(args: SelectSubset<T, LedgerTransactionFindUniqueArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LedgerTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LedgerTransactionFindUniqueOrThrowArgs} args - Arguments to find a LedgerTransaction
     * @example
     * // Get one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LedgerTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionFindFirstArgs} args - Arguments to find a LedgerTransaction
     * @example
     * // Get one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerTransactionFindFirstArgs>(args?: SelectSubset<T, LedgerTransactionFindFirstArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LedgerTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionFindFirstOrThrowArgs} args - Arguments to find a LedgerTransaction
     * @example
     * // Get one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LedgerTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerTransactions
     * const ledgerTransactions = await prisma.ledgerTransaction.findMany()
     * 
     * // Get first 10 LedgerTransactions
     * const ledgerTransactions = await prisma.ledgerTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerTransactionWithIdOnly = await prisma.ledgerTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerTransactionFindManyArgs>(args?: SelectSubset<T, LedgerTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LedgerTransaction.
     * @param {LedgerTransactionCreateArgs} args - Arguments to create a LedgerTransaction.
     * @example
     * // Create one LedgerTransaction
     * const LedgerTransaction = await prisma.ledgerTransaction.create({
     *   data: {
     *     // ... data to create a LedgerTransaction
     *   }
     * })
     * 
     */
    create<T extends LedgerTransactionCreateArgs>(args: SelectSubset<T, LedgerTransactionCreateArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LedgerTransactions.
     * @param {LedgerTransactionCreateManyArgs} args - Arguments to create many LedgerTransactions.
     * @example
     * // Create many LedgerTransactions
     * const ledgerTransaction = await prisma.ledgerTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerTransactionCreateManyArgs>(args?: SelectSubset<T, LedgerTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerTransactions and returns the data saved in the database.
     * @param {LedgerTransactionCreateManyAndReturnArgs} args - Arguments to create many LedgerTransactions.
     * @example
     * // Create many LedgerTransactions
     * const ledgerTransaction = await prisma.ledgerTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerTransactions and only return the `id`
     * const ledgerTransactionWithIdOnly = await prisma.ledgerTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LedgerTransaction.
     * @param {LedgerTransactionDeleteArgs} args - Arguments to delete one LedgerTransaction.
     * @example
     * // Delete one LedgerTransaction
     * const LedgerTransaction = await prisma.ledgerTransaction.delete({
     *   where: {
     *     // ... filter to delete one LedgerTransaction
     *   }
     * })
     * 
     */
    delete<T extends LedgerTransactionDeleteArgs>(args: SelectSubset<T, LedgerTransactionDeleteArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LedgerTransaction.
     * @param {LedgerTransactionUpdateArgs} args - Arguments to update one LedgerTransaction.
     * @example
     * // Update one LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerTransactionUpdateArgs>(args: SelectSubset<T, LedgerTransactionUpdateArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LedgerTransactions.
     * @param {LedgerTransactionDeleteManyArgs} args - Arguments to filter LedgerTransactions to delete.
     * @example
     * // Delete a few LedgerTransactions
     * const { count } = await prisma.ledgerTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerTransactionDeleteManyArgs>(args?: SelectSubset<T, LedgerTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerTransactions
     * const ledgerTransaction = await prisma.ledgerTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerTransactionUpdateManyArgs>(args: SelectSubset<T, LedgerTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LedgerTransaction.
     * @param {LedgerTransactionUpsertArgs} args - Arguments to update or create a LedgerTransaction.
     * @example
     * // Update or create a LedgerTransaction
     * const ledgerTransaction = await prisma.ledgerTransaction.upsert({
     *   create: {
     *     // ... data to create a LedgerTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerTransaction we want to update
     *   }
     * })
     */
    upsert<T extends LedgerTransactionUpsertArgs>(args: SelectSubset<T, LedgerTransactionUpsertArgs<ExtArgs>>): Prisma__LedgerTransactionClient<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LedgerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionCountArgs} args - Arguments to filter LedgerTransactions to count.
     * @example
     * // Count the number of LedgerTransactions
     * const count = await prisma.ledgerTransaction.count({
     *   where: {
     *     // ... the filter for the LedgerTransactions we want to count
     *   }
     * })
    **/
    count<T extends LedgerTransactionCountArgs>(
      args?: Subset<T, LedgerTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerTransactionAggregateArgs>(args: Subset<T, LedgerTransactionAggregateArgs>): Prisma.PrismaPromise<GetLedgerTransactionAggregateType<T>>

    /**
     * Group by LedgerTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerTransactionGroupByArgs['orderBy'] }
        : { orderBy?: LedgerTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerTransaction model
   */
  readonly fields: LedgerTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends LedgerTransaction$branchArgs<ExtArgs> = {}>(args?: Subset<T, LedgerTransaction$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    journalEntry<T extends JournalEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntryDefaultArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    partner<T extends LedgerTransaction$partnerArgs<ExtArgs> = {}>(args?: Subset<T, LedgerTransaction$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    card<T extends LedgerTransaction$cardArgs<ExtArgs> = {}>(args?: Subset<T, LedgerTransaction$cardArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerTransaction model
   */ 
  interface LedgerTransactionFieldRefs {
    readonly id: FieldRef<"LedgerTransaction", 'String'>
    readonly journalEntryId: FieldRef<"LedgerTransaction", 'String'>
    readonly accountId: FieldRef<"LedgerTransaction", 'String'>
    readonly debit: FieldRef<"LedgerTransaction", 'Decimal'>
    readonly credit: FieldRef<"LedgerTransaction", 'Decimal'>
    readonly partnerId: FieldRef<"LedgerTransaction", 'String'>
    readonly companyId: FieldRef<"LedgerTransaction", 'String'>
    readonly branchId: FieldRef<"LedgerTransaction", 'String'>
    readonly cardId: FieldRef<"LedgerTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LedgerTransaction findUnique
   */
  export type LedgerTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransaction to fetch.
     */
    where: LedgerTransactionWhereUniqueInput
  }

  /**
   * LedgerTransaction findUniqueOrThrow
   */
  export type LedgerTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransaction to fetch.
     */
    where: LedgerTransactionWhereUniqueInput
  }

  /**
   * LedgerTransaction findFirst
   */
  export type LedgerTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransaction to fetch.
     */
    where?: LedgerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerTransactions to fetch.
     */
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerTransactions.
     */
    cursor?: LedgerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerTransactions.
     */
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * LedgerTransaction findFirstOrThrow
   */
  export type LedgerTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransaction to fetch.
     */
    where?: LedgerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerTransactions to fetch.
     */
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerTransactions.
     */
    cursor?: LedgerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerTransactions.
     */
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * LedgerTransaction findMany
   */
  export type LedgerTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LedgerTransactions to fetch.
     */
    where?: LedgerTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerTransactions to fetch.
     */
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerTransactions.
     */
    cursor?: LedgerTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerTransactions.
     */
    skip?: number
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * LedgerTransaction create
   */
  export type LedgerTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerTransaction.
     */
    data: XOR<LedgerTransactionCreateInput, LedgerTransactionUncheckedCreateInput>
  }

  /**
   * LedgerTransaction createMany
   */
  export type LedgerTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerTransactions.
     */
    data: LedgerTransactionCreateManyInput | LedgerTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerTransaction createManyAndReturn
   */
  export type LedgerTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LedgerTransactions.
     */
    data: LedgerTransactionCreateManyInput | LedgerTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerTransaction update
   */
  export type LedgerTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerTransaction.
     */
    data: XOR<LedgerTransactionUpdateInput, LedgerTransactionUncheckedUpdateInput>
    /**
     * Choose, which LedgerTransaction to update.
     */
    where: LedgerTransactionWhereUniqueInput
  }

  /**
   * LedgerTransaction updateMany
   */
  export type LedgerTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerTransactions.
     */
    data: XOR<LedgerTransactionUpdateManyMutationInput, LedgerTransactionUncheckedUpdateManyInput>
    /**
     * Filter which LedgerTransactions to update
     */
    where?: LedgerTransactionWhereInput
  }

  /**
   * LedgerTransaction upsert
   */
  export type LedgerTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerTransaction to update in case it exists.
     */
    where: LedgerTransactionWhereUniqueInput
    /**
     * In case the LedgerTransaction found by the `where` argument doesn't exist, create a new LedgerTransaction with this data.
     */
    create: XOR<LedgerTransactionCreateInput, LedgerTransactionUncheckedCreateInput>
    /**
     * In case the LedgerTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerTransactionUpdateInput, LedgerTransactionUncheckedUpdateInput>
  }

  /**
   * LedgerTransaction delete
   */
  export type LedgerTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    /**
     * Filter which LedgerTransaction to delete.
     */
    where: LedgerTransactionWhereUniqueInput
  }

  /**
   * LedgerTransaction deleteMany
   */
  export type LedgerTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerTransactions to delete
     */
    where?: LedgerTransactionWhereInput
  }

  /**
   * LedgerTransaction.branch
   */
  export type LedgerTransaction$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * LedgerTransaction.partner
   */
  export type LedgerTransaction$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * LedgerTransaction.card
   */
  export type LedgerTransaction$cardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    where?: BusinessCardWhereInput
  }

  /**
   * LedgerTransaction without action
   */
  export type LedgerTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    total: Decimal | null
    paidAmount: Decimal | null
    balance: Decimal | null
  }

  export type VoucherSumAggregateOutputType = {
    total: Decimal | null
    paidAmount: Decimal | null
    balance: Decimal | null
  }

  export type VoucherMinAggregateOutputType = {
    id: string | null
    voucherNo: string | null
    date: Date | null
    companyId: string | null
    branchId: string | null
    description: string | null
    vendorId: string | null
    vendorName: string | null
    total: Decimal | null
    paidAmount: Decimal | null
    balance: Decimal | null
    status: $Enums.VoucherStatus | null
    type: $Enums.VoucherType | null
    paymentMethod: $Enums.PaymentMethod | null
    accountId: string | null
    enteredById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    billUrl: string | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: string | null
    voucherNo: string | null
    date: Date | null
    companyId: string | null
    branchId: string | null
    description: string | null
    vendorId: string | null
    vendorName: string | null
    total: Decimal | null
    paidAmount: Decimal | null
    balance: Decimal | null
    status: $Enums.VoucherStatus | null
    type: $Enums.VoucherType | null
    paymentMethod: $Enums.PaymentMethod | null
    accountId: string | null
    enteredById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    billUrl: string | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    voucherNo: number
    date: number
    companyId: number
    branchId: number
    description: number
    vendorId: number
    vendorName: number
    total: number
    paidAmount: number
    balance: number
    status: number
    type: number
    paymentMethod: number
    accountId: number
    enteredById: number
    createdAt: number
    updatedAt: number
    billUrl: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    total?: true
    paidAmount?: true
    balance?: true
  }

  export type VoucherSumAggregateInputType = {
    total?: true
    paidAmount?: true
    balance?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    voucherNo?: true
    date?: true
    companyId?: true
    branchId?: true
    description?: true
    vendorId?: true
    vendorName?: true
    total?: true
    paidAmount?: true
    balance?: true
    status?: true
    type?: true
    paymentMethod?: true
    accountId?: true
    enteredById?: true
    createdAt?: true
    updatedAt?: true
    billUrl?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    voucherNo?: true
    date?: true
    companyId?: true
    branchId?: true
    description?: true
    vendorId?: true
    vendorName?: true
    total?: true
    paidAmount?: true
    balance?: true
    status?: true
    type?: true
    paymentMethod?: true
    accountId?: true
    enteredById?: true
    createdAt?: true
    updatedAt?: true
    billUrl?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    voucherNo?: true
    date?: true
    companyId?: true
    branchId?: true
    description?: true
    vendorId?: true
    vendorName?: true
    total?: true
    paidAmount?: true
    balance?: true
    status?: true
    type?: true
    paymentMethod?: true
    accountId?: true
    enteredById?: true
    createdAt?: true
    updatedAt?: true
    billUrl?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: string
    voucherNo: string
    date: Date
    companyId: string
    branchId: string | null
    description: string | null
    vendorId: string | null
    vendorName: string | null
    total: Decimal
    paidAmount: Decimal
    balance: Decimal
    status: $Enums.VoucherStatus
    type: $Enums.VoucherType
    paymentMethod: $Enums.PaymentMethod
    accountId: string | null
    enteredById: string
    createdAt: Date
    updatedAt: Date
    billUrl: string | null
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherNo?: boolean
    date?: boolean
    companyId?: boolean
    branchId?: boolean
    description?: boolean
    vendorId?: boolean
    vendorName?: boolean
    total?: boolean
    paidAmount?: boolean
    balance?: boolean
    status?: boolean
    type?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    enteredById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billUrl?: boolean
    account?: boolean | Voucher$accountArgs<ExtArgs>
    branch?: boolean | Voucher$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | Voucher$vendorArgs<ExtArgs>
    items?: boolean | Voucher$itemsArgs<ExtArgs>
    payments?: boolean | Voucher$paymentsArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherNo?: boolean
    date?: boolean
    companyId?: boolean
    branchId?: boolean
    description?: boolean
    vendorId?: boolean
    vendorName?: boolean
    total?: boolean
    paidAmount?: boolean
    balance?: boolean
    status?: boolean
    type?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    enteredById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billUrl?: boolean
    account?: boolean | Voucher$accountArgs<ExtArgs>
    branch?: boolean | Voucher$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | Voucher$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    voucherNo?: boolean
    date?: boolean
    companyId?: boolean
    branchId?: boolean
    description?: boolean
    vendorId?: boolean
    vendorName?: boolean
    total?: boolean
    paidAmount?: boolean
    balance?: boolean
    status?: boolean
    type?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    enteredById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billUrl?: boolean
  }

  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Voucher$accountArgs<ExtArgs>
    branch?: boolean | Voucher$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | Voucher$vendorArgs<ExtArgs>
    items?: boolean | Voucher$itemsArgs<ExtArgs>
    payments?: boolean | Voucher$paymentsArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Voucher$accountArgs<ExtArgs>
    branch?: boolean | Voucher$branchArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
    vendor?: boolean | Voucher$vendorArgs<ExtArgs>
  }

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      enteredBy: Prisma.$UserPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      items: Prisma.$VoucherItemPayload<ExtArgs>[]
      payments: Prisma.$VoucherPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voucherNo: string
      date: Date
      companyId: string
      branchId: string | null
      description: string | null
      vendorId: string | null
      vendorName: string | null
      total: Prisma.Decimal
      paidAmount: Prisma.Decimal
      balance: Prisma.Decimal
      status: $Enums.VoucherStatus
      type: $Enums.VoucherType
      paymentMethod: $Enums.PaymentMethod
      accountId: string | null
      enteredById: string
      createdAt: Date
      updatedAt: Date
      billUrl: string | null
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vouchers and returns the data saved in the database.
     * @param {VoucherCreateManyAndReturnArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends Voucher$accountArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends Voucher$branchArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enteredBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vendor<T extends Voucher$vendorArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Voucher$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Voucher$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */ 
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'String'>
    readonly voucherNo: FieldRef<"Voucher", 'String'>
    readonly date: FieldRef<"Voucher", 'DateTime'>
    readonly companyId: FieldRef<"Voucher", 'String'>
    readonly branchId: FieldRef<"Voucher", 'String'>
    readonly description: FieldRef<"Voucher", 'String'>
    readonly vendorId: FieldRef<"Voucher", 'String'>
    readonly vendorName: FieldRef<"Voucher", 'String'>
    readonly total: FieldRef<"Voucher", 'Decimal'>
    readonly paidAmount: FieldRef<"Voucher", 'Decimal'>
    readonly balance: FieldRef<"Voucher", 'Decimal'>
    readonly status: FieldRef<"Voucher", 'VoucherStatus'>
    readonly type: FieldRef<"Voucher", 'VoucherType'>
    readonly paymentMethod: FieldRef<"Voucher", 'PaymentMethod'>
    readonly accountId: FieldRef<"Voucher", 'String'>
    readonly enteredById: FieldRef<"Voucher", 'String'>
    readonly createdAt: FieldRef<"Voucher", 'DateTime'>
    readonly updatedAt: FieldRef<"Voucher", 'DateTime'>
    readonly billUrl: FieldRef<"Voucher", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher createManyAndReturn
   */
  export type VoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
  }

  /**
   * Voucher.account
   */
  export type Voucher$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Voucher.branch
   */
  export type Voucher$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Voucher.vendor
   */
  export type Voucher$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * Voucher.items
   */
  export type Voucher$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    where?: VoucherItemWhereInput
    orderBy?: VoucherItemOrderByWithRelationInput | VoucherItemOrderByWithRelationInput[]
    cursor?: VoucherItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherItemScalarFieldEnum | VoucherItemScalarFieldEnum[]
  }

  /**
   * Voucher.payments
   */
  export type Voucher$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    where?: VoucherPaymentWhereInput
    orderBy?: VoucherPaymentOrderByWithRelationInput | VoucherPaymentOrderByWithRelationInput[]
    cursor?: VoucherPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherPaymentScalarFieldEnum | VoucherPaymentScalarFieldEnum[]
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Model VoucherItem
   */

  export type AggregateVoucherItem = {
    _count: VoucherItemCountAggregateOutputType | null
    _avg: VoucherItemAvgAggregateOutputType | null
    _sum: VoucherItemSumAggregateOutputType | null
    _min: VoucherItemMinAggregateOutputType | null
    _max: VoucherItemMaxAggregateOutputType | null
  }

  export type VoucherItemAvgAggregateOutputType = {
    quantity: number | null
    amount: Decimal | null
    vatAmount: Decimal | null
    vatRate: Decimal | null
  }

  export type VoucherItemSumAggregateOutputType = {
    quantity: number | null
    amount: Decimal | null
    vatAmount: Decimal | null
    vatRate: Decimal | null
  }

  export type VoucherItemMinAggregateOutputType = {
    id: string | null
    voucherId: string | null
    categoryId: string | null
    quantity: number | null
    amount: Decimal | null
    description: string | null
    isVatApplicable: boolean | null
    vatAmount: Decimal | null
    vatRate: Decimal | null
  }

  export type VoucherItemMaxAggregateOutputType = {
    id: string | null
    voucherId: string | null
    categoryId: string | null
    quantity: number | null
    amount: Decimal | null
    description: string | null
    isVatApplicable: boolean | null
    vatAmount: Decimal | null
    vatRate: Decimal | null
  }

  export type VoucherItemCountAggregateOutputType = {
    id: number
    voucherId: number
    categoryId: number
    quantity: number
    amount: number
    description: number
    isVatApplicable: number
    vatAmount: number
    vatRate: number
    _all: number
  }


  export type VoucherItemAvgAggregateInputType = {
    quantity?: true
    amount?: true
    vatAmount?: true
    vatRate?: true
  }

  export type VoucherItemSumAggregateInputType = {
    quantity?: true
    amount?: true
    vatAmount?: true
    vatRate?: true
  }

  export type VoucherItemMinAggregateInputType = {
    id?: true
    voucherId?: true
    categoryId?: true
    quantity?: true
    amount?: true
    description?: true
    isVatApplicable?: true
    vatAmount?: true
    vatRate?: true
  }

  export type VoucherItemMaxAggregateInputType = {
    id?: true
    voucherId?: true
    categoryId?: true
    quantity?: true
    amount?: true
    description?: true
    isVatApplicable?: true
    vatAmount?: true
    vatRate?: true
  }

  export type VoucherItemCountAggregateInputType = {
    id?: true
    voucherId?: true
    categoryId?: true
    quantity?: true
    amount?: true
    description?: true
    isVatApplicable?: true
    vatAmount?: true
    vatRate?: true
    _all?: true
  }

  export type VoucherItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherItem to aggregate.
     */
    where?: VoucherItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherItems to fetch.
     */
    orderBy?: VoucherItemOrderByWithRelationInput | VoucherItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherItems
    **/
    _count?: true | VoucherItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherItemMaxAggregateInputType
  }

  export type GetVoucherItemAggregateType<T extends VoucherItemAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherItem[P]>
      : GetScalarType<T[P], AggregateVoucherItem[P]>
  }




  export type VoucherItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherItemWhereInput
    orderBy?: VoucherItemOrderByWithAggregationInput | VoucherItemOrderByWithAggregationInput[]
    by: VoucherItemScalarFieldEnum[] | VoucherItemScalarFieldEnum
    having?: VoucherItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherItemCountAggregateInputType | true
    _avg?: VoucherItemAvgAggregateInputType
    _sum?: VoucherItemSumAggregateInputType
    _min?: VoucherItemMinAggregateInputType
    _max?: VoucherItemMaxAggregateInputType
  }

  export type VoucherItemGroupByOutputType = {
    id: string
    voucherId: string
    categoryId: string
    quantity: number
    amount: Decimal
    description: string | null
    isVatApplicable: boolean
    vatAmount: Decimal
    vatRate: Decimal
    _count: VoucherItemCountAggregateOutputType | null
    _avg: VoucherItemAvgAggregateOutputType | null
    _sum: VoucherItemSumAggregateOutputType | null
    _min: VoucherItemMinAggregateOutputType | null
    _max: VoucherItemMaxAggregateOutputType | null
  }

  type GetVoucherItemGroupByPayload<T extends VoucherItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherItemGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherItemGroupByOutputType[P]>
        }
      >
    >


  export type VoucherItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    categoryId?: boolean
    quantity?: boolean
    amount?: boolean
    description?: boolean
    isVatApplicable?: boolean
    vatAmount?: boolean
    vatRate?: boolean
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherItem"]>

  export type VoucherItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    categoryId?: boolean
    quantity?: boolean
    amount?: boolean
    description?: boolean
    isVatApplicable?: boolean
    vatAmount?: boolean
    vatRate?: boolean
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherItem"]>

  export type VoucherItemSelectScalar = {
    id?: boolean
    voucherId?: boolean
    categoryId?: boolean
    quantity?: boolean
    amount?: boolean
    description?: boolean
    isVatApplicable?: boolean
    vatAmount?: boolean
    vatRate?: boolean
  }

  export type VoucherItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }
  export type VoucherItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ExpenseCategoryDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }

  export type $VoucherItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherItem"
    objects: {
      category: Prisma.$ExpenseCategoryPayload<ExtArgs>
      voucher: Prisma.$VoucherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voucherId: string
      categoryId: string
      quantity: number
      amount: Prisma.Decimal
      description: string | null
      isVatApplicable: boolean
      vatAmount: Prisma.Decimal
      vatRate: Prisma.Decimal
    }, ExtArgs["result"]["voucherItem"]>
    composites: {}
  }

  type VoucherItemGetPayload<S extends boolean | null | undefined | VoucherItemDefaultArgs> = $Result.GetResult<Prisma.$VoucherItemPayload, S>

  type VoucherItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VoucherItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VoucherItemCountAggregateInputType | true
    }

  export interface VoucherItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherItem'], meta: { name: 'VoucherItem' } }
    /**
     * Find zero or one VoucherItem that matches the filter.
     * @param {VoucherItemFindUniqueArgs} args - Arguments to find a VoucherItem
     * @example
     * // Get one VoucherItem
     * const voucherItem = await prisma.voucherItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherItemFindUniqueArgs>(args: SelectSubset<T, VoucherItemFindUniqueArgs<ExtArgs>>): Prisma__VoucherItemClient<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VoucherItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VoucherItemFindUniqueOrThrowArgs} args - Arguments to find a VoucherItem
     * @example
     * // Get one VoucherItem
     * const voucherItem = await prisma.voucherItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherItemFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherItemClient<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VoucherItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherItemFindFirstArgs} args - Arguments to find a VoucherItem
     * @example
     * // Get one VoucherItem
     * const voucherItem = await prisma.voucherItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherItemFindFirstArgs>(args?: SelectSubset<T, VoucherItemFindFirstArgs<ExtArgs>>): Prisma__VoucherItemClient<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VoucherItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherItemFindFirstOrThrowArgs} args - Arguments to find a VoucherItem
     * @example
     * // Get one VoucherItem
     * const voucherItem = await prisma.voucherItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherItemFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherItemClient<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VoucherItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherItems
     * const voucherItems = await prisma.voucherItem.findMany()
     * 
     * // Get first 10 VoucherItems
     * const voucherItems = await prisma.voucherItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherItemWithIdOnly = await prisma.voucherItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherItemFindManyArgs>(args?: SelectSubset<T, VoucherItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VoucherItem.
     * @param {VoucherItemCreateArgs} args - Arguments to create a VoucherItem.
     * @example
     * // Create one VoucherItem
     * const VoucherItem = await prisma.voucherItem.create({
     *   data: {
     *     // ... data to create a VoucherItem
     *   }
     * })
     * 
     */
    create<T extends VoucherItemCreateArgs>(args: SelectSubset<T, VoucherItemCreateArgs<ExtArgs>>): Prisma__VoucherItemClient<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VoucherItems.
     * @param {VoucherItemCreateManyArgs} args - Arguments to create many VoucherItems.
     * @example
     * // Create many VoucherItems
     * const voucherItem = await prisma.voucherItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherItemCreateManyArgs>(args?: SelectSubset<T, VoucherItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoucherItems and returns the data saved in the database.
     * @param {VoucherItemCreateManyAndReturnArgs} args - Arguments to create many VoucherItems.
     * @example
     * // Create many VoucherItems
     * const voucherItem = await prisma.voucherItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoucherItems and only return the `id`
     * const voucherItemWithIdOnly = await prisma.voucherItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherItemCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VoucherItem.
     * @param {VoucherItemDeleteArgs} args - Arguments to delete one VoucherItem.
     * @example
     * // Delete one VoucherItem
     * const VoucherItem = await prisma.voucherItem.delete({
     *   where: {
     *     // ... filter to delete one VoucherItem
     *   }
     * })
     * 
     */
    delete<T extends VoucherItemDeleteArgs>(args: SelectSubset<T, VoucherItemDeleteArgs<ExtArgs>>): Prisma__VoucherItemClient<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VoucherItem.
     * @param {VoucherItemUpdateArgs} args - Arguments to update one VoucherItem.
     * @example
     * // Update one VoucherItem
     * const voucherItem = await prisma.voucherItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherItemUpdateArgs>(args: SelectSubset<T, VoucherItemUpdateArgs<ExtArgs>>): Prisma__VoucherItemClient<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VoucherItems.
     * @param {VoucherItemDeleteManyArgs} args - Arguments to filter VoucherItems to delete.
     * @example
     * // Delete a few VoucherItems
     * const { count } = await prisma.voucherItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherItemDeleteManyArgs>(args?: SelectSubset<T, VoucherItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherItems
     * const voucherItem = await prisma.voucherItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherItemUpdateManyArgs>(args: SelectSubset<T, VoucherItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VoucherItem.
     * @param {VoucherItemUpsertArgs} args - Arguments to update or create a VoucherItem.
     * @example
     * // Update or create a VoucherItem
     * const voucherItem = await prisma.voucherItem.upsert({
     *   create: {
     *     // ... data to create a VoucherItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherItem we want to update
     *   }
     * })
     */
    upsert<T extends VoucherItemUpsertArgs>(args: SelectSubset<T, VoucherItemUpsertArgs<ExtArgs>>): Prisma__VoucherItemClient<$Result.GetResult<Prisma.$VoucherItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VoucherItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherItemCountArgs} args - Arguments to filter VoucherItems to count.
     * @example
     * // Count the number of VoucherItems
     * const count = await prisma.voucherItem.count({
     *   where: {
     *     // ... the filter for the VoucherItems we want to count
     *   }
     * })
    **/
    count<T extends VoucherItemCountArgs>(
      args?: Subset<T, VoucherItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherItemAggregateArgs>(args: Subset<T, VoucherItemAggregateArgs>): Prisma.PrismaPromise<GetVoucherItemAggregateType<T>>

    /**
     * Group by VoucherItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherItemGroupByArgs['orderBy'] }
        : { orderBy?: VoucherItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherItem model
   */
  readonly fields: VoucherItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ExpenseCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategoryDefaultArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    voucher<T extends VoucherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoucherDefaultArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoucherItem model
   */ 
  interface VoucherItemFieldRefs {
    readonly id: FieldRef<"VoucherItem", 'String'>
    readonly voucherId: FieldRef<"VoucherItem", 'String'>
    readonly categoryId: FieldRef<"VoucherItem", 'String'>
    readonly quantity: FieldRef<"VoucherItem", 'Int'>
    readonly amount: FieldRef<"VoucherItem", 'Decimal'>
    readonly description: FieldRef<"VoucherItem", 'String'>
    readonly isVatApplicable: FieldRef<"VoucherItem", 'Boolean'>
    readonly vatAmount: FieldRef<"VoucherItem", 'Decimal'>
    readonly vatRate: FieldRef<"VoucherItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * VoucherItem findUnique
   */
  export type VoucherItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * Filter, which VoucherItem to fetch.
     */
    where: VoucherItemWhereUniqueInput
  }

  /**
   * VoucherItem findUniqueOrThrow
   */
  export type VoucherItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * Filter, which VoucherItem to fetch.
     */
    where: VoucherItemWhereUniqueInput
  }

  /**
   * VoucherItem findFirst
   */
  export type VoucherItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * Filter, which VoucherItem to fetch.
     */
    where?: VoucherItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherItems to fetch.
     */
    orderBy?: VoucherItemOrderByWithRelationInput | VoucherItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherItems.
     */
    cursor?: VoucherItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherItems.
     */
    distinct?: VoucherItemScalarFieldEnum | VoucherItemScalarFieldEnum[]
  }

  /**
   * VoucherItem findFirstOrThrow
   */
  export type VoucherItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * Filter, which VoucherItem to fetch.
     */
    where?: VoucherItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherItems to fetch.
     */
    orderBy?: VoucherItemOrderByWithRelationInput | VoucherItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherItems.
     */
    cursor?: VoucherItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherItems.
     */
    distinct?: VoucherItemScalarFieldEnum | VoucherItemScalarFieldEnum[]
  }

  /**
   * VoucherItem findMany
   */
  export type VoucherItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * Filter, which VoucherItems to fetch.
     */
    where?: VoucherItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherItems to fetch.
     */
    orderBy?: VoucherItemOrderByWithRelationInput | VoucherItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherItems.
     */
    cursor?: VoucherItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherItems.
     */
    skip?: number
    distinct?: VoucherItemScalarFieldEnum | VoucherItemScalarFieldEnum[]
  }

  /**
   * VoucherItem create
   */
  export type VoucherItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * The data needed to create a VoucherItem.
     */
    data: XOR<VoucherItemCreateInput, VoucherItemUncheckedCreateInput>
  }

  /**
   * VoucherItem createMany
   */
  export type VoucherItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherItems.
     */
    data: VoucherItemCreateManyInput | VoucherItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoucherItem createManyAndReturn
   */
  export type VoucherItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VoucherItems.
     */
    data: VoucherItemCreateManyInput | VoucherItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherItem update
   */
  export type VoucherItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * The data needed to update a VoucherItem.
     */
    data: XOR<VoucherItemUpdateInput, VoucherItemUncheckedUpdateInput>
    /**
     * Choose, which VoucherItem to update.
     */
    where: VoucherItemWhereUniqueInput
  }

  /**
   * VoucherItem updateMany
   */
  export type VoucherItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherItems.
     */
    data: XOR<VoucherItemUpdateManyMutationInput, VoucherItemUncheckedUpdateManyInput>
    /**
     * Filter which VoucherItems to update
     */
    where?: VoucherItemWhereInput
  }

  /**
   * VoucherItem upsert
   */
  export type VoucherItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * The filter to search for the VoucherItem to update in case it exists.
     */
    where: VoucherItemWhereUniqueInput
    /**
     * In case the VoucherItem found by the `where` argument doesn't exist, create a new VoucherItem with this data.
     */
    create: XOR<VoucherItemCreateInput, VoucherItemUncheckedCreateInput>
    /**
     * In case the VoucherItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherItemUpdateInput, VoucherItemUncheckedUpdateInput>
  }

  /**
   * VoucherItem delete
   */
  export type VoucherItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
    /**
     * Filter which VoucherItem to delete.
     */
    where: VoucherItemWhereUniqueInput
  }

  /**
   * VoucherItem deleteMany
   */
  export type VoucherItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherItems to delete
     */
    where?: VoucherItemWhereInput
  }

  /**
   * VoucherItem without action
   */
  export type VoucherItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherItem
     */
    select?: VoucherItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherItemInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    phone: number
    email: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    companyId: string
    name: string
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vouchers?: boolean | Vendor$vouchersArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vouchers?: boolean | Vendor$vouchersArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      vouchers: Prisma.$VoucherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      phone: string | null
      email: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vouchers<T extends Vendor$vouchersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$vouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */ 
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly companyId: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor.vouchers
   */
  export type Vendor$vouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model VoucherPayment
   */

  export type AggregateVoucherPayment = {
    _count: VoucherPaymentCountAggregateOutputType | null
    _avg: VoucherPaymentAvgAggregateOutputType | null
    _sum: VoucherPaymentSumAggregateOutputType | null
    _min: VoucherPaymentMinAggregateOutputType | null
    _max: VoucherPaymentMaxAggregateOutputType | null
  }

  export type VoucherPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type VoucherPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type VoucherPaymentMinAggregateOutputType = {
    id: string | null
    voucherId: string | null
    date: Date | null
    amount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    accountId: string | null
    receiptNo: string | null
    enteredById: string | null
    createdAt: Date | null
    companyId: string | null
  }

  export type VoucherPaymentMaxAggregateOutputType = {
    id: string | null
    voucherId: string | null
    date: Date | null
    amount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    accountId: string | null
    receiptNo: string | null
    enteredById: string | null
    createdAt: Date | null
    companyId: string | null
  }

  export type VoucherPaymentCountAggregateOutputType = {
    id: number
    voucherId: number
    date: number
    amount: number
    paymentMethod: number
    accountId: number
    receiptNo: number
    enteredById: number
    createdAt: number
    companyId: number
    _all: number
  }


  export type VoucherPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type VoucherPaymentSumAggregateInputType = {
    amount?: true
  }

  export type VoucherPaymentMinAggregateInputType = {
    id?: true
    voucherId?: true
    date?: true
    amount?: true
    paymentMethod?: true
    accountId?: true
    receiptNo?: true
    enteredById?: true
    createdAt?: true
    companyId?: true
  }

  export type VoucherPaymentMaxAggregateInputType = {
    id?: true
    voucherId?: true
    date?: true
    amount?: true
    paymentMethod?: true
    accountId?: true
    receiptNo?: true
    enteredById?: true
    createdAt?: true
    companyId?: true
  }

  export type VoucherPaymentCountAggregateInputType = {
    id?: true
    voucherId?: true
    date?: true
    amount?: true
    paymentMethod?: true
    accountId?: true
    receiptNo?: true
    enteredById?: true
    createdAt?: true
    companyId?: true
    _all?: true
  }

  export type VoucherPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherPayment to aggregate.
     */
    where?: VoucherPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherPayments to fetch.
     */
    orderBy?: VoucherPaymentOrderByWithRelationInput | VoucherPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherPayments
    **/
    _count?: true | VoucherPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherPaymentMaxAggregateInputType
  }

  export type GetVoucherPaymentAggregateType<T extends VoucherPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherPayment[P]>
      : GetScalarType<T[P], AggregateVoucherPayment[P]>
  }




  export type VoucherPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherPaymentWhereInput
    orderBy?: VoucherPaymentOrderByWithAggregationInput | VoucherPaymentOrderByWithAggregationInput[]
    by: VoucherPaymentScalarFieldEnum[] | VoucherPaymentScalarFieldEnum
    having?: VoucherPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherPaymentCountAggregateInputType | true
    _avg?: VoucherPaymentAvgAggregateInputType
    _sum?: VoucherPaymentSumAggregateInputType
    _min?: VoucherPaymentMinAggregateInputType
    _max?: VoucherPaymentMaxAggregateInputType
  }

  export type VoucherPaymentGroupByOutputType = {
    id: string
    voucherId: string
    date: Date
    amount: Decimal
    paymentMethod: $Enums.PaymentMethod
    accountId: string | null
    receiptNo: string
    enteredById: string
    createdAt: Date
    companyId: string
    _count: VoucherPaymentCountAggregateOutputType | null
    _avg: VoucherPaymentAvgAggregateOutputType | null
    _sum: VoucherPaymentSumAggregateOutputType | null
    _min: VoucherPaymentMinAggregateOutputType | null
    _max: VoucherPaymentMaxAggregateOutputType | null
  }

  type GetVoucherPaymentGroupByPayload<T extends VoucherPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherPaymentGroupByOutputType[P]>
        }
      >
    >


  export type VoucherPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    receiptNo?: boolean
    enteredById?: boolean
    createdAt?: boolean
    companyId?: boolean
    account?: boolean | VoucherPayment$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherPayment"]>

  export type VoucherPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    receiptNo?: boolean
    enteredById?: boolean
    createdAt?: boolean
    companyId?: boolean
    account?: boolean | VoucherPayment$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherPayment"]>

  export type VoucherPaymentSelectScalar = {
    id?: boolean
    voucherId?: boolean
    date?: boolean
    amount?: boolean
    paymentMethod?: boolean
    accountId?: boolean
    receiptNo?: boolean
    enteredById?: boolean
    createdAt?: boolean
    companyId?: boolean
  }

  export type VoucherPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | VoucherPayment$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }
  export type VoucherPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | VoucherPayment$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    enteredBy?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }

  export type $VoucherPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherPayment"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      enteredBy: Prisma.$UserPayload<ExtArgs>
      voucher: Prisma.$VoucherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voucherId: string
      date: Date
      amount: Prisma.Decimal
      paymentMethod: $Enums.PaymentMethod
      accountId: string | null
      receiptNo: string
      enteredById: string
      createdAt: Date
      companyId: string
    }, ExtArgs["result"]["voucherPayment"]>
    composites: {}
  }

  type VoucherPaymentGetPayload<S extends boolean | null | undefined | VoucherPaymentDefaultArgs> = $Result.GetResult<Prisma.$VoucherPaymentPayload, S>

  type VoucherPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VoucherPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VoucherPaymentCountAggregateInputType | true
    }

  export interface VoucherPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherPayment'], meta: { name: 'VoucherPayment' } }
    /**
     * Find zero or one VoucherPayment that matches the filter.
     * @param {VoucherPaymentFindUniqueArgs} args - Arguments to find a VoucherPayment
     * @example
     * // Get one VoucherPayment
     * const voucherPayment = await prisma.voucherPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherPaymentFindUniqueArgs>(args: SelectSubset<T, VoucherPaymentFindUniqueArgs<ExtArgs>>): Prisma__VoucherPaymentClient<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VoucherPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VoucherPaymentFindUniqueOrThrowArgs} args - Arguments to find a VoucherPayment
     * @example
     * // Get one VoucherPayment
     * const voucherPayment = await prisma.voucherPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherPaymentClient<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VoucherPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherPaymentFindFirstArgs} args - Arguments to find a VoucherPayment
     * @example
     * // Get one VoucherPayment
     * const voucherPayment = await prisma.voucherPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherPaymentFindFirstArgs>(args?: SelectSubset<T, VoucherPaymentFindFirstArgs<ExtArgs>>): Prisma__VoucherPaymentClient<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VoucherPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherPaymentFindFirstOrThrowArgs} args - Arguments to find a VoucherPayment
     * @example
     * // Get one VoucherPayment
     * const voucherPayment = await prisma.voucherPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherPaymentClient<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VoucherPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherPayments
     * const voucherPayments = await prisma.voucherPayment.findMany()
     * 
     * // Get first 10 VoucherPayments
     * const voucherPayments = await prisma.voucherPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherPaymentWithIdOnly = await prisma.voucherPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherPaymentFindManyArgs>(args?: SelectSubset<T, VoucherPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VoucherPayment.
     * @param {VoucherPaymentCreateArgs} args - Arguments to create a VoucherPayment.
     * @example
     * // Create one VoucherPayment
     * const VoucherPayment = await prisma.voucherPayment.create({
     *   data: {
     *     // ... data to create a VoucherPayment
     *   }
     * })
     * 
     */
    create<T extends VoucherPaymentCreateArgs>(args: SelectSubset<T, VoucherPaymentCreateArgs<ExtArgs>>): Prisma__VoucherPaymentClient<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VoucherPayments.
     * @param {VoucherPaymentCreateManyArgs} args - Arguments to create many VoucherPayments.
     * @example
     * // Create many VoucherPayments
     * const voucherPayment = await prisma.voucherPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherPaymentCreateManyArgs>(args?: SelectSubset<T, VoucherPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoucherPayments and returns the data saved in the database.
     * @param {VoucherPaymentCreateManyAndReturnArgs} args - Arguments to create many VoucherPayments.
     * @example
     * // Create many VoucherPayments
     * const voucherPayment = await prisma.voucherPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoucherPayments and only return the `id`
     * const voucherPaymentWithIdOnly = await prisma.voucherPayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VoucherPayment.
     * @param {VoucherPaymentDeleteArgs} args - Arguments to delete one VoucherPayment.
     * @example
     * // Delete one VoucherPayment
     * const VoucherPayment = await prisma.voucherPayment.delete({
     *   where: {
     *     // ... filter to delete one VoucherPayment
     *   }
     * })
     * 
     */
    delete<T extends VoucherPaymentDeleteArgs>(args: SelectSubset<T, VoucherPaymentDeleteArgs<ExtArgs>>): Prisma__VoucherPaymentClient<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VoucherPayment.
     * @param {VoucherPaymentUpdateArgs} args - Arguments to update one VoucherPayment.
     * @example
     * // Update one VoucherPayment
     * const voucherPayment = await prisma.voucherPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherPaymentUpdateArgs>(args: SelectSubset<T, VoucherPaymentUpdateArgs<ExtArgs>>): Prisma__VoucherPaymentClient<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VoucherPayments.
     * @param {VoucherPaymentDeleteManyArgs} args - Arguments to filter VoucherPayments to delete.
     * @example
     * // Delete a few VoucherPayments
     * const { count } = await prisma.voucherPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherPaymentDeleteManyArgs>(args?: SelectSubset<T, VoucherPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherPayments
     * const voucherPayment = await prisma.voucherPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherPaymentUpdateManyArgs>(args: SelectSubset<T, VoucherPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VoucherPayment.
     * @param {VoucherPaymentUpsertArgs} args - Arguments to update or create a VoucherPayment.
     * @example
     * // Update or create a VoucherPayment
     * const voucherPayment = await prisma.voucherPayment.upsert({
     *   create: {
     *     // ... data to create a VoucherPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherPayment we want to update
     *   }
     * })
     */
    upsert<T extends VoucherPaymentUpsertArgs>(args: SelectSubset<T, VoucherPaymentUpsertArgs<ExtArgs>>): Prisma__VoucherPaymentClient<$Result.GetResult<Prisma.$VoucherPaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VoucherPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherPaymentCountArgs} args - Arguments to filter VoucherPayments to count.
     * @example
     * // Count the number of VoucherPayments
     * const count = await prisma.voucherPayment.count({
     *   where: {
     *     // ... the filter for the VoucherPayments we want to count
     *   }
     * })
    **/
    count<T extends VoucherPaymentCountArgs>(
      args?: Subset<T, VoucherPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherPaymentAggregateArgs>(args: Subset<T, VoucherPaymentAggregateArgs>): Prisma.PrismaPromise<GetVoucherPaymentAggregateType<T>>

    /**
     * Group by VoucherPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherPaymentGroupByArgs['orderBy'] }
        : { orderBy?: VoucherPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherPayment model
   */
  readonly fields: VoucherPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends VoucherPayment$accountArgs<ExtArgs> = {}>(args?: Subset<T, VoucherPayment$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    enteredBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    voucher<T extends VoucherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoucherDefaultArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoucherPayment model
   */ 
  interface VoucherPaymentFieldRefs {
    readonly id: FieldRef<"VoucherPayment", 'String'>
    readonly voucherId: FieldRef<"VoucherPayment", 'String'>
    readonly date: FieldRef<"VoucherPayment", 'DateTime'>
    readonly amount: FieldRef<"VoucherPayment", 'Decimal'>
    readonly paymentMethod: FieldRef<"VoucherPayment", 'PaymentMethod'>
    readonly accountId: FieldRef<"VoucherPayment", 'String'>
    readonly receiptNo: FieldRef<"VoucherPayment", 'String'>
    readonly enteredById: FieldRef<"VoucherPayment", 'String'>
    readonly createdAt: FieldRef<"VoucherPayment", 'DateTime'>
    readonly companyId: FieldRef<"VoucherPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VoucherPayment findUnique
   */
  export type VoucherPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VoucherPayment to fetch.
     */
    where: VoucherPaymentWhereUniqueInput
  }

  /**
   * VoucherPayment findUniqueOrThrow
   */
  export type VoucherPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VoucherPayment to fetch.
     */
    where: VoucherPaymentWhereUniqueInput
  }

  /**
   * VoucherPayment findFirst
   */
  export type VoucherPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VoucherPayment to fetch.
     */
    where?: VoucherPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherPayments to fetch.
     */
    orderBy?: VoucherPaymentOrderByWithRelationInput | VoucherPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherPayments.
     */
    cursor?: VoucherPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherPayments.
     */
    distinct?: VoucherPaymentScalarFieldEnum | VoucherPaymentScalarFieldEnum[]
  }

  /**
   * VoucherPayment findFirstOrThrow
   */
  export type VoucherPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VoucherPayment to fetch.
     */
    where?: VoucherPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherPayments to fetch.
     */
    orderBy?: VoucherPaymentOrderByWithRelationInput | VoucherPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherPayments.
     */
    cursor?: VoucherPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherPayments.
     */
    distinct?: VoucherPaymentScalarFieldEnum | VoucherPaymentScalarFieldEnum[]
  }

  /**
   * VoucherPayment findMany
   */
  export type VoucherPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VoucherPayments to fetch.
     */
    where?: VoucherPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherPayments to fetch.
     */
    orderBy?: VoucherPaymentOrderByWithRelationInput | VoucherPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherPayments.
     */
    cursor?: VoucherPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherPayments.
     */
    skip?: number
    distinct?: VoucherPaymentScalarFieldEnum | VoucherPaymentScalarFieldEnum[]
  }

  /**
   * VoucherPayment create
   */
  export type VoucherPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a VoucherPayment.
     */
    data: XOR<VoucherPaymentCreateInput, VoucherPaymentUncheckedCreateInput>
  }

  /**
   * VoucherPayment createMany
   */
  export type VoucherPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherPayments.
     */
    data: VoucherPaymentCreateManyInput | VoucherPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoucherPayment createManyAndReturn
   */
  export type VoucherPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VoucherPayments.
     */
    data: VoucherPaymentCreateManyInput | VoucherPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherPayment update
   */
  export type VoucherPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a VoucherPayment.
     */
    data: XOR<VoucherPaymentUpdateInput, VoucherPaymentUncheckedUpdateInput>
    /**
     * Choose, which VoucherPayment to update.
     */
    where: VoucherPaymentWhereUniqueInput
  }

  /**
   * VoucherPayment updateMany
   */
  export type VoucherPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherPayments.
     */
    data: XOR<VoucherPaymentUpdateManyMutationInput, VoucherPaymentUncheckedUpdateManyInput>
    /**
     * Filter which VoucherPayments to update
     */
    where?: VoucherPaymentWhereInput
  }

  /**
   * VoucherPayment upsert
   */
  export type VoucherPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the VoucherPayment to update in case it exists.
     */
    where: VoucherPaymentWhereUniqueInput
    /**
     * In case the VoucherPayment found by the `where` argument doesn't exist, create a new VoucherPayment with this data.
     */
    create: XOR<VoucherPaymentCreateInput, VoucherPaymentUncheckedCreateInput>
    /**
     * In case the VoucherPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherPaymentUpdateInput, VoucherPaymentUncheckedUpdateInput>
  }

  /**
   * VoucherPayment delete
   */
  export type VoucherPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
    /**
     * Filter which VoucherPayment to delete.
     */
    where: VoucherPaymentWhereUniqueInput
  }

  /**
   * VoucherPayment deleteMany
   */
  export type VoucherPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherPayments to delete
     */
    where?: VoucherPaymentWhereInput
  }

  /**
   * VoucherPayment.account
   */
  export type VoucherPayment$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * VoucherPayment without action
   */
  export type VoucherPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherPayment
     */
    select?: VoucherPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherPaymentInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    usedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    usedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    usedAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    usedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    usedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      usedAt: Date | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly ipAddress: FieldRef<"PasswordResetToken", 'String'>
    readonly userAgent: FieldRef<"PasswordResetToken", 'String'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model BusinessCard
   */

  export type AggregateBusinessCard = {
    _count: BusinessCardCountAggregateOutputType | null
    _avg: BusinessCardAvgAggregateOutputType | null
    _sum: BusinessCardSumAggregateOutputType | null
    _min: BusinessCardMinAggregateOutputType | null
    _max: BusinessCardMaxAggregateOutputType | null
  }

  export type BusinessCardAvgAggregateOutputType = {
    creditLimit: Decimal | null
    statementCycleDay: number | null
    paymentDueDays: number | null
  }

  export type BusinessCardSumAggregateOutputType = {
    creditLimit: Decimal | null
    statementCycleDay: number | null
    paymentDueDays: number | null
  }

  export type BusinessCardMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    type: $Enums.CardType | null
    issuingBank: string | null
    last4Digits: string | null
    creditLimit: Decimal | null
    currency: string | null
    statementCycleDay: number | null
    paymentDueDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ledgerAccountId: string | null
  }

  export type BusinessCardMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    type: $Enums.CardType | null
    issuingBank: string | null
    last4Digits: string | null
    creditLimit: Decimal | null
    currency: string | null
    statementCycleDay: number | null
    paymentDueDays: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ledgerAccountId: string | null
  }

  export type BusinessCardCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    type: number
    issuingBank: number
    last4Digits: number
    creditLimit: number
    currency: number
    statementCycleDay: number
    paymentDueDays: number
    isActive: number
    createdAt: number
    updatedAt: number
    ledgerAccountId: number
    _all: number
  }


  export type BusinessCardAvgAggregateInputType = {
    creditLimit?: true
    statementCycleDay?: true
    paymentDueDays?: true
  }

  export type BusinessCardSumAggregateInputType = {
    creditLimit?: true
    statementCycleDay?: true
    paymentDueDays?: true
  }

  export type BusinessCardMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    issuingBank?: true
    last4Digits?: true
    creditLimit?: true
    currency?: true
    statementCycleDay?: true
    paymentDueDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ledgerAccountId?: true
  }

  export type BusinessCardMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    issuingBank?: true
    last4Digits?: true
    creditLimit?: true
    currency?: true
    statementCycleDay?: true
    paymentDueDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ledgerAccountId?: true
  }

  export type BusinessCardCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    type?: true
    issuingBank?: true
    last4Digits?: true
    creditLimit?: true
    currency?: true
    statementCycleDay?: true
    paymentDueDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ledgerAccountId?: true
    _all?: true
  }

  export type BusinessCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessCard to aggregate.
     */
    where?: BusinessCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCards to fetch.
     */
    orderBy?: BusinessCardOrderByWithRelationInput | BusinessCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessCards
    **/
    _count?: true | BusinessCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessCardMaxAggregateInputType
  }

  export type GetBusinessCardAggregateType<T extends BusinessCardAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessCard[P]>
      : GetScalarType<T[P], AggregateBusinessCard[P]>
  }




  export type BusinessCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessCardWhereInput
    orderBy?: BusinessCardOrderByWithAggregationInput | BusinessCardOrderByWithAggregationInput[]
    by: BusinessCardScalarFieldEnum[] | BusinessCardScalarFieldEnum
    having?: BusinessCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCardCountAggregateInputType | true
    _avg?: BusinessCardAvgAggregateInputType
    _sum?: BusinessCardSumAggregateInputType
    _min?: BusinessCardMinAggregateInputType
    _max?: BusinessCardMaxAggregateInputType
  }

  export type BusinessCardGroupByOutputType = {
    id: string
    companyId: string
    name: string
    type: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit: Decimal | null
    currency: string
    statementCycleDay: number | null
    paymentDueDays: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    ledgerAccountId: string
    _count: BusinessCardCountAggregateOutputType | null
    _avg: BusinessCardAvgAggregateOutputType | null
    _sum: BusinessCardSumAggregateOutputType | null
    _min: BusinessCardMinAggregateOutputType | null
    _max: BusinessCardMaxAggregateOutputType | null
  }

  type GetBusinessCardGroupByPayload<T extends BusinessCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessCardGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessCardGroupByOutputType[P]>
        }
      >
    >


  export type BusinessCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    issuingBank?: boolean
    last4Digits?: boolean
    creditLimit?: boolean
    currency?: boolean
    statementCycleDay?: boolean
    paymentDueDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ledgerAccountId?: boolean
    ledgerAccount?: boolean | AccountDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    ledgerTransactions?: boolean | BusinessCard$ledgerTransactionsArgs<ExtArgs>
    _count?: boolean | BusinessCardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessCard"]>

  export type BusinessCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    issuingBank?: boolean
    last4Digits?: boolean
    creditLimit?: boolean
    currency?: boolean
    statementCycleDay?: boolean
    paymentDueDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ledgerAccountId?: boolean
    ledgerAccount?: boolean | AccountDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessCard"]>

  export type BusinessCardSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    type?: boolean
    issuingBank?: boolean
    last4Digits?: boolean
    creditLimit?: boolean
    currency?: boolean
    statementCycleDay?: boolean
    paymentDueDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ledgerAccountId?: boolean
  }

  export type BusinessCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerAccount?: boolean | AccountDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    ledgerTransactions?: boolean | BusinessCard$ledgerTransactionsArgs<ExtArgs>
    _count?: boolean | BusinessCardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerAccount?: boolean | AccountDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $BusinessCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessCard"
    objects: {
      ledgerAccount: Prisma.$AccountPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      ledgerTransactions: Prisma.$LedgerTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      type: $Enums.CardType
      issuingBank: string
      last4Digits: string
      creditLimit: Prisma.Decimal | null
      currency: string
      statementCycleDay: number | null
      paymentDueDays: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      ledgerAccountId: string
    }, ExtArgs["result"]["businessCard"]>
    composites: {}
  }

  type BusinessCardGetPayload<S extends boolean | null | undefined | BusinessCardDefaultArgs> = $Result.GetResult<Prisma.$BusinessCardPayload, S>

  type BusinessCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessCardCountAggregateInputType | true
    }

  export interface BusinessCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessCard'], meta: { name: 'BusinessCard' } }
    /**
     * Find zero or one BusinessCard that matches the filter.
     * @param {BusinessCardFindUniqueArgs} args - Arguments to find a BusinessCard
     * @example
     * // Get one BusinessCard
     * const businessCard = await prisma.businessCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessCardFindUniqueArgs>(args: SelectSubset<T, BusinessCardFindUniqueArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessCardFindUniqueOrThrowArgs} args - Arguments to find a BusinessCard
     * @example
     * // Get one BusinessCard
     * const businessCard = await prisma.businessCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessCardFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCardFindFirstArgs} args - Arguments to find a BusinessCard
     * @example
     * // Get one BusinessCard
     * const businessCard = await prisma.businessCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessCardFindFirstArgs>(args?: SelectSubset<T, BusinessCardFindFirstArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCardFindFirstOrThrowArgs} args - Arguments to find a BusinessCard
     * @example
     * // Get one BusinessCard
     * const businessCard = await prisma.businessCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessCardFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessCards
     * const businessCards = await prisma.businessCard.findMany()
     * 
     * // Get first 10 BusinessCards
     * const businessCards = await prisma.businessCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessCardWithIdOnly = await prisma.businessCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessCardFindManyArgs>(args?: SelectSubset<T, BusinessCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessCard.
     * @param {BusinessCardCreateArgs} args - Arguments to create a BusinessCard.
     * @example
     * // Create one BusinessCard
     * const BusinessCard = await prisma.businessCard.create({
     *   data: {
     *     // ... data to create a BusinessCard
     *   }
     * })
     * 
     */
    create<T extends BusinessCardCreateArgs>(args: SelectSubset<T, BusinessCardCreateArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessCards.
     * @param {BusinessCardCreateManyArgs} args - Arguments to create many BusinessCards.
     * @example
     * // Create many BusinessCards
     * const businessCard = await prisma.businessCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCardCreateManyArgs>(args?: SelectSubset<T, BusinessCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessCards and returns the data saved in the database.
     * @param {BusinessCardCreateManyAndReturnArgs} args - Arguments to create many BusinessCards.
     * @example
     * // Create many BusinessCards
     * const businessCard = await prisma.businessCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessCards and only return the `id`
     * const businessCardWithIdOnly = await prisma.businessCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessCardCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessCard.
     * @param {BusinessCardDeleteArgs} args - Arguments to delete one BusinessCard.
     * @example
     * // Delete one BusinessCard
     * const BusinessCard = await prisma.businessCard.delete({
     *   where: {
     *     // ... filter to delete one BusinessCard
     *   }
     * })
     * 
     */
    delete<T extends BusinessCardDeleteArgs>(args: SelectSubset<T, BusinessCardDeleteArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessCard.
     * @param {BusinessCardUpdateArgs} args - Arguments to update one BusinessCard.
     * @example
     * // Update one BusinessCard
     * const businessCard = await prisma.businessCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessCardUpdateArgs>(args: SelectSubset<T, BusinessCardUpdateArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessCards.
     * @param {BusinessCardDeleteManyArgs} args - Arguments to filter BusinessCards to delete.
     * @example
     * // Delete a few BusinessCards
     * const { count } = await prisma.businessCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessCardDeleteManyArgs>(args?: SelectSubset<T, BusinessCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessCards
     * const businessCard = await prisma.businessCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessCardUpdateManyArgs>(args: SelectSubset<T, BusinessCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessCard.
     * @param {BusinessCardUpsertArgs} args - Arguments to update or create a BusinessCard.
     * @example
     * // Update or create a BusinessCard
     * const businessCard = await prisma.businessCard.upsert({
     *   create: {
     *     // ... data to create a BusinessCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessCard we want to update
     *   }
     * })
     */
    upsert<T extends BusinessCardUpsertArgs>(args: SelectSubset<T, BusinessCardUpsertArgs<ExtArgs>>): Prisma__BusinessCardClient<$Result.GetResult<Prisma.$BusinessCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCardCountArgs} args - Arguments to filter BusinessCards to count.
     * @example
     * // Count the number of BusinessCards
     * const count = await prisma.businessCard.count({
     *   where: {
     *     // ... the filter for the BusinessCards we want to count
     *   }
     * })
    **/
    count<T extends BusinessCardCountArgs>(
      args?: Subset<T, BusinessCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessCardAggregateArgs>(args: Subset<T, BusinessCardAggregateArgs>): Prisma.PrismaPromise<GetBusinessCardAggregateType<T>>

    /**
     * Group by BusinessCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessCardGroupByArgs['orderBy'] }
        : { orderBy?: BusinessCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessCard model
   */
  readonly fields: BusinessCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ledgerAccount<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ledgerTransactions<T extends BusinessCard$ledgerTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessCard$ledgerTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessCard model
   */ 
  interface BusinessCardFieldRefs {
    readonly id: FieldRef<"BusinessCard", 'String'>
    readonly companyId: FieldRef<"BusinessCard", 'String'>
    readonly name: FieldRef<"BusinessCard", 'String'>
    readonly type: FieldRef<"BusinessCard", 'CardType'>
    readonly issuingBank: FieldRef<"BusinessCard", 'String'>
    readonly last4Digits: FieldRef<"BusinessCard", 'String'>
    readonly creditLimit: FieldRef<"BusinessCard", 'Decimal'>
    readonly currency: FieldRef<"BusinessCard", 'String'>
    readonly statementCycleDay: FieldRef<"BusinessCard", 'Int'>
    readonly paymentDueDays: FieldRef<"BusinessCard", 'Int'>
    readonly isActive: FieldRef<"BusinessCard", 'Boolean'>
    readonly createdAt: FieldRef<"BusinessCard", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessCard", 'DateTime'>
    readonly ledgerAccountId: FieldRef<"BusinessCard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessCard findUnique
   */
  export type BusinessCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCard to fetch.
     */
    where: BusinessCardWhereUniqueInput
  }

  /**
   * BusinessCard findUniqueOrThrow
   */
  export type BusinessCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCard to fetch.
     */
    where: BusinessCardWhereUniqueInput
  }

  /**
   * BusinessCard findFirst
   */
  export type BusinessCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCard to fetch.
     */
    where?: BusinessCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCards to fetch.
     */
    orderBy?: BusinessCardOrderByWithRelationInput | BusinessCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessCards.
     */
    cursor?: BusinessCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessCards.
     */
    distinct?: BusinessCardScalarFieldEnum | BusinessCardScalarFieldEnum[]
  }

  /**
   * BusinessCard findFirstOrThrow
   */
  export type BusinessCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCard to fetch.
     */
    where?: BusinessCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCards to fetch.
     */
    orderBy?: BusinessCardOrderByWithRelationInput | BusinessCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessCards.
     */
    cursor?: BusinessCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessCards.
     */
    distinct?: BusinessCardScalarFieldEnum | BusinessCardScalarFieldEnum[]
  }

  /**
   * BusinessCard findMany
   */
  export type BusinessCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCards to fetch.
     */
    where?: BusinessCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCards to fetch.
     */
    orderBy?: BusinessCardOrderByWithRelationInput | BusinessCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessCards.
     */
    cursor?: BusinessCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCards.
     */
    skip?: number
    distinct?: BusinessCardScalarFieldEnum | BusinessCardScalarFieldEnum[]
  }

  /**
   * BusinessCard create
   */
  export type BusinessCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessCard.
     */
    data: XOR<BusinessCardCreateInput, BusinessCardUncheckedCreateInput>
  }

  /**
   * BusinessCard createMany
   */
  export type BusinessCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessCards.
     */
    data: BusinessCardCreateManyInput | BusinessCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessCard createManyAndReturn
   */
  export type BusinessCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessCards.
     */
    data: BusinessCardCreateManyInput | BusinessCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessCard update
   */
  export type BusinessCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessCard.
     */
    data: XOR<BusinessCardUpdateInput, BusinessCardUncheckedUpdateInput>
    /**
     * Choose, which BusinessCard to update.
     */
    where: BusinessCardWhereUniqueInput
  }

  /**
   * BusinessCard updateMany
   */
  export type BusinessCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessCards.
     */
    data: XOR<BusinessCardUpdateManyMutationInput, BusinessCardUncheckedUpdateManyInput>
    /**
     * Filter which BusinessCards to update
     */
    where?: BusinessCardWhereInput
  }

  /**
   * BusinessCard upsert
   */
  export type BusinessCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessCard to update in case it exists.
     */
    where: BusinessCardWhereUniqueInput
    /**
     * In case the BusinessCard found by the `where` argument doesn't exist, create a new BusinessCard with this data.
     */
    create: XOR<BusinessCardCreateInput, BusinessCardUncheckedCreateInput>
    /**
     * In case the BusinessCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessCardUpdateInput, BusinessCardUncheckedUpdateInput>
  }

  /**
   * BusinessCard delete
   */
  export type BusinessCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
    /**
     * Filter which BusinessCard to delete.
     */
    where: BusinessCardWhereUniqueInput
  }

  /**
   * BusinessCard deleteMany
   */
  export type BusinessCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessCards to delete
     */
    where?: BusinessCardWhereInput
  }

  /**
   * BusinessCard.ledgerTransactions
   */
  export type BusinessCard$ledgerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerTransaction
     */
    select?: LedgerTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerTransactionInclude<ExtArgs> | null
    where?: LedgerTransactionWhereInput
    orderBy?: LedgerTransactionOrderByWithRelationInput | LedgerTransactionOrderByWithRelationInput[]
    cursor?: LedgerTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerTransactionScalarFieldEnum | LedgerTransactionScalarFieldEnum[]
  }

  /**
   * BusinessCard without action
   */
  export type BusinessCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCard
     */
    select?: BusinessCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessCardInclude<ExtArgs> | null
  }


  /**
   * Model Quotation
   */

  export type AggregateQuotation = {
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  export type QuotationAvgAggregateOutputType = {
    subtotal: Decimal | null
    totalGovFee: Decimal | null
    totalTax: Decimal | null
    grandTotal: Decimal | null
    invoicedAmount: Decimal | null
  }

  export type QuotationSumAggregateOutputType = {
    subtotal: Decimal | null
    totalGovFee: Decimal | null
    totalTax: Decimal | null
    grandTotal: Decimal | null
    invoicedAmount: Decimal | null
  }

  export type QuotationMinAggregateOutputType = {
    id: string | null
    quotationNo: string | null
    date: Date | null
    validUntil: Date | null
    companyId: string | null
    branchId: string | null
    partnerId: string | null
    beneficiaryName: string | null
    salespersonId: string | null
    currency: string | null
    status: $Enums.QuotationStatus | null
    subtotal: Decimal | null
    totalGovFee: Decimal | null
    totalTax: Decimal | null
    grandTotal: Decimal | null
    notes: string | null
    termsAndConditions: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
    acceptedAt: Date | null
    convertedAt: Date | null
    approvedById: string | null
    approvedAt: Date | null
    invoicedAmount: Decimal | null
    deletedAt: Date | null
  }

  export type QuotationMaxAggregateOutputType = {
    id: string | null
    quotationNo: string | null
    date: Date | null
    validUntil: Date | null
    companyId: string | null
    branchId: string | null
    partnerId: string | null
    beneficiaryName: string | null
    salespersonId: string | null
    currency: string | null
    status: $Enums.QuotationStatus | null
    subtotal: Decimal | null
    totalGovFee: Decimal | null
    totalTax: Decimal | null
    grandTotal: Decimal | null
    notes: string | null
    termsAndConditions: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
    acceptedAt: Date | null
    convertedAt: Date | null
    approvedById: string | null
    approvedAt: Date | null
    invoicedAmount: Decimal | null
    deletedAt: Date | null
  }

  export type QuotationCountAggregateOutputType = {
    id: number
    quotationNo: number
    date: number
    validUntil: number
    companyId: number
    branchId: number
    partnerId: number
    beneficiaryName: number
    salespersonId: number
    currency: number
    status: number
    subtotal: number
    totalGovFee: number
    totalTax: number
    grandTotal: number
    notes: number
    termsAndConditions: number
    createdAt: number
    updatedAt: number
    sentAt: number
    acceptedAt: number
    convertedAt: number
    approvedById: number
    approvedAt: number
    invoicedAmount: number
    deletedAt: number
    _all: number
  }


  export type QuotationAvgAggregateInputType = {
    subtotal?: true
    totalGovFee?: true
    totalTax?: true
    grandTotal?: true
    invoicedAmount?: true
  }

  export type QuotationSumAggregateInputType = {
    subtotal?: true
    totalGovFee?: true
    totalTax?: true
    grandTotal?: true
    invoicedAmount?: true
  }

  export type QuotationMinAggregateInputType = {
    id?: true
    quotationNo?: true
    date?: true
    validUntil?: true
    companyId?: true
    branchId?: true
    partnerId?: true
    beneficiaryName?: true
    salespersonId?: true
    currency?: true
    status?: true
    subtotal?: true
    totalGovFee?: true
    totalTax?: true
    grandTotal?: true
    notes?: true
    termsAndConditions?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    acceptedAt?: true
    convertedAt?: true
    approvedById?: true
    approvedAt?: true
    invoicedAmount?: true
    deletedAt?: true
  }

  export type QuotationMaxAggregateInputType = {
    id?: true
    quotationNo?: true
    date?: true
    validUntil?: true
    companyId?: true
    branchId?: true
    partnerId?: true
    beneficiaryName?: true
    salespersonId?: true
    currency?: true
    status?: true
    subtotal?: true
    totalGovFee?: true
    totalTax?: true
    grandTotal?: true
    notes?: true
    termsAndConditions?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    acceptedAt?: true
    convertedAt?: true
    approvedById?: true
    approvedAt?: true
    invoicedAmount?: true
    deletedAt?: true
  }

  export type QuotationCountAggregateInputType = {
    id?: true
    quotationNo?: true
    date?: true
    validUntil?: true
    companyId?: true
    branchId?: true
    partnerId?: true
    beneficiaryName?: true
    salespersonId?: true
    currency?: true
    status?: true
    subtotal?: true
    totalGovFee?: true
    totalTax?: true
    grandTotal?: true
    notes?: true
    termsAndConditions?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    acceptedAt?: true
    convertedAt?: true
    approvedById?: true
    approvedAt?: true
    invoicedAmount?: true
    deletedAt?: true
    _all?: true
  }

  export type QuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotation to aggregate.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotations
    **/
    _count?: true | QuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationMaxAggregateInputType
  }

  export type GetQuotationAggregateType<T extends QuotationAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotation[P]>
      : GetScalarType<T[P], AggregateQuotation[P]>
  }




  export type QuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithAggregationInput | QuotationOrderByWithAggregationInput[]
    by: QuotationScalarFieldEnum[] | QuotationScalarFieldEnum
    having?: QuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationCountAggregateInputType | true
    _avg?: QuotationAvgAggregateInputType
    _sum?: QuotationSumAggregateInputType
    _min?: QuotationMinAggregateInputType
    _max?: QuotationMaxAggregateInputType
  }

  export type QuotationGroupByOutputType = {
    id: string
    quotationNo: string
    date: Date
    validUntil: Date
    companyId: string
    branchId: string | null
    partnerId: string | null
    beneficiaryName: string | null
    salespersonId: string
    currency: string
    status: $Enums.QuotationStatus
    subtotal: Decimal
    totalGovFee: Decimal
    totalTax: Decimal
    grandTotal: Decimal
    notes: string | null
    termsAndConditions: string | null
    createdAt: Date
    updatedAt: Date
    sentAt: Date | null
    acceptedAt: Date | null
    convertedAt: Date | null
    approvedById: string | null
    approvedAt: Date | null
    invoicedAmount: Decimal
    deletedAt: Date | null
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  type GetQuotationGroupByPayload<T extends QuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationGroupByOutputType[P]>
        }
      >
    >


  export type QuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationNo?: boolean
    date?: boolean
    validUntil?: boolean
    companyId?: boolean
    branchId?: boolean
    partnerId?: boolean
    beneficiaryName?: boolean
    salespersonId?: boolean
    currency?: boolean
    status?: boolean
    subtotal?: boolean
    totalGovFee?: boolean
    totalTax?: boolean
    grandTotal?: boolean
    notes?: boolean
    termsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    acceptedAt?: boolean
    convertedAt?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    invoicedAmount?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    branch?: boolean | Quotation$branchArgs<ExtArgs>
    partner?: boolean | Quotation$partnerArgs<ExtArgs>
    salesperson?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Quotation$itemsArgs<ExtArgs>
    invoices?: boolean | Quotation$invoicesArgs<ExtArgs>
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
    _count?: boolean | QuotationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationNo?: boolean
    date?: boolean
    validUntil?: boolean
    companyId?: boolean
    branchId?: boolean
    partnerId?: boolean
    beneficiaryName?: boolean
    salespersonId?: boolean
    currency?: boolean
    status?: boolean
    subtotal?: boolean
    totalGovFee?: boolean
    totalTax?: boolean
    grandTotal?: boolean
    notes?: boolean
    termsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    acceptedAt?: boolean
    convertedAt?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    invoicedAmount?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    branch?: boolean | Quotation$branchArgs<ExtArgs>
    partner?: boolean | Quotation$partnerArgs<ExtArgs>
    salesperson?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectScalar = {
    id?: boolean
    quotationNo?: boolean
    date?: boolean
    validUntil?: boolean
    companyId?: boolean
    branchId?: boolean
    partnerId?: boolean
    beneficiaryName?: boolean
    salespersonId?: boolean
    currency?: boolean
    status?: boolean
    subtotal?: boolean
    totalGovFee?: boolean
    totalTax?: boolean
    grandTotal?: boolean
    notes?: boolean
    termsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    acceptedAt?: boolean
    convertedAt?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    invoicedAmount?: boolean
    deletedAt?: boolean
  }

  export type QuotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    branch?: boolean | Quotation$branchArgs<ExtArgs>
    partner?: boolean | Quotation$partnerArgs<ExtArgs>
    salesperson?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Quotation$itemsArgs<ExtArgs>
    invoices?: boolean | Quotation$invoicesArgs<ExtArgs>
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
    _count?: boolean | QuotationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    branch?: boolean | Quotation$branchArgs<ExtArgs>
    partner?: boolean | Quotation$partnerArgs<ExtArgs>
    salesperson?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
  }

  export type $QuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quotation"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      salesperson: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$QuotationItemPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quotationNo: string
      date: Date
      validUntil: Date
      companyId: string
      branchId: string | null
      partnerId: string | null
      beneficiaryName: string | null
      salespersonId: string
      currency: string
      status: $Enums.QuotationStatus
      subtotal: Prisma.Decimal
      totalGovFee: Prisma.Decimal
      totalTax: Prisma.Decimal
      grandTotal: Prisma.Decimal
      notes: string | null
      termsAndConditions: string | null
      createdAt: Date
      updatedAt: Date
      sentAt: Date | null
      acceptedAt: Date | null
      convertedAt: Date | null
      approvedById: string | null
      approvedAt: Date | null
      invoicedAmount: Prisma.Decimal
      deletedAt: Date | null
    }, ExtArgs["result"]["quotation"]>
    composites: {}
  }

  type QuotationGetPayload<S extends boolean | null | undefined | QuotationDefaultArgs> = $Result.GetResult<Prisma.$QuotationPayload, S>

  type QuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuotationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuotationCountAggregateInputType | true
    }

  export interface QuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quotation'], meta: { name: 'Quotation' } }
    /**
     * Find zero or one Quotation that matches the filter.
     * @param {QuotationFindUniqueArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationFindUniqueArgs>(args: SelectSubset<T, QuotationFindUniqueArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quotation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuotationFindUniqueOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationFindFirstArgs>(args?: SelectSubset<T, QuotationFindFirstArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotations
     * const quotations = await prisma.quotation.findMany()
     * 
     * // Get first 10 Quotations
     * const quotations = await prisma.quotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationWithIdOnly = await prisma.quotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationFindManyArgs>(args?: SelectSubset<T, QuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quotation.
     * @param {QuotationCreateArgs} args - Arguments to create a Quotation.
     * @example
     * // Create one Quotation
     * const Quotation = await prisma.quotation.create({
     *   data: {
     *     // ... data to create a Quotation
     *   }
     * })
     * 
     */
    create<T extends QuotationCreateArgs>(args: SelectSubset<T, QuotationCreateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quotations.
     * @param {QuotationCreateManyArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationCreateManyArgs>(args?: SelectSubset<T, QuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotations and returns the data saved in the database.
     * @param {QuotationCreateManyAndReturnArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quotation.
     * @param {QuotationDeleteArgs} args - Arguments to delete one Quotation.
     * @example
     * // Delete one Quotation
     * const Quotation = await prisma.quotation.delete({
     *   where: {
     *     // ... filter to delete one Quotation
     *   }
     * })
     * 
     */
    delete<T extends QuotationDeleteArgs>(args: SelectSubset<T, QuotationDeleteArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quotation.
     * @param {QuotationUpdateArgs} args - Arguments to update one Quotation.
     * @example
     * // Update one Quotation
     * const quotation = await prisma.quotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationUpdateArgs>(args: SelectSubset<T, QuotationUpdateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quotations.
     * @param {QuotationDeleteManyArgs} args - Arguments to filter Quotations to delete.
     * @example
     * // Delete a few Quotations
     * const { count } = await prisma.quotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationDeleteManyArgs>(args?: SelectSubset<T, QuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationUpdateManyArgs>(args: SelectSubset<T, QuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quotation.
     * @param {QuotationUpsertArgs} args - Arguments to update or create a Quotation.
     * @example
     * // Update or create a Quotation
     * const quotation = await prisma.quotation.upsert({
     *   create: {
     *     // ... data to create a Quotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation we want to update
     *   }
     * })
     */
    upsert<T extends QuotationUpsertArgs>(args: SelectSubset<T, QuotationUpsertArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationCountArgs} args - Arguments to filter Quotations to count.
     * @example
     * // Count the number of Quotations
     * const count = await prisma.quotation.count({
     *   where: {
     *     // ... the filter for the Quotations we want to count
     *   }
     * })
    **/
    count<T extends QuotationCountArgs>(
      args?: Subset<T, QuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationAggregateArgs>(args: Subset<T, QuotationAggregateArgs>): Prisma.PrismaPromise<GetQuotationAggregateType<T>>

    /**
     * Group by Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationGroupByArgs['orderBy'] }
        : { orderBy?: QuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quotation model
   */
  readonly fields: QuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends Quotation$branchArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    partner<T extends Quotation$partnerArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    salesperson<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Quotation$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Quotation$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    approvedBy<T extends Quotation$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quotation model
   */ 
  interface QuotationFieldRefs {
    readonly id: FieldRef<"Quotation", 'String'>
    readonly quotationNo: FieldRef<"Quotation", 'String'>
    readonly date: FieldRef<"Quotation", 'DateTime'>
    readonly validUntil: FieldRef<"Quotation", 'DateTime'>
    readonly companyId: FieldRef<"Quotation", 'String'>
    readonly branchId: FieldRef<"Quotation", 'String'>
    readonly partnerId: FieldRef<"Quotation", 'String'>
    readonly beneficiaryName: FieldRef<"Quotation", 'String'>
    readonly salespersonId: FieldRef<"Quotation", 'String'>
    readonly currency: FieldRef<"Quotation", 'String'>
    readonly status: FieldRef<"Quotation", 'QuotationStatus'>
    readonly subtotal: FieldRef<"Quotation", 'Decimal'>
    readonly totalGovFee: FieldRef<"Quotation", 'Decimal'>
    readonly totalTax: FieldRef<"Quotation", 'Decimal'>
    readonly grandTotal: FieldRef<"Quotation", 'Decimal'>
    readonly notes: FieldRef<"Quotation", 'String'>
    readonly termsAndConditions: FieldRef<"Quotation", 'String'>
    readonly createdAt: FieldRef<"Quotation", 'DateTime'>
    readonly updatedAt: FieldRef<"Quotation", 'DateTime'>
    readonly sentAt: FieldRef<"Quotation", 'DateTime'>
    readonly acceptedAt: FieldRef<"Quotation", 'DateTime'>
    readonly convertedAt: FieldRef<"Quotation", 'DateTime'>
    readonly approvedById: FieldRef<"Quotation", 'String'>
    readonly approvedAt: FieldRef<"Quotation", 'DateTime'>
    readonly invoicedAmount: FieldRef<"Quotation", 'Decimal'>
    readonly deletedAt: FieldRef<"Quotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quotation findUnique
   */
  export type QuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findUniqueOrThrow
   */
  export type QuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findFirst
   */
  export type QuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findFirstOrThrow
   */
  export type QuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findMany
   */
  export type QuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotations to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation create
   */
  export type QuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to create a Quotation.
     */
    data: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
  }

  /**
   * Quotation createMany
   */
  export type QuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quotation createManyAndReturn
   */
  export type QuotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation update
   */
  export type QuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to update a Quotation.
     */
    data: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
    /**
     * Choose, which Quotation to update.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation updateMany
   */
  export type QuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
  }

  /**
   * Quotation upsert
   */
  export type QuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The filter to search for the Quotation to update in case it exists.
     */
    where: QuotationWhereUniqueInput
    /**
     * In case the Quotation found by the `where` argument doesn't exist, create a new Quotation with this data.
     */
    create: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
    /**
     * In case the Quotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
  }

  /**
   * Quotation delete
   */
  export type QuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter which Quotation to delete.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation deleteMany
   */
  export type QuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotations to delete
     */
    where?: QuotationWhereInput
  }

  /**
   * Quotation.branch
   */
  export type Quotation$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Quotation.partner
   */
  export type Quotation$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * Quotation.items
   */
  export type Quotation$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    cursor?: QuotationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * Quotation.invoices
   */
  export type Quotation$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Quotation.approvedBy
   */
  export type Quotation$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Quotation without action
   */
  export type QuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
  }


  /**
   * Model QuotationItem
   */

  export type AggregateQuotationItem = {
    _count: QuotationItemCountAggregateOutputType | null
    _avg: QuotationItemAvgAggregateOutputType | null
    _sum: QuotationItemSumAggregateOutputType | null
    _min: QuotationItemMinAggregateOutputType | null
    _max: QuotationItemMaxAggregateOutputType | null
  }

  export type QuotationItemAvgAggregateOutputType = {
    govFee: Decimal | null
    typingCharge: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    quantity: number | null
  }

  export type QuotationItemSumAggregateOutputType = {
    govFee: Decimal | null
    typingCharge: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    quantity: number | null
  }

  export type QuotationItemMinAggregateOutputType = {
    id: string | null
    quotationId: string | null
    workTypeId: string | null
    description: string | null
    govFee: Decimal | null
    typingCharge: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    isVatApplicable: boolean | null
    quantity: number | null
  }

  export type QuotationItemMaxAggregateOutputType = {
    id: string | null
    quotationId: string | null
    workTypeId: string | null
    description: string | null
    govFee: Decimal | null
    typingCharge: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    isVatApplicable: boolean | null
    quantity: number | null
  }

  export type QuotationItemCountAggregateOutputType = {
    id: number
    quotationId: number
    workTypeId: number
    description: number
    govFee: number
    typingCharge: number
    taxRate: number
    taxAmount: number
    total: number
    isVatApplicable: number
    quantity: number
    _all: number
  }


  export type QuotationItemAvgAggregateInputType = {
    govFee?: true
    typingCharge?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    quantity?: true
  }

  export type QuotationItemSumAggregateInputType = {
    govFee?: true
    typingCharge?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    quantity?: true
  }

  export type QuotationItemMinAggregateInputType = {
    id?: true
    quotationId?: true
    workTypeId?: true
    description?: true
    govFee?: true
    typingCharge?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    isVatApplicable?: true
    quantity?: true
  }

  export type QuotationItemMaxAggregateInputType = {
    id?: true
    quotationId?: true
    workTypeId?: true
    description?: true
    govFee?: true
    typingCharge?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    isVatApplicable?: true
    quantity?: true
  }

  export type QuotationItemCountAggregateInputType = {
    id?: true
    quotationId?: true
    workTypeId?: true
    description?: true
    govFee?: true
    typingCharge?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    isVatApplicable?: true
    quantity?: true
    _all?: true
  }

  export type QuotationItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationItem to aggregate.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotationItems
    **/
    _count?: true | QuotationItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationItemMaxAggregateInputType
  }

  export type GetQuotationItemAggregateType<T extends QuotationItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotationItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotationItem[P]>
      : GetScalarType<T[P], AggregateQuotationItem[P]>
  }




  export type QuotationItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithAggregationInput | QuotationItemOrderByWithAggregationInput[]
    by: QuotationItemScalarFieldEnum[] | QuotationItemScalarFieldEnum
    having?: QuotationItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationItemCountAggregateInputType | true
    _avg?: QuotationItemAvgAggregateInputType
    _sum?: QuotationItemSumAggregateInputType
    _min?: QuotationItemMinAggregateInputType
    _max?: QuotationItemMaxAggregateInputType
  }

  export type QuotationItemGroupByOutputType = {
    id: string
    quotationId: string
    workTypeId: string | null
    description: string
    govFee: Decimal
    typingCharge: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    total: Decimal
    isVatApplicable: boolean
    quantity: number
    _count: QuotationItemCountAggregateOutputType | null
    _avg: QuotationItemAvgAggregateOutputType | null
    _sum: QuotationItemSumAggregateOutputType | null
    _min: QuotationItemMinAggregateOutputType | null
    _max: QuotationItemMaxAggregateOutputType | null
  }

  type GetQuotationItemGroupByPayload<T extends QuotationItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationItemGroupByOutputType[P]>
        }
      >
    >


  export type QuotationItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    workTypeId?: boolean
    description?: boolean
    govFee?: boolean
    typingCharge?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    isVatApplicable?: boolean
    quantity?: boolean
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    workType?: boolean | QuotationItem$workTypeArgs<ExtArgs>
  }, ExtArgs["result"]["quotationItem"]>

  export type QuotationItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    workTypeId?: boolean
    description?: boolean
    govFee?: boolean
    typingCharge?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    isVatApplicable?: boolean
    quantity?: boolean
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    workType?: boolean | QuotationItem$workTypeArgs<ExtArgs>
  }, ExtArgs["result"]["quotationItem"]>

  export type QuotationItemSelectScalar = {
    id?: boolean
    quotationId?: boolean
    workTypeId?: boolean
    description?: boolean
    govFee?: boolean
    typingCharge?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    isVatApplicable?: boolean
    quantity?: boolean
  }

  export type QuotationItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    workType?: boolean | QuotationItem$workTypeArgs<ExtArgs>
  }
  export type QuotationItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    workType?: boolean | QuotationItem$workTypeArgs<ExtArgs>
  }

  export type $QuotationItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotationItem"
    objects: {
      quotation: Prisma.$QuotationPayload<ExtArgs>
      workType: Prisma.$WorkTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quotationId: string
      workTypeId: string | null
      description: string
      govFee: Prisma.Decimal
      typingCharge: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
      isVatApplicable: boolean
      quantity: number
    }, ExtArgs["result"]["quotationItem"]>
    composites: {}
  }

  type QuotationItemGetPayload<S extends boolean | null | undefined | QuotationItemDefaultArgs> = $Result.GetResult<Prisma.$QuotationItemPayload, S>

  type QuotationItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuotationItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuotationItemCountAggregateInputType | true
    }

  export interface QuotationItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotationItem'], meta: { name: 'QuotationItem' } }
    /**
     * Find zero or one QuotationItem that matches the filter.
     * @param {QuotationItemFindUniqueArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationItemFindUniqueArgs>(args: SelectSubset<T, QuotationItemFindUniqueArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuotationItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuotationItemFindUniqueOrThrowArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuotationItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindFirstArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationItemFindFirstArgs>(args?: SelectSubset<T, QuotationItemFindFirstArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuotationItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindFirstOrThrowArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuotationItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotationItems
     * const quotationItems = await prisma.quotationItem.findMany()
     * 
     * // Get first 10 QuotationItems
     * const quotationItems = await prisma.quotationItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationItemWithIdOnly = await prisma.quotationItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationItemFindManyArgs>(args?: SelectSubset<T, QuotationItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuotationItem.
     * @param {QuotationItemCreateArgs} args - Arguments to create a QuotationItem.
     * @example
     * // Create one QuotationItem
     * const QuotationItem = await prisma.quotationItem.create({
     *   data: {
     *     // ... data to create a QuotationItem
     *   }
     * })
     * 
     */
    create<T extends QuotationItemCreateArgs>(args: SelectSubset<T, QuotationItemCreateArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuotationItems.
     * @param {QuotationItemCreateManyArgs} args - Arguments to create many QuotationItems.
     * @example
     * // Create many QuotationItems
     * const quotationItem = await prisma.quotationItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationItemCreateManyArgs>(args?: SelectSubset<T, QuotationItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotationItems and returns the data saved in the database.
     * @param {QuotationItemCreateManyAndReturnArgs} args - Arguments to create many QuotationItems.
     * @example
     * // Create many QuotationItems
     * const quotationItem = await prisma.quotationItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotationItems and only return the `id`
     * const quotationItemWithIdOnly = await prisma.quotationItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuotationItem.
     * @param {QuotationItemDeleteArgs} args - Arguments to delete one QuotationItem.
     * @example
     * // Delete one QuotationItem
     * const QuotationItem = await prisma.quotationItem.delete({
     *   where: {
     *     // ... filter to delete one QuotationItem
     *   }
     * })
     * 
     */
    delete<T extends QuotationItemDeleteArgs>(args: SelectSubset<T, QuotationItemDeleteArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuotationItem.
     * @param {QuotationItemUpdateArgs} args - Arguments to update one QuotationItem.
     * @example
     * // Update one QuotationItem
     * const quotationItem = await prisma.quotationItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationItemUpdateArgs>(args: SelectSubset<T, QuotationItemUpdateArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuotationItems.
     * @param {QuotationItemDeleteManyArgs} args - Arguments to filter QuotationItems to delete.
     * @example
     * // Delete a few QuotationItems
     * const { count } = await prisma.quotationItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationItemDeleteManyArgs>(args?: SelectSubset<T, QuotationItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotationItems
     * const quotationItem = await prisma.quotationItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationItemUpdateManyArgs>(args: SelectSubset<T, QuotationItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuotationItem.
     * @param {QuotationItemUpsertArgs} args - Arguments to update or create a QuotationItem.
     * @example
     * // Update or create a QuotationItem
     * const quotationItem = await prisma.quotationItem.upsert({
     *   create: {
     *     // ... data to create a QuotationItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotationItem we want to update
     *   }
     * })
     */
    upsert<T extends QuotationItemUpsertArgs>(args: SelectSubset<T, QuotationItemUpsertArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuotationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemCountArgs} args - Arguments to filter QuotationItems to count.
     * @example
     * // Count the number of QuotationItems
     * const count = await prisma.quotationItem.count({
     *   where: {
     *     // ... the filter for the QuotationItems we want to count
     *   }
     * })
    **/
    count<T extends QuotationItemCountArgs>(
      args?: Subset<T, QuotationItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationItemAggregateArgs>(args: Subset<T, QuotationItemAggregateArgs>): Prisma.PrismaPromise<GetQuotationItemAggregateType<T>>

    /**
     * Group by QuotationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationItemGroupByArgs['orderBy'] }
        : { orderBy?: QuotationItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotationItem model
   */
  readonly fields: QuotationItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotationItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quotation<T extends QuotationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationDefaultArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workType<T extends QuotationItem$workTypeArgs<ExtArgs> = {}>(args?: Subset<T, QuotationItem$workTypeArgs<ExtArgs>>): Prisma__WorkTypeClient<$Result.GetResult<Prisma.$WorkTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotationItem model
   */ 
  interface QuotationItemFieldRefs {
    readonly id: FieldRef<"QuotationItem", 'String'>
    readonly quotationId: FieldRef<"QuotationItem", 'String'>
    readonly workTypeId: FieldRef<"QuotationItem", 'String'>
    readonly description: FieldRef<"QuotationItem", 'String'>
    readonly govFee: FieldRef<"QuotationItem", 'Decimal'>
    readonly typingCharge: FieldRef<"QuotationItem", 'Decimal'>
    readonly taxRate: FieldRef<"QuotationItem", 'Decimal'>
    readonly taxAmount: FieldRef<"QuotationItem", 'Decimal'>
    readonly total: FieldRef<"QuotationItem", 'Decimal'>
    readonly isVatApplicable: FieldRef<"QuotationItem", 'Boolean'>
    readonly quantity: FieldRef<"QuotationItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuotationItem findUnique
   */
  export type QuotationItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem findUniqueOrThrow
   */
  export type QuotationItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem findFirst
   */
  export type QuotationItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationItems.
     */
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem findFirstOrThrow
   */
  export type QuotationItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationItems.
     */
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem findMany
   */
  export type QuotationItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItems to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem create
   */
  export type QuotationItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotationItem.
     */
    data: XOR<QuotationItemCreateInput, QuotationItemUncheckedCreateInput>
  }

  /**
   * QuotationItem createMany
   */
  export type QuotationItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotationItems.
     */
    data: QuotationItemCreateManyInput | QuotationItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuotationItem createManyAndReturn
   */
  export type QuotationItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuotationItems.
     */
    data: QuotationItemCreateManyInput | QuotationItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationItem update
   */
  export type QuotationItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotationItem.
     */
    data: XOR<QuotationItemUpdateInput, QuotationItemUncheckedUpdateInput>
    /**
     * Choose, which QuotationItem to update.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem updateMany
   */
  export type QuotationItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotationItems.
     */
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyInput>
    /**
     * Filter which QuotationItems to update
     */
    where?: QuotationItemWhereInput
  }

  /**
   * QuotationItem upsert
   */
  export type QuotationItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotationItem to update in case it exists.
     */
    where: QuotationItemWhereUniqueInput
    /**
     * In case the QuotationItem found by the `where` argument doesn't exist, create a new QuotationItem with this data.
     */
    create: XOR<QuotationItemCreateInput, QuotationItemUncheckedCreateInput>
    /**
     * In case the QuotationItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationItemUpdateInput, QuotationItemUncheckedUpdateInput>
  }

  /**
   * QuotationItem delete
   */
  export type QuotationItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter which QuotationItem to delete.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem deleteMany
   */
  export type QuotationItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationItems to delete
     */
    where?: QuotationItemWhereInput
  }

  /**
   * QuotationItem.workType
   */
  export type QuotationItem$workTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkType
     */
    select?: WorkTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkTypeInclude<ExtArgs> | null
    where?: WorkTypeWhereInput
  }

  /**
   * QuotationItem without action
   */
  export type QuotationItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    email: 'email',
    phone: 'phone',
    address: 'address',
    trn: 'trn',
    isActive: 'isActive',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accountingMethod: 'accountingMethod',
    accountingModel: 'accountingModel',
    allowBackDated: 'allowBackDated',
    auditRetentionDays: 'auditRetentionDays',
    baseCurrency: 'baseCurrency',
    decimalPrecision: 'decimalPrecision',
    emirate: 'emirate',
    establishmentCard: 'establishmentCard',
    fiscalYearStart: 'fiscalYearStart',
    invoiceFooter: 'invoiceFooter',
    invoiceHeader: 'invoiceHeader',
    legalType: 'legalType',
    logo: 'logo',
    nameAr: 'nameAr',
    stampImage: 'stampImage',
    startDate: 'startDate',
    tradeLicense: 'tradeLicense',
    vatFilingStart: 'vatFilingStart',
    vatRate: 'vatRate',
    vatRegistered: 'vatRegistered',
    vatRegistrationDate: 'vatRegistrationDate',
    vatReturnFreq: 'vatReturnFreq',
    website: 'website'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const DailyClosingScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    branchId: 'branchId',
    date: 'date',
    status: 'status',
    openingCash: 'openingCash',
    cashIn: 'cashIn',
    cashOut: 'cashOut',
    closingCash: 'closingCash',
    bankIn: 'bankIn',
    posIn: 'posIn',
    totalSales: 'totalSales',
    totalVat: 'totalVat',
    totalGovFee: 'totalGovFee',
    closedById: 'closedById',
    closedAt: 'closedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyClosingScalarFieldEnum = (typeof DailyClosingScalarFieldEnum)[keyof typeof DailyClosingScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    code: 'code',
    location: 'location',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    address: 'address',
    allowCrossBranch: 'allowCrossBranch',
    cashCounterEnabled: 'cashCounterEnabled',
    email: 'email',
    emirate: 'emirate',
    googleMapLink: 'googleMapLink',
    invoicePrefix: 'invoicePrefix',
    managerId: 'managerId',
    nextInvoiceNumber: 'nextInvoiceNumber',
    openingCashBalance: 'openingCashBalance',
    receiptPrefix: 'receiptPrefix',
    separateNumbering: 'separateNumbering',
    type: 'type'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    module: 'module',
    action: 'action',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    createdAt: 'createdAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    companyId: 'companyId',
    branchId: 'branchId',
    role: 'role',
    isActive: 'isActive',
    forcePasswordChange: 'forcePasswordChange',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    lastLoginUserAgent: 'lastLoginUserAgent',
    passwordChangedAt: 'passwordChangedAt',
    failedLoginAttempts: 'failedLoginAttempts',
    failedLoginResetAt: 'failedLoginResetAt',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    lastActivity: 'lastActivity',
    createdAt: 'createdAt',
    isValid: 'isValid'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    action: 'action',
    module: 'module',
    recordId: 'recordId',
    recordType: 'recordType',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ApprovalRequestScalarFieldEnum: {
    id: 'id',
    requesterId: 'requesterId',
    approverId: 'approverId',
    module: 'module',
    action: 'action',
    recordId: 'recordId',
    recordType: 'recordType',
    reason: 'reason',
    status: 'status',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalRequestScalarFieldEnum = (typeof ApprovalRequestScalarFieldEnum)[keyof typeof ApprovalRequestScalarFieldEnum]


  export const FinancialPeriodScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    year: 'year',
    month: 'month',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accountingLocked: 'accountingLocked',
    accountingLockedAt: 'accountingLockedAt',
    accountingLockedById: 'accountingLockedById',
    isYearEndClosed: 'isYearEndClosed',
    lastUnlockReason: 'lastUnlockReason',
    lastUnlockedAt: 'lastUnlockedAt',
    lastUnlockedById: 'lastUnlockedById',
    periodEnd: 'periodEnd',
    periodStart: 'periodStart',
    vatLocked: 'vatLocked',
    vatLockedAt: 'vatLockedAt',
    vatLockedById: 'vatLockedById',
    yearEndClosedAt: 'yearEndClosedAt',
    yearEndClosedById: 'yearEndClosedById'
  };

  export type FinancialPeriodScalarFieldEnum = (typeof FinancialPeriodScalarFieldEnum)[keyof typeof FinancialPeriodScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    date: 'date',
    companyId: 'companyId',
    branchId: 'branchId',
    customerId: 'customerId',
    customerName: 'customerName',
    agentId: 'agentId',
    subtotal: 'subtotal',
    tax: 'tax',
    discount: 'discount',
    total: 'total',
    paidAmount: 'paidAmount',
    balance: 'balance',
    paymentMethod: 'paymentMethod',
    paymentRef: 'paymentRef',
    bankName: 'bankName',
    status: 'status',
    govtFeeAccountId: 'govtFeeAccountId',
    govtFeeRef: 'govtFeeRef',
    customerPhone: 'customerPhone',
    customerEmail: 'customerEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    quotationId: 'quotationId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    branchId: 'branchId',
    invoiceId: 'invoiceId',
    invNo: 'invNo',
    date: 'date',
    enteredById: 'enteredById',
    beneficiaryId: 'beneficiaryId',
    partnerId: 'partnerId',
    workTypeId: 'workTypeId',
    govFee: 'govFee',
    typingCharge: 'typingCharge',
    vat: 'vat',
    total: 'total',
    type: 'type',
    receiptNo: 'receiptNo',
    govtFeeAccountId: 'govtFeeAccountId',
    govtFeeRef: 'govtFeeRef',
    paymentMethod: 'paymentMethod',
    cardId: 'cardId',
    transactionId: 'transactionId',
    status: 'status',
    advanceStatus: 'advanceStatus',
    advanceAmount: 'advanceAmount',
    customerName: 'customerName',
    applicantName: 'applicantName',
    details: 'details',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isVatApplicable: 'isVatApplicable',
    vatRate: 'vatRate',
    quantity: 'quantity'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const WorkTypeScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    description: 'description',
    presetGovFee: 'presetGovFee',
    presetTypingCharge: 'presetTypingCharge',
    vatApplicable: 'vatApplicable',
    vatRate: 'vatRate'
  };

  export type WorkTypeScalarFieldEnum = (typeof WorkTypeScalarFieldEnum)[keyof typeof WorkTypeScalarFieldEnum]


  export const BeneficiaryScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    details: 'details',
    phone: 'phone',
    email: 'email',
    partnerId: 'partnerId'
  };

  export type BeneficiaryScalarFieldEnum = (typeof BeneficiaryScalarFieldEnum)[keyof typeof BeneficiaryScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    type: 'type',
    email: 'email',
    phone: 'phone'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    branchId: 'branchId',
    date: 'date',
    description: 'description',
    amount: 'amount',
    categoryId: 'categoryId',
    paymentMethod: 'paymentMethod',
    accountId: 'accountId',
    enteredById: 'enteredById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const ExpenseCategoryScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    description: 'description',
    ledgerAccountId: 'ledgerAccountId'
  };

  export type ExpenseCategoryScalarFieldEnum = (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    type: 'type',
    balance: 'balance',
    accountNumber: 'accountNumber',
    bankName: 'bankName',
    branchId: 'branchId',
    category: 'category',
    code: 'code',
    iban: 'iban',
    isPostable: 'isPostable',
    isSystem: 'isSystem',
    linkedBranchIds: 'linkedBranchIds',
    merchantId: 'merchantId',
    parentAccountId: 'parentAccountId',
    swiftCode: 'swiftCode',
    terminalId: 'terminalId'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    branchId: 'branchId',
    postingDate: 'postingDate',
    createdAt: 'createdAt',
    description: 'description',
    type: 'type',
    referenceType: 'referenceType',
    referenceId: 'referenceId',
    reversedEntryId: 'reversedEntryId'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const LedgerTransactionScalarFieldEnum: {
    id: 'id',
    journalEntryId: 'journalEntryId',
    accountId: 'accountId',
    debit: 'debit',
    credit: 'credit',
    partnerId: 'partnerId',
    companyId: 'companyId',
    branchId: 'branchId',
    cardId: 'cardId'
  };

  export type LedgerTransactionScalarFieldEnum = (typeof LedgerTransactionScalarFieldEnum)[keyof typeof LedgerTransactionScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    voucherNo: 'voucherNo',
    date: 'date',
    companyId: 'companyId',
    branchId: 'branchId',
    description: 'description',
    vendorId: 'vendorId',
    vendorName: 'vendorName',
    total: 'total',
    paidAmount: 'paidAmount',
    balance: 'balance',
    status: 'status',
    type: 'type',
    paymentMethod: 'paymentMethod',
    accountId: 'accountId',
    enteredById: 'enteredById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    billUrl: 'billUrl'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const VoucherItemScalarFieldEnum: {
    id: 'id',
    voucherId: 'voucherId',
    categoryId: 'categoryId',
    quantity: 'quantity',
    amount: 'amount',
    description: 'description',
    isVatApplicable: 'isVatApplicable',
    vatAmount: 'vatAmount',
    vatRate: 'vatRate'
  };

  export type VoucherItemScalarFieldEnum = (typeof VoucherItemScalarFieldEnum)[keyof typeof VoucherItemScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    phone: 'phone',
    email: 'email',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const VoucherPaymentScalarFieldEnum: {
    id: 'id',
    voucherId: 'voucherId',
    date: 'date',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    accountId: 'accountId',
    receiptNo: 'receiptNo',
    enteredById: 'enteredById',
    createdAt: 'createdAt',
    companyId: 'companyId'
  };

  export type VoucherPaymentScalarFieldEnum = (typeof VoucherPaymentScalarFieldEnum)[keyof typeof VoucherPaymentScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const BusinessCardScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    type: 'type',
    issuingBank: 'issuingBank',
    last4Digits: 'last4Digits',
    creditLimit: 'creditLimit',
    currency: 'currency',
    statementCycleDay: 'statementCycleDay',
    paymentDueDays: 'paymentDueDays',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ledgerAccountId: 'ledgerAccountId'
  };

  export type BusinessCardScalarFieldEnum = (typeof BusinessCardScalarFieldEnum)[keyof typeof BusinessCardScalarFieldEnum]


  export const QuotationScalarFieldEnum: {
    id: 'id',
    quotationNo: 'quotationNo',
    date: 'date',
    validUntil: 'validUntil',
    companyId: 'companyId',
    branchId: 'branchId',
    partnerId: 'partnerId',
    beneficiaryName: 'beneficiaryName',
    salespersonId: 'salespersonId',
    currency: 'currency',
    status: 'status',
    subtotal: 'subtotal',
    totalGovFee: 'totalGovFee',
    totalTax: 'totalTax',
    grandTotal: 'grandTotal',
    notes: 'notes',
    termsAndConditions: 'termsAndConditions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sentAt: 'sentAt',
    acceptedAt: 'acceptedAt',
    convertedAt: 'convertedAt',
    approvedById: 'approvedById',
    approvedAt: 'approvedAt',
    invoicedAmount: 'invoicedAmount',
    deletedAt: 'deletedAt'
  };

  export type QuotationScalarFieldEnum = (typeof QuotationScalarFieldEnum)[keyof typeof QuotationScalarFieldEnum]


  export const QuotationItemScalarFieldEnum: {
    id: 'id',
    quotationId: 'quotationId',
    workTypeId: 'workTypeId',
    description: 'description',
    govFee: 'govFee',
    typingCharge: 'typingCharge',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    total: 'total',
    isVatApplicable: 'isVatApplicable',
    quantity: 'quantity'
  };

  export type QuotationItemScalarFieldEnum = (typeof QuotationItemScalarFieldEnum)[keyof typeof QuotationItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AccountingMethod'
   */
  export type EnumAccountingMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountingMethod'>
    


  /**
   * Reference to a field of type 'AccountingMethod[]'
   */
  export type ListEnumAccountingMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountingMethod[]'>
    


  /**
   * Reference to a field of type 'AccountingModel'
   */
  export type EnumAccountingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountingModel'>
    


  /**
   * Reference to a field of type 'AccountingModel[]'
   */
  export type ListEnumAccountingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountingModel[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Emirate'
   */
  export type EnumEmirateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Emirate'>
    


  /**
   * Reference to a field of type 'Emirate[]'
   */
  export type ListEnumEmirateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Emirate[]'>
    


  /**
   * Reference to a field of type 'LegalType'
   */
  export type EnumLegalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LegalType'>
    


  /**
   * Reference to a field of type 'LegalType[]'
   */
  export type ListEnumLegalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LegalType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'VatFrequency'
   */
  export type EnumVatFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VatFrequency'>
    


  /**
   * Reference to a field of type 'VatFrequency[]'
   */
  export type ListEnumVatFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VatFrequency[]'>
    


  /**
   * Reference to a field of type 'ClosingStatus'
   */
  export type EnumClosingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClosingStatus'>
    


  /**
   * Reference to a field of type 'ClosingStatus[]'
   */
  export type ListEnumClosingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClosingStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BranchType'
   */
  export type EnumBranchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BranchType'>
    


  /**
   * Reference to a field of type 'BranchType[]'
   */
  export type ListEnumBranchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BranchType[]'>
    


  /**
   * Reference to a field of type 'UserRole_Legacy'
   */
  export type EnumUserRole_LegacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole_Legacy'>
    


  /**
   * Reference to a field of type 'UserRole_Legacy[]'
   */
  export type ListEnumUserRole_LegacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole_Legacy[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'AdvanceStatus'
   */
  export type EnumAdvanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdvanceStatus'>
    


  /**
   * Reference to a field of type 'AdvanceStatus[]'
   */
  export type ListEnumAdvanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdvanceStatus[]'>
    


  /**
   * Reference to a field of type 'PartnerType'
   */
  export type EnumPartnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerType'>
    


  /**
   * Reference to a field of type 'PartnerType[]'
   */
  export type ListEnumPartnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerType[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'AccountCategory'
   */
  export type EnumAccountCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountCategory'>
    


  /**
   * Reference to a field of type 'AccountCategory[]'
   */
  export type ListEnumAccountCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountCategory[]'>
    


  /**
   * Reference to a field of type 'JournalEntryType'
   */
  export type EnumJournalEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalEntryType'>
    


  /**
   * Reference to a field of type 'JournalEntryType[]'
   */
  export type ListEnumJournalEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalEntryType[]'>
    


  /**
   * Reference to a field of type 'VoucherStatus'
   */
  export type EnumVoucherStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherStatus'>
    


  /**
   * Reference to a field of type 'VoucherStatus[]'
   */
  export type ListEnumVoucherStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherStatus[]'>
    


  /**
   * Reference to a field of type 'VoucherType'
   */
  export type EnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType'>
    


  /**
   * Reference to a field of type 'VoucherType[]'
   */
  export type ListEnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType[]'>
    


  /**
   * Reference to a field of type 'CardType'
   */
  export type EnumCardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardType'>
    


  /**
   * Reference to a field of type 'CardType[]'
   */
  export type ListEnumCardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardType[]'>
    


  /**
   * Reference to a field of type 'QuotationStatus'
   */
  export type EnumQuotationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationStatus'>
    


  /**
   * Reference to a field of type 'QuotationStatus[]'
   */
  export type ListEnumQuotationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    code?: StringFilter<"Company"> | string
    email?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    trn?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    lockedUntil?: DateTimeNullableFilter<"Company"> | Date | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    accountingMethod?: EnumAccountingMethodFilter<"Company"> | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFilter<"Company"> | $Enums.AccountingModel
    allowBackDated?: BoolFilter<"Company"> | boolean
    auditRetentionDays?: IntFilter<"Company"> | number
    baseCurrency?: StringFilter<"Company"> | string
    decimalPrecision?: IntFilter<"Company"> | number
    emirate?: EnumEmirateFilter<"Company"> | $Enums.Emirate
    establishmentCard?: StringNullableFilter<"Company"> | string | null
    fiscalYearStart?: IntFilter<"Company"> | number
    invoiceFooter?: StringNullableFilter<"Company"> | string | null
    invoiceHeader?: StringNullableFilter<"Company"> | string | null
    legalType?: EnumLegalTypeFilter<"Company"> | $Enums.LegalType
    logo?: StringNullableFilter<"Company"> | string | null
    nameAr?: StringNullableFilter<"Company"> | string | null
    stampImage?: StringNullableFilter<"Company"> | string | null
    startDate?: DateTimeFilter<"Company"> | Date | string
    tradeLicense?: StringNullableFilter<"Company"> | string | null
    vatFilingStart?: DateTimeNullableFilter<"Company"> | Date | string | null
    vatRate?: FloatFilter<"Company"> | number
    vatRegistered?: BoolFilter<"Company"> | boolean
    vatRegistrationDate?: DateTimeNullableFilter<"Company"> | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFilter<"Company"> | $Enums.VatFrequency
    website?: StringNullableFilter<"Company"> | string | null
    accounts?: AccountListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    beneficiaries?: BeneficiaryListRelationFilter
    branches?: BranchListRelationFilter
    dailyClosings?: DailyClosingListRelationFilter
    expenses?: ExpenseListRelationFilter
    expenseCategories?: ExpenseCategoryListRelationFilter
    financialPeriods?: FinancialPeriodListRelationFilter
    invoices?: InvoiceListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    partners?: PartnerListRelationFilter
    transactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
    vendors?: VendorListRelationFilter
    vouchers?: VoucherListRelationFilter
    voucherPayments?: VoucherPaymentListRelationFilter
    workTypes?: WorkTypeListRelationFilter
    businessCards?: BusinessCardListRelationFilter
    quotations?: QuotationListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    trn?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingMethod?: SortOrder
    accountingModel?: SortOrder
    allowBackDated?: SortOrder
    auditRetentionDays?: SortOrder
    baseCurrency?: SortOrder
    decimalPrecision?: SortOrder
    emirate?: SortOrder
    establishmentCard?: SortOrderInput | SortOrder
    fiscalYearStart?: SortOrder
    invoiceFooter?: SortOrderInput | SortOrder
    invoiceHeader?: SortOrderInput | SortOrder
    legalType?: SortOrder
    logo?: SortOrderInput | SortOrder
    nameAr?: SortOrderInput | SortOrder
    stampImage?: SortOrderInput | SortOrder
    startDate?: SortOrder
    tradeLicense?: SortOrderInput | SortOrder
    vatFilingStart?: SortOrderInput | SortOrder
    vatRate?: SortOrder
    vatRegistered?: SortOrder
    vatRegistrationDate?: SortOrderInput | SortOrder
    vatReturnFreq?: SortOrder
    website?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    beneficiaries?: BeneficiaryOrderByRelationAggregateInput
    branches?: BranchOrderByRelationAggregateInput
    dailyClosings?: DailyClosingOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    expenseCategories?: ExpenseCategoryOrderByRelationAggregateInput
    financialPeriods?: FinancialPeriodOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    partners?: PartnerOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    vendors?: VendorOrderByRelationAggregateInput
    vouchers?: VoucherOrderByRelationAggregateInput
    voucherPayments?: VoucherPaymentOrderByRelationAggregateInput
    workTypes?: WorkTypeOrderByRelationAggregateInput
    businessCards?: BusinessCardOrderByRelationAggregateInput
    quotations?: QuotationOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    email?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    trn?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    lockedUntil?: DateTimeNullableFilter<"Company"> | Date | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    accountingMethod?: EnumAccountingMethodFilter<"Company"> | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFilter<"Company"> | $Enums.AccountingModel
    allowBackDated?: BoolFilter<"Company"> | boolean
    auditRetentionDays?: IntFilter<"Company"> | number
    baseCurrency?: StringFilter<"Company"> | string
    decimalPrecision?: IntFilter<"Company"> | number
    emirate?: EnumEmirateFilter<"Company"> | $Enums.Emirate
    establishmentCard?: StringNullableFilter<"Company"> | string | null
    fiscalYearStart?: IntFilter<"Company"> | number
    invoiceFooter?: StringNullableFilter<"Company"> | string | null
    invoiceHeader?: StringNullableFilter<"Company"> | string | null
    legalType?: EnumLegalTypeFilter<"Company"> | $Enums.LegalType
    logo?: StringNullableFilter<"Company"> | string | null
    nameAr?: StringNullableFilter<"Company"> | string | null
    stampImage?: StringNullableFilter<"Company"> | string | null
    startDate?: DateTimeFilter<"Company"> | Date | string
    tradeLicense?: StringNullableFilter<"Company"> | string | null
    vatFilingStart?: DateTimeNullableFilter<"Company"> | Date | string | null
    vatRate?: FloatFilter<"Company"> | number
    vatRegistered?: BoolFilter<"Company"> | boolean
    vatRegistrationDate?: DateTimeNullableFilter<"Company"> | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFilter<"Company"> | $Enums.VatFrequency
    website?: StringNullableFilter<"Company"> | string | null
    accounts?: AccountListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    beneficiaries?: BeneficiaryListRelationFilter
    branches?: BranchListRelationFilter
    dailyClosings?: DailyClosingListRelationFilter
    expenses?: ExpenseListRelationFilter
    expenseCategories?: ExpenseCategoryListRelationFilter
    financialPeriods?: FinancialPeriodListRelationFilter
    invoices?: InvoiceListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    partners?: PartnerListRelationFilter
    transactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
    vendors?: VendorListRelationFilter
    vouchers?: VoucherListRelationFilter
    voucherPayments?: VoucherPaymentListRelationFilter
    workTypes?: WorkTypeListRelationFilter
    businessCards?: BusinessCardListRelationFilter
    quotations?: QuotationListRelationFilter
  }, "id" | "name" | "code">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    trn?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingMethod?: SortOrder
    accountingModel?: SortOrder
    allowBackDated?: SortOrder
    auditRetentionDays?: SortOrder
    baseCurrency?: SortOrder
    decimalPrecision?: SortOrder
    emirate?: SortOrder
    establishmentCard?: SortOrderInput | SortOrder
    fiscalYearStart?: SortOrder
    invoiceFooter?: SortOrderInput | SortOrder
    invoiceHeader?: SortOrderInput | SortOrder
    legalType?: SortOrder
    logo?: SortOrderInput | SortOrder
    nameAr?: SortOrderInput | SortOrder
    stampImage?: SortOrderInput | SortOrder
    startDate?: SortOrder
    tradeLicense?: SortOrderInput | SortOrder
    vatFilingStart?: SortOrderInput | SortOrder
    vatRate?: SortOrder
    vatRegistered?: SortOrder
    vatRegistrationDate?: SortOrderInput | SortOrder
    vatReturnFreq?: SortOrder
    website?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    code?: StringWithAggregatesFilter<"Company"> | string
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    trn?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    accountingMethod?: EnumAccountingMethodWithAggregatesFilter<"Company"> | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelWithAggregatesFilter<"Company"> | $Enums.AccountingModel
    allowBackDated?: BoolWithAggregatesFilter<"Company"> | boolean
    auditRetentionDays?: IntWithAggregatesFilter<"Company"> | number
    baseCurrency?: StringWithAggregatesFilter<"Company"> | string
    decimalPrecision?: IntWithAggregatesFilter<"Company"> | number
    emirate?: EnumEmirateWithAggregatesFilter<"Company"> | $Enums.Emirate
    establishmentCard?: StringNullableWithAggregatesFilter<"Company"> | string | null
    fiscalYearStart?: IntWithAggregatesFilter<"Company"> | number
    invoiceFooter?: StringNullableWithAggregatesFilter<"Company"> | string | null
    invoiceHeader?: StringNullableWithAggregatesFilter<"Company"> | string | null
    legalType?: EnumLegalTypeWithAggregatesFilter<"Company"> | $Enums.LegalType
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    nameAr?: StringNullableWithAggregatesFilter<"Company"> | string | null
    stampImage?: StringNullableWithAggregatesFilter<"Company"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    tradeLicense?: StringNullableWithAggregatesFilter<"Company"> | string | null
    vatFilingStart?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    vatRate?: FloatWithAggregatesFilter<"Company"> | number
    vatRegistered?: BoolWithAggregatesFilter<"Company"> | boolean
    vatRegistrationDate?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    vatReturnFreq?: EnumVatFrequencyWithAggregatesFilter<"Company"> | $Enums.VatFrequency
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
  }

  export type DailyClosingWhereInput = {
    AND?: DailyClosingWhereInput | DailyClosingWhereInput[]
    OR?: DailyClosingWhereInput[]
    NOT?: DailyClosingWhereInput | DailyClosingWhereInput[]
    id?: StringFilter<"DailyClosing"> | string
    companyId?: StringFilter<"DailyClosing"> | string
    branchId?: StringFilter<"DailyClosing"> | string
    date?: DateTimeFilter<"DailyClosing"> | Date | string
    status?: EnumClosingStatusFilter<"DailyClosing"> | $Enums.ClosingStatus
    openingCash?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    closedById?: StringNullableFilter<"DailyClosing"> | string | null
    closedAt?: DateTimeNullableFilter<"DailyClosing"> | Date | string | null
    notes?: StringNullableFilter<"DailyClosing"> | string | null
    createdAt?: DateTimeFilter<"DailyClosing"> | Date | string
    updatedAt?: DateTimeFilter<"DailyClosing"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    closedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type DailyClosingOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    openingCash?: SortOrder
    cashIn?: SortOrder
    cashOut?: SortOrder
    closingCash?: SortOrder
    bankIn?: SortOrder
    posIn?: SortOrder
    totalSales?: SortOrder
    totalVat?: SortOrder
    totalGovFee?: SortOrder
    closedById?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    closedBy?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type DailyClosingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_branchId_date?: DailyClosingCompanyIdBranchIdDateCompoundUniqueInput
    AND?: DailyClosingWhereInput | DailyClosingWhereInput[]
    OR?: DailyClosingWhereInput[]
    NOT?: DailyClosingWhereInput | DailyClosingWhereInput[]
    companyId?: StringFilter<"DailyClosing"> | string
    branchId?: StringFilter<"DailyClosing"> | string
    date?: DateTimeFilter<"DailyClosing"> | Date | string
    status?: EnumClosingStatusFilter<"DailyClosing"> | $Enums.ClosingStatus
    openingCash?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    closedById?: StringNullableFilter<"DailyClosing"> | string | null
    closedAt?: DateTimeNullableFilter<"DailyClosing"> | Date | string | null
    notes?: StringNullableFilter<"DailyClosing"> | string | null
    createdAt?: DateTimeFilter<"DailyClosing"> | Date | string
    updatedAt?: DateTimeFilter<"DailyClosing"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    closedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_branchId_date">

  export type DailyClosingOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    openingCash?: SortOrder
    cashIn?: SortOrder
    cashOut?: SortOrder
    closingCash?: SortOrder
    bankIn?: SortOrder
    posIn?: SortOrder
    totalSales?: SortOrder
    totalVat?: SortOrder
    totalGovFee?: SortOrder
    closedById?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyClosingCountOrderByAggregateInput
    _avg?: DailyClosingAvgOrderByAggregateInput
    _max?: DailyClosingMaxOrderByAggregateInput
    _min?: DailyClosingMinOrderByAggregateInput
    _sum?: DailyClosingSumOrderByAggregateInput
  }

  export type DailyClosingScalarWhereWithAggregatesInput = {
    AND?: DailyClosingScalarWhereWithAggregatesInput | DailyClosingScalarWhereWithAggregatesInput[]
    OR?: DailyClosingScalarWhereWithAggregatesInput[]
    NOT?: DailyClosingScalarWhereWithAggregatesInput | DailyClosingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyClosing"> | string
    companyId?: StringWithAggregatesFilter<"DailyClosing"> | string
    branchId?: StringWithAggregatesFilter<"DailyClosing"> | string
    date?: DateTimeWithAggregatesFilter<"DailyClosing"> | Date | string
    status?: EnumClosingStatusWithAggregatesFilter<"DailyClosing"> | $Enums.ClosingStatus
    openingCash?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    posIn?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalWithAggregatesFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    closedById?: StringNullableWithAggregatesFilter<"DailyClosing"> | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"DailyClosing"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"DailyClosing"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyClosing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyClosing"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    companyId?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    isActive?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    address?: StringNullableFilter<"Branch"> | string | null
    allowCrossBranch?: BoolFilter<"Branch"> | boolean
    cashCounterEnabled?: BoolFilter<"Branch"> | boolean
    email?: StringNullableFilter<"Branch"> | string | null
    emirate?: EnumEmirateFilter<"Branch"> | $Enums.Emirate
    googleMapLink?: StringNullableFilter<"Branch"> | string | null
    invoicePrefix?: StringNullableFilter<"Branch"> | string | null
    managerId?: StringNullableFilter<"Branch"> | string | null
    nextInvoiceNumber?: IntFilter<"Branch"> | number
    openingCashBalance?: FloatFilter<"Branch"> | number
    receiptPrefix?: StringNullableFilter<"Branch"> | string | null
    separateNumbering?: BoolFilter<"Branch"> | boolean
    type?: EnumBranchTypeFilter<"Branch"> | $Enums.BranchType
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    dailyClosings?: DailyClosingListRelationFilter
    expenses?: ExpenseListRelationFilter
    invoices?: InvoiceListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    ledgerTransactions?: LedgerTransactionListRelationFilter
    transactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
    vouchers?: VoucherListRelationFilter
    quotations?: QuotationListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    location?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: SortOrderInput | SortOrder
    allowCrossBranch?: SortOrder
    cashCounterEnabled?: SortOrder
    email?: SortOrderInput | SortOrder
    emirate?: SortOrder
    googleMapLink?: SortOrderInput | SortOrder
    invoicePrefix?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    nextInvoiceNumber?: SortOrder
    openingCashBalance?: SortOrder
    receiptPrefix?: SortOrderInput | SortOrder
    separateNumbering?: SortOrder
    type?: SortOrder
    company?: CompanyOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    dailyClosings?: DailyClosingOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    ledgerTransactions?: LedgerTransactionOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    vouchers?: VoucherOrderByRelationAggregateInput
    quotations?: QuotationOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: BranchCompanyIdCodeCompoundUniqueInput
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    companyId?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    isActive?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    address?: StringNullableFilter<"Branch"> | string | null
    allowCrossBranch?: BoolFilter<"Branch"> | boolean
    cashCounterEnabled?: BoolFilter<"Branch"> | boolean
    email?: StringNullableFilter<"Branch"> | string | null
    emirate?: EnumEmirateFilter<"Branch"> | $Enums.Emirate
    googleMapLink?: StringNullableFilter<"Branch"> | string | null
    invoicePrefix?: StringNullableFilter<"Branch"> | string | null
    managerId?: StringNullableFilter<"Branch"> | string | null
    nextInvoiceNumber?: IntFilter<"Branch"> | number
    openingCashBalance?: FloatFilter<"Branch"> | number
    receiptPrefix?: StringNullableFilter<"Branch"> | string | null
    separateNumbering?: BoolFilter<"Branch"> | boolean
    type?: EnumBranchTypeFilter<"Branch"> | $Enums.BranchType
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    dailyClosings?: DailyClosingListRelationFilter
    expenses?: ExpenseListRelationFilter
    invoices?: InvoiceListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    ledgerTransactions?: LedgerTransactionListRelationFilter
    transactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
    vouchers?: VoucherListRelationFilter
    quotations?: QuotationListRelationFilter
  }, "id" | "companyId_code">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    location?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: SortOrderInput | SortOrder
    allowCrossBranch?: SortOrder
    cashCounterEnabled?: SortOrder
    email?: SortOrderInput | SortOrder
    emirate?: SortOrder
    googleMapLink?: SortOrderInput | SortOrder
    invoicePrefix?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    nextInvoiceNumber?: SortOrder
    openingCashBalance?: SortOrder
    receiptPrefix?: SortOrderInput | SortOrder
    separateNumbering?: SortOrder
    type?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    companyId?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    code?: StringWithAggregatesFilter<"Branch"> | string
    location?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    isActive?: BoolWithAggregatesFilter<"Branch"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    allowCrossBranch?: BoolWithAggregatesFilter<"Branch"> | boolean
    cashCounterEnabled?: BoolWithAggregatesFilter<"Branch"> | boolean
    email?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    emirate?: EnumEmirateWithAggregatesFilter<"Branch"> | $Enums.Emirate
    googleMapLink?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    invoicePrefix?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    nextInvoiceNumber?: IntWithAggregatesFilter<"Branch"> | number
    openingCashBalance?: FloatWithAggregatesFilter<"Branch"> | number
    receiptPrefix?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    separateNumbering?: BoolWithAggregatesFilter<"Branch"> | boolean
    type?: EnumBranchTypeWithAggregatesFilter<"Branch"> | $Enums.BranchType
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    code?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }, "id" | "name" | "code">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    code?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    module_action?: PermissionModuleActionCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "name" | "module_action">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    module?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    permission?: PermissionOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    companyId?: StringFilter<"User"> | string
    branchId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRole_LegacyFilter<"User"> | $Enums.UserRole_Legacy
    isActive?: BoolFilter<"User"> | boolean
    forcePasswordChange?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    lastLoginUserAgent?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    failedLoginResetAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    approvalActions?: ApprovalRequestListRelationFilter
    approvalRequests?: ApprovalRequestListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    managedBranches?: BranchListRelationFilter
    dailyClosings?: DailyClosingListRelationFilter
    expenses?: ExpenseListRelationFilter
    accountingLockedPeriods?: FinancialPeriodListRelationFilter
    unlockedPeriods?: FinancialPeriodListRelationFilter
    vatLockedPeriods?: FinancialPeriodListRelationFilter
    yearEndClosedPeriods?: FinancialPeriodListRelationFilter
    invoices?: InvoiceListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    sessions?: SessionListRelationFilter
    transactions?: TransactionListRelationFilter
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    userRoles?: UserRoleListRelationFilter
    vouchers?: VoucherListRelationFilter
    voucherPayments?: VoucherPaymentListRelationFilter
    quotations?: QuotationListRelationFilter
    approvedQuotations?: QuotationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    forcePasswordChange?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    lastLoginUserAgent?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    failedLoginResetAt?: SortOrderInput | SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvalActions?: ApprovalRequestOrderByRelationAggregateInput
    approvalRequests?: ApprovalRequestOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    managedBranches?: BranchOrderByRelationAggregateInput
    dailyClosings?: DailyClosingOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    accountingLockedPeriods?: FinancialPeriodOrderByRelationAggregateInput
    unlockedPeriods?: FinancialPeriodOrderByRelationAggregateInput
    vatLockedPeriods?: FinancialPeriodOrderByRelationAggregateInput
    yearEndClosedPeriods?: FinancialPeriodOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    branch?: BranchOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    vouchers?: VoucherOrderByRelationAggregateInput
    voucherPayments?: VoucherPaymentOrderByRelationAggregateInput
    quotations?: QuotationOrderByRelationAggregateInput
    approvedQuotations?: QuotationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    companyId?: StringFilter<"User"> | string
    branchId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRole_LegacyFilter<"User"> | $Enums.UserRole_Legacy
    isActive?: BoolFilter<"User"> | boolean
    forcePasswordChange?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    lastLoginUserAgent?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    failedLoginResetAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    approvalActions?: ApprovalRequestListRelationFilter
    approvalRequests?: ApprovalRequestListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    managedBranches?: BranchListRelationFilter
    dailyClosings?: DailyClosingListRelationFilter
    expenses?: ExpenseListRelationFilter
    accountingLockedPeriods?: FinancialPeriodListRelationFilter
    unlockedPeriods?: FinancialPeriodListRelationFilter
    vatLockedPeriods?: FinancialPeriodListRelationFilter
    yearEndClosedPeriods?: FinancialPeriodListRelationFilter
    invoices?: InvoiceListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    sessions?: SessionListRelationFilter
    transactions?: TransactionListRelationFilter
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    userRoles?: UserRoleListRelationFilter
    vouchers?: VoucherListRelationFilter
    voucherPayments?: VoucherPaymentListRelationFilter
    quotations?: QuotationListRelationFilter
    approvedQuotations?: QuotationListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    forcePasswordChange?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    lastLoginUserAgent?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    failedLoginResetAt?: SortOrderInput | SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    companyId?: StringWithAggregatesFilter<"User"> | string
    branchId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRole_LegacyWithAggregatesFilter<"User"> | $Enums.UserRole_Legacy
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    forcePasswordChange?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLoginUserAgent?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntWithAggregatesFilter<"User"> | number
    failedLoginResetAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    isValid?: BoolFilter<"Session"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    isValid?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    isValid?: BoolFilter<"Session"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    isValid?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    lastActivity?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    isValid?: BoolWithAggregatesFilter<"Session"> | boolean
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    recordId?: StringNullableFilter<"AuditLog"> | string | null
    recordType?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    module?: SortOrder
    recordId?: SortOrderInput | SortOrder
    recordType?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    companyId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    recordId?: StringNullableFilter<"AuditLog"> | string | null
    recordType?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    module?: SortOrder
    recordId?: SortOrderInput | SortOrder
    recordType?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    companyId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    module?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    recordType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ApprovalRequestWhereInput = {
    AND?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    OR?: ApprovalRequestWhereInput[]
    NOT?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    id?: StringFilter<"ApprovalRequest"> | string
    requesterId?: StringFilter<"ApprovalRequest"> | string
    approverId?: StringNullableFilter<"ApprovalRequest"> | string | null
    module?: StringFilter<"ApprovalRequest"> | string
    action?: StringFilter<"ApprovalRequest"> | string
    recordId?: StringFilter<"ApprovalRequest"> | string
    recordType?: StringFilter<"ApprovalRequest"> | string
    reason?: StringFilter<"ApprovalRequest"> | string
    status?: EnumApprovalStatusFilter<"ApprovalRequest"> | $Enums.ApprovalStatus
    approvedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    comments?: StringNullableFilter<"ApprovalRequest"> | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    requester?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ApprovalRequestOrderByWithRelationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrderInput | SortOrder
    module?: SortOrder
    action?: SortOrder
    recordId?: SortOrder
    recordType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approver?: UserOrderByWithRelationInput
    requester?: UserOrderByWithRelationInput
  }

  export type ApprovalRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    OR?: ApprovalRequestWhereInput[]
    NOT?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    requesterId?: StringFilter<"ApprovalRequest"> | string
    approverId?: StringNullableFilter<"ApprovalRequest"> | string | null
    module?: StringFilter<"ApprovalRequest"> | string
    action?: StringFilter<"ApprovalRequest"> | string
    recordId?: StringFilter<"ApprovalRequest"> | string
    recordType?: StringFilter<"ApprovalRequest"> | string
    reason?: StringFilter<"ApprovalRequest"> | string
    status?: EnumApprovalStatusFilter<"ApprovalRequest"> | $Enums.ApprovalStatus
    approvedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    comments?: StringNullableFilter<"ApprovalRequest"> | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    approver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    requester?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ApprovalRequestOrderByWithAggregationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrderInput | SortOrder
    module?: SortOrder
    action?: SortOrder
    recordId?: SortOrder
    recordType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalRequestCountOrderByAggregateInput
    _max?: ApprovalRequestMaxOrderByAggregateInput
    _min?: ApprovalRequestMinOrderByAggregateInput
  }

  export type ApprovalRequestScalarWhereWithAggregatesInput = {
    AND?: ApprovalRequestScalarWhereWithAggregatesInput | ApprovalRequestScalarWhereWithAggregatesInput[]
    OR?: ApprovalRequestScalarWhereWithAggregatesInput[]
    NOT?: ApprovalRequestScalarWhereWithAggregatesInput | ApprovalRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    requesterId?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    approverId?: StringNullableWithAggregatesFilter<"ApprovalRequest"> | string | null
    module?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    action?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    recordId?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    recordType?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    reason?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    status?: EnumApprovalStatusWithAggregatesFilter<"ApprovalRequest"> | $Enums.ApprovalStatus
    approvedAt?: DateTimeNullableWithAggregatesFilter<"ApprovalRequest"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"ApprovalRequest"> | Date | string | null
    comments?: StringNullableWithAggregatesFilter<"ApprovalRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalRequest"> | Date | string
  }

  export type FinancialPeriodWhereInput = {
    AND?: FinancialPeriodWhereInput | FinancialPeriodWhereInput[]
    OR?: FinancialPeriodWhereInput[]
    NOT?: FinancialPeriodWhereInput | FinancialPeriodWhereInput[]
    id?: StringFilter<"FinancialPeriod"> | string
    companyId?: StringFilter<"FinancialPeriod"> | string
    year?: IntFilter<"FinancialPeriod"> | number
    month?: IntFilter<"FinancialPeriod"> | number
    createdAt?: DateTimeFilter<"FinancialPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialPeriod"> | Date | string
    accountingLocked?: BoolFilter<"FinancialPeriod"> | boolean
    accountingLockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    accountingLockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    isYearEndClosed?: BoolFilter<"FinancialPeriod"> | boolean
    lastUnlockReason?: StringNullableFilter<"FinancialPeriod"> | string | null
    lastUnlockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    lastUnlockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    periodEnd?: DateTimeFilter<"FinancialPeriod"> | Date | string
    periodStart?: DateTimeFilter<"FinancialPeriod"> | Date | string
    vatLocked?: BoolFilter<"FinancialPeriod"> | boolean
    vatLockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    vatLockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    yearEndClosedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    yearEndClosedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    accountingLockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    lastUnlockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    vatLockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    yearEndClosedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type FinancialPeriodOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingLocked?: SortOrder
    accountingLockedAt?: SortOrderInput | SortOrder
    accountingLockedById?: SortOrderInput | SortOrder
    isYearEndClosed?: SortOrder
    lastUnlockReason?: SortOrderInput | SortOrder
    lastUnlockedAt?: SortOrderInput | SortOrder
    lastUnlockedById?: SortOrderInput | SortOrder
    periodEnd?: SortOrder
    periodStart?: SortOrder
    vatLocked?: SortOrder
    vatLockedAt?: SortOrderInput | SortOrder
    vatLockedById?: SortOrderInput | SortOrder
    yearEndClosedAt?: SortOrderInput | SortOrder
    yearEndClosedById?: SortOrderInput | SortOrder
    accountingLockedBy?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    lastUnlockedBy?: UserOrderByWithRelationInput
    vatLockedBy?: UserOrderByWithRelationInput
    yearEndClosedBy?: UserOrderByWithRelationInput
  }

  export type FinancialPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_year_month?: FinancialPeriodCompanyIdYearMonthCompoundUniqueInput
    AND?: FinancialPeriodWhereInput | FinancialPeriodWhereInput[]
    OR?: FinancialPeriodWhereInput[]
    NOT?: FinancialPeriodWhereInput | FinancialPeriodWhereInput[]
    companyId?: StringFilter<"FinancialPeriod"> | string
    year?: IntFilter<"FinancialPeriod"> | number
    month?: IntFilter<"FinancialPeriod"> | number
    createdAt?: DateTimeFilter<"FinancialPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialPeriod"> | Date | string
    accountingLocked?: BoolFilter<"FinancialPeriod"> | boolean
    accountingLockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    accountingLockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    isYearEndClosed?: BoolFilter<"FinancialPeriod"> | boolean
    lastUnlockReason?: StringNullableFilter<"FinancialPeriod"> | string | null
    lastUnlockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    lastUnlockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    periodEnd?: DateTimeFilter<"FinancialPeriod"> | Date | string
    periodStart?: DateTimeFilter<"FinancialPeriod"> | Date | string
    vatLocked?: BoolFilter<"FinancialPeriod"> | boolean
    vatLockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    vatLockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    yearEndClosedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    yearEndClosedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    accountingLockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    lastUnlockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    vatLockedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    yearEndClosedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "companyId_year_month">

  export type FinancialPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingLocked?: SortOrder
    accountingLockedAt?: SortOrderInput | SortOrder
    accountingLockedById?: SortOrderInput | SortOrder
    isYearEndClosed?: SortOrder
    lastUnlockReason?: SortOrderInput | SortOrder
    lastUnlockedAt?: SortOrderInput | SortOrder
    lastUnlockedById?: SortOrderInput | SortOrder
    periodEnd?: SortOrder
    periodStart?: SortOrder
    vatLocked?: SortOrder
    vatLockedAt?: SortOrderInput | SortOrder
    vatLockedById?: SortOrderInput | SortOrder
    yearEndClosedAt?: SortOrderInput | SortOrder
    yearEndClosedById?: SortOrderInput | SortOrder
    _count?: FinancialPeriodCountOrderByAggregateInput
    _avg?: FinancialPeriodAvgOrderByAggregateInput
    _max?: FinancialPeriodMaxOrderByAggregateInput
    _min?: FinancialPeriodMinOrderByAggregateInput
    _sum?: FinancialPeriodSumOrderByAggregateInput
  }

  export type FinancialPeriodScalarWhereWithAggregatesInput = {
    AND?: FinancialPeriodScalarWhereWithAggregatesInput | FinancialPeriodScalarWhereWithAggregatesInput[]
    OR?: FinancialPeriodScalarWhereWithAggregatesInput[]
    NOT?: FinancialPeriodScalarWhereWithAggregatesInput | FinancialPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialPeriod"> | string
    companyId?: StringWithAggregatesFilter<"FinancialPeriod"> | string
    year?: IntWithAggregatesFilter<"FinancialPeriod"> | number
    month?: IntWithAggregatesFilter<"FinancialPeriod"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FinancialPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinancialPeriod"> | Date | string
    accountingLocked?: BoolWithAggregatesFilter<"FinancialPeriod"> | boolean
    accountingLockedAt?: DateTimeNullableWithAggregatesFilter<"FinancialPeriod"> | Date | string | null
    accountingLockedById?: StringNullableWithAggregatesFilter<"FinancialPeriod"> | string | null
    isYearEndClosed?: BoolWithAggregatesFilter<"FinancialPeriod"> | boolean
    lastUnlockReason?: StringNullableWithAggregatesFilter<"FinancialPeriod"> | string | null
    lastUnlockedAt?: DateTimeNullableWithAggregatesFilter<"FinancialPeriod"> | Date | string | null
    lastUnlockedById?: StringNullableWithAggregatesFilter<"FinancialPeriod"> | string | null
    periodEnd?: DateTimeWithAggregatesFilter<"FinancialPeriod"> | Date | string
    periodStart?: DateTimeWithAggregatesFilter<"FinancialPeriod"> | Date | string
    vatLocked?: BoolWithAggregatesFilter<"FinancialPeriod"> | boolean
    vatLockedAt?: DateTimeNullableWithAggregatesFilter<"FinancialPeriod"> | Date | string | null
    vatLockedById?: StringNullableWithAggregatesFilter<"FinancialPeriod"> | string | null
    yearEndClosedAt?: DateTimeNullableWithAggregatesFilter<"FinancialPeriod"> | Date | string | null
    yearEndClosedById?: StringNullableWithAggregatesFilter<"FinancialPeriod"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNo?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: StringFilter<"Invoice"> | string
    branchId?: StringNullableFilter<"Invoice"> | string | null
    customerId?: StringNullableFilter<"Invoice"> | string | null
    customerName?: StringNullableFilter<"Invoice"> | string | null
    agentId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Invoice"> | $Enums.PaymentMethod
    paymentRef?: StringNullableFilter<"Invoice"> | string | null
    bankName?: StringNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    govtFeeAccountId?: StringNullableFilter<"Invoice"> | string | null
    govtFeeRef?: StringNullableFilter<"Invoice"> | string | null
    customerPhone?: StringNullableFilter<"Invoice"> | string | null
    customerEmail?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    quotationId?: StringNullableFilter<"Invoice"> | string | null
    agent?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    govtFeeAccount?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    transactions?: TransactionListRelationFilter
    quotation?: XOR<QuotationNullableRelationFilter, QuotationWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    paymentMethod?: SortOrder
    paymentRef?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    status?: SortOrder
    govtFeeAccountId?: SortOrderInput | SortOrder
    govtFeeRef?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrderInput | SortOrder
    agent?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    govtFeeAccount?: AccountOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    quotation?: QuotationOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNo?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    date?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: StringFilter<"Invoice"> | string
    branchId?: StringNullableFilter<"Invoice"> | string | null
    customerId?: StringNullableFilter<"Invoice"> | string | null
    customerName?: StringNullableFilter<"Invoice"> | string | null
    agentId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Invoice"> | $Enums.PaymentMethod
    paymentRef?: StringNullableFilter<"Invoice"> | string | null
    bankName?: StringNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    govtFeeAccountId?: StringNullableFilter<"Invoice"> | string | null
    govtFeeRef?: StringNullableFilter<"Invoice"> | string | null
    customerPhone?: StringNullableFilter<"Invoice"> | string | null
    customerEmail?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    quotationId?: StringNullableFilter<"Invoice"> | string | null
    agent?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    govtFeeAccount?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    transactions?: TransactionListRelationFilter
    quotation?: XOR<QuotationNullableRelationFilter, QuotationWhereInput> | null
  }, "id" | "invoiceNo">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    paymentMethod?: SortOrder
    paymentRef?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    status?: SortOrder
    govtFeeAccountId?: SortOrderInput | SortOrder
    govtFeeRef?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNo?: StringWithAggregatesFilter<"Invoice"> | string
    date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    companyId?: StringWithAggregatesFilter<"Invoice"> | string
    branchId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    agentId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Invoice"> | $Enums.PaymentMethod
    paymentRef?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    govtFeeAccountId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    govtFeeRef?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customerPhone?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customerEmail?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    quotationId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    companyId?: StringFilter<"Transaction"> | string
    branchId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    invNo?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    enteredById?: StringNullableFilter<"Transaction"> | string | null
    beneficiaryId?: StringNullableFilter<"Transaction"> | string | null
    partnerId?: StringNullableFilter<"Transaction"> | string | null
    workTypeId?: StringNullableFilter<"Transaction"> | string | null
    govFee?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    vat?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    receiptNo?: StringNullableFilter<"Transaction"> | string | null
    govtFeeAccountId?: StringNullableFilter<"Transaction"> | string | null
    govtFeeRef?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    cardId?: StringNullableFilter<"Transaction"> | string | null
    transactionId?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumPaymentStatusFilter<"Transaction"> | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFilter<"Transaction"> | $Enums.AdvanceStatus
    advanceAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    customerName?: StringNullableFilter<"Transaction"> | string | null
    applicantName?: StringNullableFilter<"Transaction"> | string | null
    details?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    isVatApplicable?: BoolFilter<"Transaction"> | boolean
    vatRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"Transaction"> | number
    beneficiary?: XOR<BeneficiaryNullableRelationFilter, BeneficiaryWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    enteredBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    govtFeeAccount?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    workType?: XOR<WorkTypeNullableRelationFilter, WorkTypeWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    invNo?: SortOrderInput | SortOrder
    date?: SortOrder
    enteredById?: SortOrderInput | SortOrder
    beneficiaryId?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    workTypeId?: SortOrderInput | SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    vat?: SortOrder
    total?: SortOrder
    type?: SortOrder
    receiptNo?: SortOrderInput | SortOrder
    govtFeeAccountId?: SortOrderInput | SortOrder
    govtFeeRef?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    cardId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    advanceStatus?: SortOrder
    advanceAmount?: SortOrder
    customerName?: SortOrderInput | SortOrder
    applicantName?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVatApplicable?: SortOrder
    vatRate?: SortOrder
    quantity?: SortOrder
    beneficiary?: BeneficiaryOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    enteredBy?: UserOrderByWithRelationInput
    govtFeeAccount?: AccountOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
    workType?: WorkTypeOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    companyId?: StringFilter<"Transaction"> | string
    branchId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    invNo?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    enteredById?: StringNullableFilter<"Transaction"> | string | null
    beneficiaryId?: StringNullableFilter<"Transaction"> | string | null
    partnerId?: StringNullableFilter<"Transaction"> | string | null
    workTypeId?: StringNullableFilter<"Transaction"> | string | null
    govFee?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    vat?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    receiptNo?: StringNullableFilter<"Transaction"> | string | null
    govtFeeAccountId?: StringNullableFilter<"Transaction"> | string | null
    govtFeeRef?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    cardId?: StringNullableFilter<"Transaction"> | string | null
    transactionId?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumPaymentStatusFilter<"Transaction"> | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFilter<"Transaction"> | $Enums.AdvanceStatus
    advanceAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    customerName?: StringNullableFilter<"Transaction"> | string | null
    applicantName?: StringNullableFilter<"Transaction"> | string | null
    details?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    isVatApplicable?: BoolFilter<"Transaction"> | boolean
    vatRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"Transaction"> | number
    beneficiary?: XOR<BeneficiaryNullableRelationFilter, BeneficiaryWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    enteredBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    govtFeeAccount?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    workType?: XOR<WorkTypeNullableRelationFilter, WorkTypeWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    invNo?: SortOrderInput | SortOrder
    date?: SortOrder
    enteredById?: SortOrderInput | SortOrder
    beneficiaryId?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    workTypeId?: SortOrderInput | SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    vat?: SortOrder
    total?: SortOrder
    type?: SortOrder
    receiptNo?: SortOrderInput | SortOrder
    govtFeeAccountId?: SortOrderInput | SortOrder
    govtFeeRef?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    cardId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    advanceStatus?: SortOrder
    advanceAmount?: SortOrder
    customerName?: SortOrderInput | SortOrder
    applicantName?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVatApplicable?: SortOrder
    vatRate?: SortOrder
    quantity?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    companyId?: StringWithAggregatesFilter<"Transaction"> | string
    branchId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    invNo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    enteredById?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    beneficiaryId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    partnerId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    workTypeId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    govFee?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    vat?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    receiptNo?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    govtFeeAccountId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    govtFeeRef?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    cardId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Transaction"> | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusWithAggregatesFilter<"Transaction"> | $Enums.AdvanceStatus
    advanceAmount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    customerName?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    applicantName?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    details?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    isVatApplicable?: BoolWithAggregatesFilter<"Transaction"> | boolean
    vatRate?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    quantity?: IntWithAggregatesFilter<"Transaction"> | number
  }

  export type WorkTypeWhereInput = {
    AND?: WorkTypeWhereInput | WorkTypeWhereInput[]
    OR?: WorkTypeWhereInput[]
    NOT?: WorkTypeWhereInput | WorkTypeWhereInput[]
    id?: StringFilter<"WorkType"> | string
    companyId?: StringFilter<"WorkType"> | string
    description?: StringFilter<"WorkType"> | string
    presetGovFee?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFilter<"WorkType"> | boolean
    vatRate?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    transactions?: TransactionListRelationFilter
    quotationItems?: QuotationItemListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type WorkTypeOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    description?: SortOrder
    presetGovFee?: SortOrder
    presetTypingCharge?: SortOrder
    vatApplicable?: SortOrder
    vatRate?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    quotationItems?: QuotationItemOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type WorkTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_description?: WorkTypeCompanyIdDescriptionCompoundUniqueInput
    AND?: WorkTypeWhereInput | WorkTypeWhereInput[]
    OR?: WorkTypeWhereInput[]
    NOT?: WorkTypeWhereInput | WorkTypeWhereInput[]
    companyId?: StringFilter<"WorkType"> | string
    description?: StringFilter<"WorkType"> | string
    presetGovFee?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFilter<"WorkType"> | boolean
    vatRate?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    transactions?: TransactionListRelationFilter
    quotationItems?: QuotationItemListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_description">

  export type WorkTypeOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    description?: SortOrder
    presetGovFee?: SortOrder
    presetTypingCharge?: SortOrder
    vatApplicable?: SortOrder
    vatRate?: SortOrder
    _count?: WorkTypeCountOrderByAggregateInput
    _avg?: WorkTypeAvgOrderByAggregateInput
    _max?: WorkTypeMaxOrderByAggregateInput
    _min?: WorkTypeMinOrderByAggregateInput
    _sum?: WorkTypeSumOrderByAggregateInput
  }

  export type WorkTypeScalarWhereWithAggregatesInput = {
    AND?: WorkTypeScalarWhereWithAggregatesInput | WorkTypeScalarWhereWithAggregatesInput[]
    OR?: WorkTypeScalarWhereWithAggregatesInput[]
    NOT?: WorkTypeScalarWhereWithAggregatesInput | WorkTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkType"> | string
    companyId?: StringWithAggregatesFilter<"WorkType"> | string
    description?: StringWithAggregatesFilter<"WorkType"> | string
    presetGovFee?: DecimalWithAggregatesFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalWithAggregatesFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolWithAggregatesFilter<"WorkType"> | boolean
    vatRate?: DecimalWithAggregatesFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
  }

  export type BeneficiaryWhereInput = {
    AND?: BeneficiaryWhereInput | BeneficiaryWhereInput[]
    OR?: BeneficiaryWhereInput[]
    NOT?: BeneficiaryWhereInput | BeneficiaryWhereInput[]
    id?: StringFilter<"Beneficiary"> | string
    companyId?: StringFilter<"Beneficiary"> | string
    name?: StringFilter<"Beneficiary"> | string
    details?: StringNullableFilter<"Beneficiary"> | string | null
    phone?: StringNullableFilter<"Beneficiary"> | string | null
    email?: StringNullableFilter<"Beneficiary"> | string | null
    partnerId?: StringNullableFilter<"Beneficiary"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    transactions?: TransactionListRelationFilter
  }

  export type BeneficiaryOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    details?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type BeneficiaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BeneficiaryWhereInput | BeneficiaryWhereInput[]
    OR?: BeneficiaryWhereInput[]
    NOT?: BeneficiaryWhereInput | BeneficiaryWhereInput[]
    companyId?: StringFilter<"Beneficiary"> | string
    name?: StringFilter<"Beneficiary"> | string
    details?: StringNullableFilter<"Beneficiary"> | string | null
    phone?: StringNullableFilter<"Beneficiary"> | string | null
    email?: StringNullableFilter<"Beneficiary"> | string | null
    partnerId?: StringNullableFilter<"Beneficiary"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    transactions?: TransactionListRelationFilter
  }, "id">

  export type BeneficiaryOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    details?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    _count?: BeneficiaryCountOrderByAggregateInput
    _max?: BeneficiaryMaxOrderByAggregateInput
    _min?: BeneficiaryMinOrderByAggregateInput
  }

  export type BeneficiaryScalarWhereWithAggregatesInput = {
    AND?: BeneficiaryScalarWhereWithAggregatesInput | BeneficiaryScalarWhereWithAggregatesInput[]
    OR?: BeneficiaryScalarWhereWithAggregatesInput[]
    NOT?: BeneficiaryScalarWhereWithAggregatesInput | BeneficiaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Beneficiary"> | string
    companyId?: StringWithAggregatesFilter<"Beneficiary"> | string
    name?: StringWithAggregatesFilter<"Beneficiary"> | string
    details?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
    email?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
    partnerId?: StringNullableWithAggregatesFilter<"Beneficiary"> | string | null
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    companyId?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    type?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    email?: StringNullableFilter<"Partner"> | string | null
    phone?: StringNullableFilter<"Partner"> | string | null
    beneficiaries?: BeneficiaryListRelationFilter
    ledgerTransactions?: LedgerTransactionListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    transactions?: TransactionListRelationFilter
    quotations?: QuotationListRelationFilter
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    beneficiaries?: BeneficiaryOrderByRelationAggregateInput
    ledgerTransactions?: LedgerTransactionOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    quotations?: QuotationOrderByRelationAggregateInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_name?: PartnerCompanyIdNameCompoundUniqueInput
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    companyId?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    type?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    email?: StringNullableFilter<"Partner"> | string | null
    phone?: StringNullableFilter<"Partner"> | string | null
    beneficiaries?: BeneficiaryListRelationFilter
    ledgerTransactions?: LedgerTransactionListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    transactions?: TransactionListRelationFilter
    quotations?: QuotationListRelationFilter
  }, "id" | "companyId_name">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    companyId?: StringWithAggregatesFilter<"Partner"> | string
    name?: StringWithAggregatesFilter<"Partner"> | string
    type?: EnumPartnerTypeWithAggregatesFilter<"Partner"> | $Enums.PartnerType
    email?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Partner"> | string | null
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    companyId?: StringFilter<"Expense"> | string
    branchId?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    categoryId?: StringFilter<"Expense"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"Expense"> | string | null
    enteredById?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    category?: XOR<ExpenseCategoryRelationFilter, ExpenseCategoryWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    enteredBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    categoryId?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrderInput | SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    category?: ExpenseCategoryOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    enteredBy?: UserOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    companyId?: StringFilter<"Expense"> | string
    branchId?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    categoryId?: StringFilter<"Expense"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"Expense"> | string | null
    enteredById?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    category?: XOR<ExpenseCategoryRelationFilter, ExpenseCategoryWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    enteredBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    categoryId?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrderInput | SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    companyId?: StringWithAggregatesFilter<"Expense"> | string
    branchId?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    categoryId?: StringWithAggregatesFilter<"Expense"> | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Expense"> | $Enums.PaymentMethod
    accountId?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    enteredById?: StringWithAggregatesFilter<"Expense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type ExpenseCategoryWhereInput = {
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    companyId?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringNullableFilter<"ExpenseCategory"> | string | null
    ledgerAccountId?: StringNullableFilter<"ExpenseCategory"> | string | null
    expenses?: ExpenseListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    ledgerAccount?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    voucherItems?: VoucherItemListRelationFilter
  }

  export type ExpenseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ledgerAccountId?: SortOrderInput | SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    ledgerAccount?: AccountOrderByWithRelationInput
    voucherItems?: VoucherItemOrderByRelationAggregateInput
  }

  export type ExpenseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_name?: ExpenseCategoryCompanyIdNameCompoundUniqueInput
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    companyId?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringNullableFilter<"ExpenseCategory"> | string | null
    ledgerAccountId?: StringNullableFilter<"ExpenseCategory"> | string | null
    expenses?: ExpenseListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    ledgerAccount?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    voucherItems?: VoucherItemListRelationFilter
  }, "id" | "companyId_name">

  export type ExpenseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ledgerAccountId?: SortOrderInput | SortOrder
    _count?: ExpenseCategoryCountOrderByAggregateInput
    _max?: ExpenseCategoryMaxOrderByAggregateInput
    _min?: ExpenseCategoryMinOrderByAggregateInput
  }

  export type ExpenseCategoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    companyId?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    name?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
    ledgerAccountId?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    companyId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    balance?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"Account"> | string | null
    bankName?: StringNullableFilter<"Account"> | string | null
    branchId?: StringNullableFilter<"Account"> | string | null
    category?: EnumAccountCategoryFilter<"Account"> | $Enums.AccountCategory
    code?: StringFilter<"Account"> | string
    iban?: StringNullableFilter<"Account"> | string | null
    isPostable?: BoolFilter<"Account"> | boolean
    isSystem?: BoolFilter<"Account"> | boolean
    linkedBranchIds?: StringNullableListFilter<"Account">
    merchantId?: StringNullableFilter<"Account"> | string | null
    parentAccountId?: StringNullableFilter<"Account"> | string | null
    swiftCode?: StringNullableFilter<"Account"> | string | null
    terminalId?: StringNullableFilter<"Account"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    parentAccount?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    childAccounts?: AccountListRelationFilter
    expenses?: ExpenseListRelationFilter
    expenseCategories?: ExpenseCategoryListRelationFilter
    invoicesGovtFee?: InvoiceListRelationFilter
    ledgerTransactions?: LedgerTransactionListRelationFilter
    transactions?: TransactionListRelationFilter
    transactionsGovtFee?: TransactionListRelationFilter
    vouchers?: VoucherListRelationFilter
    voucherPayments?: VoucherPaymentListRelationFilter
    businessCards?: BusinessCardListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    category?: SortOrder
    code?: SortOrder
    iban?: SortOrderInput | SortOrder
    isPostable?: SortOrder
    isSystem?: SortOrder
    linkedBranchIds?: SortOrder
    merchantId?: SortOrderInput | SortOrder
    parentAccountId?: SortOrderInput | SortOrder
    swiftCode?: SortOrderInput | SortOrder
    terminalId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    parentAccount?: AccountOrderByWithRelationInput
    childAccounts?: AccountOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    expenseCategories?: ExpenseCategoryOrderByRelationAggregateInput
    invoicesGovtFee?: InvoiceOrderByRelationAggregateInput
    ledgerTransactions?: LedgerTransactionOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    transactionsGovtFee?: TransactionOrderByRelationAggregateInput
    vouchers?: VoucherOrderByRelationAggregateInput
    voucherPayments?: VoucherPaymentOrderByRelationAggregateInput
    businessCards?: BusinessCardOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: AccountCompanyIdCodeCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    companyId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    balance?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"Account"> | string | null
    bankName?: StringNullableFilter<"Account"> | string | null
    branchId?: StringNullableFilter<"Account"> | string | null
    category?: EnumAccountCategoryFilter<"Account"> | $Enums.AccountCategory
    code?: StringFilter<"Account"> | string
    iban?: StringNullableFilter<"Account"> | string | null
    isPostable?: BoolFilter<"Account"> | boolean
    isSystem?: BoolFilter<"Account"> | boolean
    linkedBranchIds?: StringNullableListFilter<"Account">
    merchantId?: StringNullableFilter<"Account"> | string | null
    parentAccountId?: StringNullableFilter<"Account"> | string | null
    swiftCode?: StringNullableFilter<"Account"> | string | null
    terminalId?: StringNullableFilter<"Account"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    parentAccount?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    childAccounts?: AccountListRelationFilter
    expenses?: ExpenseListRelationFilter
    expenseCategories?: ExpenseCategoryListRelationFilter
    invoicesGovtFee?: InvoiceListRelationFilter
    ledgerTransactions?: LedgerTransactionListRelationFilter
    transactions?: TransactionListRelationFilter
    transactionsGovtFee?: TransactionListRelationFilter
    vouchers?: VoucherListRelationFilter
    voucherPayments?: VoucherPaymentListRelationFilter
    businessCards?: BusinessCardListRelationFilter
  }, "id" | "companyId_code">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    category?: SortOrder
    code?: SortOrder
    iban?: SortOrderInput | SortOrder
    isPostable?: SortOrder
    isSystem?: SortOrder
    linkedBranchIds?: SortOrder
    merchantId?: SortOrderInput | SortOrder
    parentAccountId?: SortOrderInput | SortOrder
    swiftCode?: SortOrderInput | SortOrder
    terminalId?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    companyId?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    type?: EnumAccountTypeWithAggregatesFilter<"Account"> | $Enums.AccountType
    balance?: DecimalWithAggregatesFilter<"Account"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableWithAggregatesFilter<"Account"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Account"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    category?: EnumAccountCategoryWithAggregatesFilter<"Account"> | $Enums.AccountCategory
    code?: StringWithAggregatesFilter<"Account"> | string
    iban?: StringNullableWithAggregatesFilter<"Account"> | string | null
    isPostable?: BoolWithAggregatesFilter<"Account"> | boolean
    isSystem?: BoolWithAggregatesFilter<"Account"> | boolean
    linkedBranchIds?: StringNullableListFilter<"Account">
    merchantId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    parentAccountId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    swiftCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    terminalId?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type JournalEntryWhereInput = {
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    companyId?: StringFilter<"JournalEntry"> | string
    branchId?: StringNullableFilter<"JournalEntry"> | string | null
    postingDate?: DateTimeFilter<"JournalEntry"> | Date | string
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    description?: StringNullableFilter<"JournalEntry"> | string | null
    type?: EnumJournalEntryTypeFilter<"JournalEntry"> | $Enums.JournalEntryType
    referenceType?: StringNullableFilter<"JournalEntry"> | string | null
    referenceId?: StringNullableFilter<"JournalEntry"> | string | null
    reversedEntryId?: StringNullableFilter<"JournalEntry"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    transactions?: LedgerTransactionListRelationFilter
  }

  export type JournalEntryOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    postingDate?: SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    referenceType?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    reversedEntryId?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    transactions?: LedgerTransactionOrderByRelationAggregateInput
  }

  export type JournalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    companyId?: StringFilter<"JournalEntry"> | string
    branchId?: StringNullableFilter<"JournalEntry"> | string | null
    postingDate?: DateTimeFilter<"JournalEntry"> | Date | string
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    description?: StringNullableFilter<"JournalEntry"> | string | null
    type?: EnumJournalEntryTypeFilter<"JournalEntry"> | $Enums.JournalEntryType
    referenceType?: StringNullableFilter<"JournalEntry"> | string | null
    referenceId?: StringNullableFilter<"JournalEntry"> | string | null
    reversedEntryId?: StringNullableFilter<"JournalEntry"> | string | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    transactions?: LedgerTransactionListRelationFilter
  }, "id">

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    postingDate?: SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    referenceType?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    reversedEntryId?: SortOrderInput | SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    OR?: JournalEntryScalarWhereWithAggregatesInput[]
    NOT?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalEntry"> | string
    companyId?: StringWithAggregatesFilter<"JournalEntry"> | string
    branchId?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    postingDate?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    description?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    type?: EnumJournalEntryTypeWithAggregatesFilter<"JournalEntry"> | $Enums.JournalEntryType
    referenceType?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    referenceId?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    reversedEntryId?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
  }

  export type LedgerTransactionWhereInput = {
    AND?: LedgerTransactionWhereInput | LedgerTransactionWhereInput[]
    OR?: LedgerTransactionWhereInput[]
    NOT?: LedgerTransactionWhereInput | LedgerTransactionWhereInput[]
    id?: StringFilter<"LedgerTransaction"> | string
    journalEntryId?: StringFilter<"LedgerTransaction"> | string
    accountId?: StringFilter<"LedgerTransaction"> | string
    debit?: DecimalFilter<"LedgerTransaction"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"LedgerTransaction"> | Decimal | DecimalJsLike | number | string
    partnerId?: StringNullableFilter<"LedgerTransaction"> | string | null
    companyId?: StringFilter<"LedgerTransaction"> | string
    branchId?: StringNullableFilter<"LedgerTransaction"> | string | null
    cardId?: StringNullableFilter<"LedgerTransaction"> | string | null
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    journalEntry?: XOR<JournalEntryRelationFilter, JournalEntryWhereInput>
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    card?: XOR<BusinessCardNullableRelationFilter, BusinessCardWhereInput> | null
  }

  export type LedgerTransactionOrderByWithRelationInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    cardId?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    journalEntry?: JournalEntryOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
    card?: BusinessCardOrderByWithRelationInput
  }

  export type LedgerTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LedgerTransactionWhereInput | LedgerTransactionWhereInput[]
    OR?: LedgerTransactionWhereInput[]
    NOT?: LedgerTransactionWhereInput | LedgerTransactionWhereInput[]
    journalEntryId?: StringFilter<"LedgerTransaction"> | string
    accountId?: StringFilter<"LedgerTransaction"> | string
    debit?: DecimalFilter<"LedgerTransaction"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"LedgerTransaction"> | Decimal | DecimalJsLike | number | string
    partnerId?: StringNullableFilter<"LedgerTransaction"> | string | null
    companyId?: StringFilter<"LedgerTransaction"> | string
    branchId?: StringNullableFilter<"LedgerTransaction"> | string | null
    cardId?: StringNullableFilter<"LedgerTransaction"> | string | null
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    journalEntry?: XOR<JournalEntryRelationFilter, JournalEntryWhereInput>
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    card?: XOR<BusinessCardNullableRelationFilter, BusinessCardWhereInput> | null
  }, "id">

  export type LedgerTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    cardId?: SortOrderInput | SortOrder
    _count?: LedgerTransactionCountOrderByAggregateInput
    _avg?: LedgerTransactionAvgOrderByAggregateInput
    _max?: LedgerTransactionMaxOrderByAggregateInput
    _min?: LedgerTransactionMinOrderByAggregateInput
    _sum?: LedgerTransactionSumOrderByAggregateInput
  }

  export type LedgerTransactionScalarWhereWithAggregatesInput = {
    AND?: LedgerTransactionScalarWhereWithAggregatesInput | LedgerTransactionScalarWhereWithAggregatesInput[]
    OR?: LedgerTransactionScalarWhereWithAggregatesInput[]
    NOT?: LedgerTransactionScalarWhereWithAggregatesInput | LedgerTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LedgerTransaction"> | string
    journalEntryId?: StringWithAggregatesFilter<"LedgerTransaction"> | string
    accountId?: StringWithAggregatesFilter<"LedgerTransaction"> | string
    debit?: DecimalWithAggregatesFilter<"LedgerTransaction"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalWithAggregatesFilter<"LedgerTransaction"> | Decimal | DecimalJsLike | number | string
    partnerId?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
    companyId?: StringWithAggregatesFilter<"LedgerTransaction"> | string
    branchId?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
    cardId?: StringNullableWithAggregatesFilter<"LedgerTransaction"> | string | null
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: StringFilter<"Voucher"> | string
    voucherNo?: StringFilter<"Voucher"> | string
    date?: DateTimeFilter<"Voucher"> | Date | string
    companyId?: StringFilter<"Voucher"> | string
    branchId?: StringNullableFilter<"Voucher"> | string | null
    description?: StringNullableFilter<"Voucher"> | string | null
    vendorId?: StringNullableFilter<"Voucher"> | string | null
    vendorName?: StringNullableFilter<"Voucher"> | string | null
    total?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFilter<"Voucher"> | $Enums.VoucherStatus
    type?: EnumVoucherTypeFilter<"Voucher"> | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFilter<"Voucher"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"Voucher"> | string | null
    enteredById?: StringFilter<"Voucher"> | string
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    billUrl?: StringNullableFilter<"Voucher"> | string | null
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    enteredBy?: XOR<UserRelationFilter, UserWhereInput>
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    items?: VoucherItemListRelationFilter
    payments?: VoucherPaymentListRelationFilter
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    voucherNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    vendorName?: SortOrderInput | SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    type?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrderInput | SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billUrl?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    enteredBy?: UserOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    items?: VoucherItemOrderByRelationAggregateInput
    payments?: VoucherPaymentOrderByRelationAggregateInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    voucherNo?: string
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    date?: DateTimeFilter<"Voucher"> | Date | string
    companyId?: StringFilter<"Voucher"> | string
    branchId?: StringNullableFilter<"Voucher"> | string | null
    description?: StringNullableFilter<"Voucher"> | string | null
    vendorId?: StringNullableFilter<"Voucher"> | string | null
    vendorName?: StringNullableFilter<"Voucher"> | string | null
    total?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFilter<"Voucher"> | $Enums.VoucherStatus
    type?: EnumVoucherTypeFilter<"Voucher"> | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFilter<"Voucher"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"Voucher"> | string | null
    enteredById?: StringFilter<"Voucher"> | string
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    billUrl?: StringNullableFilter<"Voucher"> | string | null
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    enteredBy?: XOR<UserRelationFilter, UserWhereInput>
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    items?: VoucherItemListRelationFilter
    payments?: VoucherPaymentListRelationFilter
  }, "id" | "voucherNo">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    voucherNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    vendorName?: SortOrderInput | SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    type?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrderInput | SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billUrl?: SortOrderInput | SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Voucher"> | string
    voucherNo?: StringWithAggregatesFilter<"Voucher"> | string
    date?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    companyId?: StringWithAggregatesFilter<"Voucher"> | string
    branchId?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    description?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    vendorId?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    vendorName?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    total?: DecimalWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusWithAggregatesFilter<"Voucher"> | $Enums.VoucherStatus
    type?: EnumVoucherTypeWithAggregatesFilter<"Voucher"> | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Voucher"> | $Enums.PaymentMethod
    accountId?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    enteredById?: StringWithAggregatesFilter<"Voucher"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    billUrl?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
  }

  export type VoucherItemWhereInput = {
    AND?: VoucherItemWhereInput | VoucherItemWhereInput[]
    OR?: VoucherItemWhereInput[]
    NOT?: VoucherItemWhereInput | VoucherItemWhereInput[]
    id?: StringFilter<"VoucherItem"> | string
    voucherId?: StringFilter<"VoucherItem"> | string
    categoryId?: StringFilter<"VoucherItem"> | string
    quantity?: IntFilter<"VoucherItem"> | number
    amount?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"VoucherItem"> | string | null
    isVatApplicable?: BoolFilter<"VoucherItem"> | boolean
    vatAmount?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    category?: XOR<ExpenseCategoryRelationFilter, ExpenseCategoryWhereInput>
    voucher?: XOR<VoucherRelationFilter, VoucherWhereInput>
  }

  export type VoucherItemOrderByWithRelationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    categoryId?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    isVatApplicable?: SortOrder
    vatAmount?: SortOrder
    vatRate?: SortOrder
    category?: ExpenseCategoryOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
  }

  export type VoucherItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoucherItemWhereInput | VoucherItemWhereInput[]
    OR?: VoucherItemWhereInput[]
    NOT?: VoucherItemWhereInput | VoucherItemWhereInput[]
    voucherId?: StringFilter<"VoucherItem"> | string
    categoryId?: StringFilter<"VoucherItem"> | string
    quantity?: IntFilter<"VoucherItem"> | number
    amount?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"VoucherItem"> | string | null
    isVatApplicable?: BoolFilter<"VoucherItem"> | boolean
    vatAmount?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    category?: XOR<ExpenseCategoryRelationFilter, ExpenseCategoryWhereInput>
    voucher?: XOR<VoucherRelationFilter, VoucherWhereInput>
  }, "id">

  export type VoucherItemOrderByWithAggregationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    categoryId?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    isVatApplicable?: SortOrder
    vatAmount?: SortOrder
    vatRate?: SortOrder
    _count?: VoucherItemCountOrderByAggregateInput
    _avg?: VoucherItemAvgOrderByAggregateInput
    _max?: VoucherItemMaxOrderByAggregateInput
    _min?: VoucherItemMinOrderByAggregateInput
    _sum?: VoucherItemSumOrderByAggregateInput
  }

  export type VoucherItemScalarWhereWithAggregatesInput = {
    AND?: VoucherItemScalarWhereWithAggregatesInput | VoucherItemScalarWhereWithAggregatesInput[]
    OR?: VoucherItemScalarWhereWithAggregatesInput[]
    NOT?: VoucherItemScalarWhereWithAggregatesInput | VoucherItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoucherItem"> | string
    voucherId?: StringWithAggregatesFilter<"VoucherItem"> | string
    categoryId?: StringWithAggregatesFilter<"VoucherItem"> | string
    quantity?: IntWithAggregatesFilter<"VoucherItem"> | number
    amount?: DecimalWithAggregatesFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"VoucherItem"> | string | null
    isVatApplicable?: BoolWithAggregatesFilter<"VoucherItem"> | boolean
    vatAmount?: DecimalWithAggregatesFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalWithAggregatesFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    companyId?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    phone?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    vouchers?: VoucherListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    vouchers?: VoucherOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_name?: VendorCompanyIdNameCompoundUniqueInput
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    companyId?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    phone?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    vouchers?: VoucherListRelationFilter
  }, "id" | "companyId_name">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    companyId?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type VoucherPaymentWhereInput = {
    AND?: VoucherPaymentWhereInput | VoucherPaymentWhereInput[]
    OR?: VoucherPaymentWhereInput[]
    NOT?: VoucherPaymentWhereInput | VoucherPaymentWhereInput[]
    id?: StringFilter<"VoucherPayment"> | string
    voucherId?: StringFilter<"VoucherPayment"> | string
    date?: DateTimeFilter<"VoucherPayment"> | Date | string
    amount?: DecimalFilter<"VoucherPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"VoucherPayment"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"VoucherPayment"> | string | null
    receiptNo?: StringFilter<"VoucherPayment"> | string
    enteredById?: StringFilter<"VoucherPayment"> | string
    createdAt?: DateTimeFilter<"VoucherPayment"> | Date | string
    companyId?: StringFilter<"VoucherPayment"> | string
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    enteredBy?: XOR<UserRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherRelationFilter, VoucherWhereInput>
  }

  export type VoucherPaymentOrderByWithRelationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrderInput | SortOrder
    receiptNo?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    account?: AccountOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    enteredBy?: UserOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
  }

  export type VoucherPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_receiptNo?: VoucherPaymentCompanyIdReceiptNoCompoundUniqueInput
    AND?: VoucherPaymentWhereInput | VoucherPaymentWhereInput[]
    OR?: VoucherPaymentWhereInput[]
    NOT?: VoucherPaymentWhereInput | VoucherPaymentWhereInput[]
    voucherId?: StringFilter<"VoucherPayment"> | string
    date?: DateTimeFilter<"VoucherPayment"> | Date | string
    amount?: DecimalFilter<"VoucherPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"VoucherPayment"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"VoucherPayment"> | string | null
    receiptNo?: StringFilter<"VoucherPayment"> | string
    enteredById?: StringFilter<"VoucherPayment"> | string
    createdAt?: DateTimeFilter<"VoucherPayment"> | Date | string
    companyId?: StringFilter<"VoucherPayment"> | string
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    enteredBy?: XOR<UserRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherRelationFilter, VoucherWhereInput>
  }, "id" | "companyId_receiptNo">

  export type VoucherPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrderInput | SortOrder
    receiptNo?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
    _count?: VoucherPaymentCountOrderByAggregateInput
    _avg?: VoucherPaymentAvgOrderByAggregateInput
    _max?: VoucherPaymentMaxOrderByAggregateInput
    _min?: VoucherPaymentMinOrderByAggregateInput
    _sum?: VoucherPaymentSumOrderByAggregateInput
  }

  export type VoucherPaymentScalarWhereWithAggregatesInput = {
    AND?: VoucherPaymentScalarWhereWithAggregatesInput | VoucherPaymentScalarWhereWithAggregatesInput[]
    OR?: VoucherPaymentScalarWhereWithAggregatesInput[]
    NOT?: VoucherPaymentScalarWhereWithAggregatesInput | VoucherPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoucherPayment"> | string
    voucherId?: StringWithAggregatesFilter<"VoucherPayment"> | string
    date?: DateTimeWithAggregatesFilter<"VoucherPayment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"VoucherPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"VoucherPayment"> | $Enums.PaymentMethod
    accountId?: StringNullableWithAggregatesFilter<"VoucherPayment"> | string | null
    receiptNo?: StringWithAggregatesFilter<"VoucherPayment"> | string
    enteredById?: StringWithAggregatesFilter<"VoucherPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VoucherPayment"> | Date | string
    companyId?: StringWithAggregatesFilter<"VoucherPayment"> | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    ipAddress?: StringNullableFilter<"PasswordResetToken"> | string | null
    userAgent?: StringNullableFilter<"PasswordResetToken"> | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    ipAddress?: StringNullableFilter<"PasswordResetToken"> | string | null
    userAgent?: StringNullableFilter<"PasswordResetToken"> | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PasswordResetToken"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PasswordResetToken"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type BusinessCardWhereInput = {
    AND?: BusinessCardWhereInput | BusinessCardWhereInput[]
    OR?: BusinessCardWhereInput[]
    NOT?: BusinessCardWhereInput | BusinessCardWhereInput[]
    id?: StringFilter<"BusinessCard"> | string
    companyId?: StringFilter<"BusinessCard"> | string
    name?: StringFilter<"BusinessCard"> | string
    type?: EnumCardTypeFilter<"BusinessCard"> | $Enums.CardType
    issuingBank?: StringFilter<"BusinessCard"> | string
    last4Digits?: StringFilter<"BusinessCard"> | string
    creditLimit?: DecimalNullableFilter<"BusinessCard"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"BusinessCard"> | string
    statementCycleDay?: IntNullableFilter<"BusinessCard"> | number | null
    paymentDueDays?: IntNullableFilter<"BusinessCard"> | number | null
    isActive?: BoolFilter<"BusinessCard"> | boolean
    createdAt?: DateTimeFilter<"BusinessCard"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessCard"> | Date | string
    ledgerAccountId?: StringFilter<"BusinessCard"> | string
    ledgerAccount?: XOR<AccountRelationFilter, AccountWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    ledgerTransactions?: LedgerTransactionListRelationFilter
  }

  export type BusinessCardOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    issuingBank?: SortOrder
    last4Digits?: SortOrder
    creditLimit?: SortOrderInput | SortOrder
    currency?: SortOrder
    statementCycleDay?: SortOrderInput | SortOrder
    paymentDueDays?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ledgerAccountId?: SortOrder
    ledgerAccount?: AccountOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    ledgerTransactions?: LedgerTransactionOrderByRelationAggregateInput
  }

  export type BusinessCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_ledgerAccountId?: BusinessCardCompanyIdLedgerAccountIdCompoundUniqueInput
    AND?: BusinessCardWhereInput | BusinessCardWhereInput[]
    OR?: BusinessCardWhereInput[]
    NOT?: BusinessCardWhereInput | BusinessCardWhereInput[]
    companyId?: StringFilter<"BusinessCard"> | string
    name?: StringFilter<"BusinessCard"> | string
    type?: EnumCardTypeFilter<"BusinessCard"> | $Enums.CardType
    issuingBank?: StringFilter<"BusinessCard"> | string
    last4Digits?: StringFilter<"BusinessCard"> | string
    creditLimit?: DecimalNullableFilter<"BusinessCard"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"BusinessCard"> | string
    statementCycleDay?: IntNullableFilter<"BusinessCard"> | number | null
    paymentDueDays?: IntNullableFilter<"BusinessCard"> | number | null
    isActive?: BoolFilter<"BusinessCard"> | boolean
    createdAt?: DateTimeFilter<"BusinessCard"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessCard"> | Date | string
    ledgerAccountId?: StringFilter<"BusinessCard"> | string
    ledgerAccount?: XOR<AccountRelationFilter, AccountWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    ledgerTransactions?: LedgerTransactionListRelationFilter
  }, "id" | "companyId_ledgerAccountId">

  export type BusinessCardOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    issuingBank?: SortOrder
    last4Digits?: SortOrder
    creditLimit?: SortOrderInput | SortOrder
    currency?: SortOrder
    statementCycleDay?: SortOrderInput | SortOrder
    paymentDueDays?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ledgerAccountId?: SortOrder
    _count?: BusinessCardCountOrderByAggregateInput
    _avg?: BusinessCardAvgOrderByAggregateInput
    _max?: BusinessCardMaxOrderByAggregateInput
    _min?: BusinessCardMinOrderByAggregateInput
    _sum?: BusinessCardSumOrderByAggregateInput
  }

  export type BusinessCardScalarWhereWithAggregatesInput = {
    AND?: BusinessCardScalarWhereWithAggregatesInput | BusinessCardScalarWhereWithAggregatesInput[]
    OR?: BusinessCardScalarWhereWithAggregatesInput[]
    NOT?: BusinessCardScalarWhereWithAggregatesInput | BusinessCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessCard"> | string
    companyId?: StringWithAggregatesFilter<"BusinessCard"> | string
    name?: StringWithAggregatesFilter<"BusinessCard"> | string
    type?: EnumCardTypeWithAggregatesFilter<"BusinessCard"> | $Enums.CardType
    issuingBank?: StringWithAggregatesFilter<"BusinessCard"> | string
    last4Digits?: StringWithAggregatesFilter<"BusinessCard"> | string
    creditLimit?: DecimalNullableWithAggregatesFilter<"BusinessCard"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"BusinessCard"> | string
    statementCycleDay?: IntNullableWithAggregatesFilter<"BusinessCard"> | number | null
    paymentDueDays?: IntNullableWithAggregatesFilter<"BusinessCard"> | number | null
    isActive?: BoolWithAggregatesFilter<"BusinessCard"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BusinessCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessCard"> | Date | string
    ledgerAccountId?: StringWithAggregatesFilter<"BusinessCard"> | string
  }

  export type QuotationWhereInput = {
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    id?: StringFilter<"Quotation"> | string
    quotationNo?: StringFilter<"Quotation"> | string
    date?: DateTimeFilter<"Quotation"> | Date | string
    validUntil?: DateTimeFilter<"Quotation"> | Date | string
    companyId?: StringFilter<"Quotation"> | string
    branchId?: StringNullableFilter<"Quotation"> | string | null
    partnerId?: StringNullableFilter<"Quotation"> | string | null
    beneficiaryName?: StringNullableFilter<"Quotation"> | string | null
    salespersonId?: StringFilter<"Quotation"> | string
    currency?: StringFilter<"Quotation"> | string
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    subtotal?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Quotation"> | string | null
    termsAndConditions?: StringNullableFilter<"Quotation"> | string | null
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
    sentAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    convertedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    approvedById?: StringNullableFilter<"Quotation"> | string | null
    approvedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    invoicedAmount?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    deletedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    salesperson?: XOR<UserRelationFilter, UserWhereInput>
    items?: QuotationItemListRelationFilter
    invoices?: InvoiceListRelationFilter
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type QuotationOrderByWithRelationInput = {
    id?: SortOrder
    quotationNo?: SortOrder
    date?: SortOrder
    validUntil?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    beneficiaryName?: SortOrderInput | SortOrder
    salespersonId?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    totalGovFee?: SortOrder
    totalTax?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    termsAndConditions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    invoicedAmount?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
    salesperson?: UserOrderByWithRelationInput
    items?: QuotationItemOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type QuotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quotationNo?: string
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    date?: DateTimeFilter<"Quotation"> | Date | string
    validUntil?: DateTimeFilter<"Quotation"> | Date | string
    companyId?: StringFilter<"Quotation"> | string
    branchId?: StringNullableFilter<"Quotation"> | string | null
    partnerId?: StringNullableFilter<"Quotation"> | string | null
    beneficiaryName?: StringNullableFilter<"Quotation"> | string | null
    salespersonId?: StringFilter<"Quotation"> | string
    currency?: StringFilter<"Quotation"> | string
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    subtotal?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Quotation"> | string | null
    termsAndConditions?: StringNullableFilter<"Quotation"> | string | null
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
    sentAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    convertedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    approvedById?: StringNullableFilter<"Quotation"> | string | null
    approvedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    invoicedAmount?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    deletedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    salesperson?: XOR<UserRelationFilter, UserWhereInput>
    items?: QuotationItemListRelationFilter
    invoices?: InvoiceListRelationFilter
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "quotationNo">

  export type QuotationOrderByWithAggregationInput = {
    id?: SortOrder
    quotationNo?: SortOrder
    date?: SortOrder
    validUntil?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    beneficiaryName?: SortOrderInput | SortOrder
    salespersonId?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    totalGovFee?: SortOrder
    totalTax?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    termsAndConditions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    invoicedAmount?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuotationCountOrderByAggregateInput
    _avg?: QuotationAvgOrderByAggregateInput
    _max?: QuotationMaxOrderByAggregateInput
    _min?: QuotationMinOrderByAggregateInput
    _sum?: QuotationSumOrderByAggregateInput
  }

  export type QuotationScalarWhereWithAggregatesInput = {
    AND?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    OR?: QuotationScalarWhereWithAggregatesInput[]
    NOT?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quotation"> | string
    quotationNo?: StringWithAggregatesFilter<"Quotation"> | string
    date?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    validUntil?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    companyId?: StringWithAggregatesFilter<"Quotation"> | string
    branchId?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    partnerId?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    beneficiaryName?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    salespersonId?: StringWithAggregatesFilter<"Quotation"> | string
    currency?: StringWithAggregatesFilter<"Quotation"> | string
    status?: EnumQuotationStatusWithAggregatesFilter<"Quotation"> | $Enums.QuotationStatus
    subtotal?: DecimalWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    termsAndConditions?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"Quotation"> | Date | string | null
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"Quotation"> | Date | string | null
    convertedAt?: DateTimeNullableWithAggregatesFilter<"Quotation"> | Date | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Quotation"> | Date | string | null
    invoicedAmount?: DecimalWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Quotation"> | Date | string | null
  }

  export type QuotationItemWhereInput = {
    AND?: QuotationItemWhereInput | QuotationItemWhereInput[]
    OR?: QuotationItemWhereInput[]
    NOT?: QuotationItemWhereInput | QuotationItemWhereInput[]
    id?: StringFilter<"QuotationItem"> | string
    quotationId?: StringFilter<"QuotationItem"> | string
    workTypeId?: StringNullableFilter<"QuotationItem"> | string | null
    description?: StringFilter<"QuotationItem"> | string
    govFee?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFilter<"QuotationItem"> | boolean
    quantity?: IntFilter<"QuotationItem"> | number
    quotation?: XOR<QuotationRelationFilter, QuotationWhereInput>
    workType?: XOR<WorkTypeNullableRelationFilter, WorkTypeWhereInput> | null
  }

  export type QuotationItemOrderByWithRelationInput = {
    id?: SortOrder
    quotationId?: SortOrder
    workTypeId?: SortOrderInput | SortOrder
    description?: SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    isVatApplicable?: SortOrder
    quantity?: SortOrder
    quotation?: QuotationOrderByWithRelationInput
    workType?: WorkTypeOrderByWithRelationInput
  }

  export type QuotationItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuotationItemWhereInput | QuotationItemWhereInput[]
    OR?: QuotationItemWhereInput[]
    NOT?: QuotationItemWhereInput | QuotationItemWhereInput[]
    quotationId?: StringFilter<"QuotationItem"> | string
    workTypeId?: StringNullableFilter<"QuotationItem"> | string | null
    description?: StringFilter<"QuotationItem"> | string
    govFee?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFilter<"QuotationItem"> | boolean
    quantity?: IntFilter<"QuotationItem"> | number
    quotation?: XOR<QuotationRelationFilter, QuotationWhereInput>
    workType?: XOR<WorkTypeNullableRelationFilter, WorkTypeWhereInput> | null
  }, "id">

  export type QuotationItemOrderByWithAggregationInput = {
    id?: SortOrder
    quotationId?: SortOrder
    workTypeId?: SortOrderInput | SortOrder
    description?: SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    isVatApplicable?: SortOrder
    quantity?: SortOrder
    _count?: QuotationItemCountOrderByAggregateInput
    _avg?: QuotationItemAvgOrderByAggregateInput
    _max?: QuotationItemMaxOrderByAggregateInput
    _min?: QuotationItemMinOrderByAggregateInput
    _sum?: QuotationItemSumOrderByAggregateInput
  }

  export type QuotationItemScalarWhereWithAggregatesInput = {
    AND?: QuotationItemScalarWhereWithAggregatesInput | QuotationItemScalarWhereWithAggregatesInput[]
    OR?: QuotationItemScalarWhereWithAggregatesInput[]
    NOT?: QuotationItemScalarWhereWithAggregatesInput | QuotationItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuotationItem"> | string
    quotationId?: StringWithAggregatesFilter<"QuotationItem"> | string
    workTypeId?: StringNullableWithAggregatesFilter<"QuotationItem"> | string | null
    description?: StringWithAggregatesFilter<"QuotationItem"> | string
    govFee?: DecimalWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolWithAggregatesFilter<"QuotationItem"> | boolean
    quantity?: IntWithAggregatesFilter<"QuotationItem"> | number
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyClosingCreateInput = {
    id?: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDailyClosingsInput
    closedBy?: UserCreateNestedOneWithoutDailyClosingsInput
    company: CompanyCreateNestedOneWithoutDailyClosingsInput
  }

  export type DailyClosingUncheckedCreateInput = {
    id?: string
    companyId: string
    branchId: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyClosingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDailyClosingsNestedInput
    closedBy?: UserUpdateOneWithoutDailyClosingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDailyClosingsNestedInput
  }

  export type DailyClosingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyClosingCreateManyInput = {
    id?: string
    companyId: string
    branchId: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyClosingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyClosingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    module: string
    action: string
    description?: string | null
    createdAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    module: string
    action: string
    description?: string | null
    createdAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    module: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    lastActivity?: Date | string
    createdAt?: Date | string
    isValid?: boolean
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    lastActivity?: Date | string
    createdAt?: Date | string
    isValid?: boolean
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    lastActivity?: Date | string
    createdAt?: Date | string
    isValid?: boolean
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    companyId: string
    userId?: string | null
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    companyId: string
    userId?: string | null
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestCreateInput = {
    id?: string
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutApprovalActionsInput
    requester: UserCreateNestedOneWithoutApprovalRequestsInput
  }

  export type ApprovalRequestUncheckedCreateInput = {
    id?: string
    requesterId: string
    approverId?: string | null
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutApprovalActionsNestedInput
    requester?: UserUpdateOneRequiredWithoutApprovalRequestsNestedInput
  }

  export type ApprovalRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestCreateManyInput = {
    id?: string
    requesterId: string
    approverId?: string | null
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialPeriodCreateInput = {
    id?: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    yearEndClosedAt?: Date | string | null
    accountingLockedBy?: UserCreateNestedOneWithoutAccountingLockedPeriodsInput
    company: CompanyCreateNestedOneWithoutFinancialPeriodsInput
    lastUnlockedBy?: UserCreateNestedOneWithoutUnlockedPeriodsInput
    vatLockedBy?: UserCreateNestedOneWithoutVatLockedPeriodsInput
    yearEndClosedBy?: UserCreateNestedOneWithoutYearEndClosedPeriodsInput
  }

  export type FinancialPeriodUncheckedCreateInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedBy?: UserUpdateOneWithoutAccountingLockedPeriodsNestedInput
    company?: CompanyUpdateOneRequiredWithoutFinancialPeriodsNestedInput
    lastUnlockedBy?: UserUpdateOneWithoutUnlockedPeriodsNestedInput
    vatLockedBy?: UserUpdateOneWithoutVatLockedPeriodsNestedInput
    yearEndClosedBy?: UserUpdateOneWithoutYearEndClosedPeriodsNestedInput
  }

  export type FinancialPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodCreateManyInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: UserCreateNestedOneWithoutInvoicesInput
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
    govtFeeAccount?: AccountCreateNestedOneWithoutInvoicesGovtFeeInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
    quotation?: QuotationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneWithoutInvoicesNestedInput
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutInvoicesGovtFeeNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
    quotation?: QuotationUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WorkTypeCreateInput = {
    id?: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionCreateNestedManyWithoutWorkTypeInput
    quotationItems?: QuotationItemCreateNestedManyWithoutWorkTypeInput
    company: CompanyCreateNestedOneWithoutWorkTypesInput
  }

  export type WorkTypeUncheckedCreateInput = {
    id?: string
    companyId: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutWorkTypeInput
    quotationItems?: QuotationItemUncheckedCreateNestedManyWithoutWorkTypeInput
  }

  export type WorkTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUpdateManyWithoutWorkTypeNestedInput
    quotationItems?: QuotationItemUpdateManyWithoutWorkTypeNestedInput
    company?: CompanyUpdateOneRequiredWithoutWorkTypesNestedInput
  }

  export type WorkTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedUpdateManyWithoutWorkTypeNestedInput
    quotationItems?: QuotationItemUncheckedUpdateManyWithoutWorkTypeNestedInput
  }

  export type WorkTypeCreateManyInput = {
    id?: string
    companyId: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
  }

  export type WorkTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WorkTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BeneficiaryCreateInput = {
    id?: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    company: CompanyCreateNestedOneWithoutBeneficiariesInput
    partner?: PartnerCreateNestedOneWithoutBeneficiariesInput
    transactions?: TransactionCreateNestedManyWithoutBeneficiaryInput
  }

  export type BeneficiaryUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    partnerId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutBeneficiaryInput
  }

  export type BeneficiaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutBeneficiariesNestedInput
    partner?: PartnerUpdateOneWithoutBeneficiariesNestedInput
    transactions?: TransactionUpdateManyWithoutBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutBeneficiaryNestedInput
  }

  export type BeneficiaryCreateManyInput = {
    id?: string
    companyId: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    partnerId?: string | null
  }

  export type BeneficiaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BeneficiaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartnerCreateInput = {
    id?: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPartnerInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutPartnerInput
    company: CompanyCreateNestedOneWithoutPartnersInput
    transactions?: TransactionCreateNestedManyWithoutPartnerInput
    quotations?: QuotationCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPartnerInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutPartnerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPartnerInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUpdateManyWithoutPartnerNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutPartnerNestedInput
    company?: CompanyUpdateOneRequiredWithoutPartnersNestedInput
    transactions?: TransactionUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPartnerNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutPartnerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
  }

  export type PartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateInput = {
    id?: string
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutExpensesInput
    branch?: BranchCreateNestedOneWithoutExpensesInput
    category: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    company: CompanyCreateNestedOneWithoutExpensesInput
    enteredBy: UserCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    companyId: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutExpensesNestedInput
    branch?: BranchUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    companyId: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    expenses?: ExpenseCreateNestedManyWithoutCategoryInput
    company: CompanyCreateNestedOneWithoutExpenseCategoriesInput
    ledgerAccount?: AccountCreateNestedOneWithoutExpenseCategoriesInput
    voucherItems?: VoucherItemCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    ledgerAccountId?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCategoryInput
    voucherItems?: VoucherItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutCategoryNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpenseCategoriesNestedInput
    ledgerAccount?: AccountUpdateOneWithoutExpenseCategoriesNestedInput
    voucherItems?: VoucherItemUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ledgerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutCategoryNestedInput
    voucherItems?: VoucherItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryCreateManyInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    ledgerAccountId?: string | null
  }

  export type ExpenseCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ledgerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalEntryCreateInput = {
    id?: string
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
    branch?: BranchCreateNestedOneWithoutJournalEntriesInput
    company: CompanyCreateNestedOneWithoutJournalEntriesInput
    transactions?: LedgerTransactionCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: string
    companyId: string
    branchId?: string | null
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
    transactions?: LedgerTransactionUncheckedCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutJournalEntriesNestedInput
    company?: CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput
    transactions?: LedgerTransactionUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LedgerTransactionUncheckedUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryCreateManyInput = {
    id?: string
    companyId: string
    branchId?: string | null
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
  }

  export type JournalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionCreateInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    companyId: string
    account: AccountCreateNestedOneWithoutLedgerTransactionsInput
    branch?: BranchCreateNestedOneWithoutLedgerTransactionsInput
    journalEntry: JournalEntryCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutLedgerTransactionsInput
    card?: BusinessCardCreateNestedOneWithoutLedgerTransactionsInput
  }

  export type LedgerTransactionUncheckedCreateInput = {
    id?: string
    journalEntryId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    branchId?: string | null
    cardId?: string | null
  }

  export type LedgerTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutLedgerTransactionsNestedInput
    branch?: BranchUpdateOneWithoutLedgerTransactionsNestedInput
    journalEntry?: JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutLedgerTransactionsNestedInput
    card?: BusinessCardUpdateOneWithoutLedgerTransactionsNestedInput
  }

  export type LedgerTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionCreateManyInput = {
    id?: string
    journalEntryId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    branchId?: string | null
    cardId?: string | null
  }

  export type LedgerTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type LedgerTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherCreateInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    account?: AccountCreateNestedOneWithoutVouchersInput
    branch?: BranchCreateNestedOneWithoutVouchersInput
    company: CompanyCreateNestedOneWithoutVouchersInput
    enteredBy: UserCreateNestedOneWithoutVouchersInput
    vendor?: VendorCreateNestedOneWithoutVouchersInput
    items?: VoucherItemCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    items?: VoucherItemUncheckedCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutVouchersNestedInput
    branch?: BranchUpdateOneWithoutVouchersNestedInput
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVouchersNestedInput
    vendor?: VendorUpdateOneWithoutVouchersNestedInput
    items?: VoucherItemUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: VoucherItemUncheckedUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherCreateManyInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
  }

  export type VoucherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherItemCreateInput = {
    id?: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
    category: ExpenseCategoryCreateNestedOneWithoutVoucherItemsInput
    voucher: VoucherCreateNestedOneWithoutItemsInput
  }

  export type VoucherItemUncheckedCreateInput = {
    id?: string
    voucherId: string
    categoryId: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
  }

  export type VoucherItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: ExpenseCategoryUpdateOneRequiredWithoutVoucherItemsNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutItemsNestedInput
  }

  export type VoucherItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherItemCreateManyInput = {
    id?: string
    voucherId: string
    categoryId: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
  }

  export type VoucherItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VendorCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVendorsInput
    vouchers?: VoucherCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vouchers?: VoucherUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVendorsNestedInput
    vouchers?: VoucherUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vouchers?: VoucherUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    companyId: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherPaymentCreateInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    receiptNo: string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutVoucherPaymentsInput
    company: CompanyCreateNestedOneWithoutVoucherPaymentsInput
    enteredBy: UserCreateNestedOneWithoutVoucherPaymentsInput
    voucher: VoucherCreateNestedOneWithoutPaymentsInput
  }

  export type VoucherPaymentUncheckedCreateInput = {
    id?: string
    voucherId: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    receiptNo: string
    enteredById: string
    createdAt?: Date | string
    companyId: string
  }

  export type VoucherPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    receiptNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutVoucherPaymentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutVoucherPaymentsNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVoucherPaymentsNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type VoucherPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNo?: StringFieldUpdateOperationsInput | string
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherPaymentCreateManyInput = {
    id?: string
    voucherId: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    receiptNo: string
    enteredById: string
    createdAt?: Date | string
    companyId: string
  }

  export type VoucherPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    receiptNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNo?: StringFieldUpdateOperationsInput | string
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCardCreateInput = {
    id?: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerAccount: AccountCreateNestedOneWithoutBusinessCardsInput
    company: CompanyCreateNestedOneWithoutBusinessCardsInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutCardInput
  }

  export type BusinessCardUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerAccountId: string
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutCardInput
  }

  export type BusinessCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerAccount?: AccountUpdateOneRequiredWithoutBusinessCardsNestedInput
    company?: CompanyUpdateOneRequiredWithoutBusinessCardsNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutCardNestedInput
  }

  export type BusinessCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerAccountId?: StringFieldUpdateOperationsInput | string
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutCardNestedInput
  }

  export type BusinessCardCreateManyInput = {
    id?: string
    companyId: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerAccountId: string
  }

  export type BusinessCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type QuotationCreateInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutQuotationsInput
    branch?: BranchCreateNestedOneWithoutQuotationsInput
    partner?: PartnerCreateNestedOneWithoutQuotationsInput
    salesperson: UserCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceCreateNestedManyWithoutQuotationInput
    approvedBy?: UserCreateNestedOneWithoutApprovedQuotationsInput
  }

  export type QuotationUncheckedCreateInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutQuotationsNestedInput
    branch?: BranchUpdateOneWithoutQuotationsNestedInput
    partner?: PartnerUpdateOneWithoutQuotationsNestedInput
    salesperson?: UserUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUpdateManyWithoutQuotationNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedQuotationsNestedInput
  }

  export type QuotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationCreateManyInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
  }

  export type QuotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuotationItemCreateInput = {
    id?: string
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
    quotation: QuotationCreateNestedOneWithoutItemsInput
    workType?: WorkTypeCreateNestedOneWithoutQuotationItemsInput
  }

  export type QuotationItemUncheckedCreateInput = {
    id?: string
    quotationId: string
    workTypeId?: string | null
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
  }

  export type QuotationItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quotation?: QuotationUpdateOneRequiredWithoutItemsNestedInput
    workType?: WorkTypeUpdateOneWithoutQuotationItemsNestedInput
  }

  export type QuotationItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type QuotationItemCreateManyInput = {
    id?: string
    quotationId: string
    workTypeId?: string | null
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
  }

  export type QuotationItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type QuotationItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumAccountingMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingMethod | EnumAccountingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingMethod[] | ListEnumAccountingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingMethod[] | ListEnumAccountingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingMethodFilter<$PrismaModel> | $Enums.AccountingMethod
  }

  export type EnumAccountingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingModel | EnumAccountingModelFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingModel[] | ListEnumAccountingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingModel[] | ListEnumAccountingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingModelFilter<$PrismaModel> | $Enums.AccountingModel
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumEmirateFilter<$PrismaModel = never> = {
    equals?: $Enums.Emirate | EnumEmirateFieldRefInput<$PrismaModel>
    in?: $Enums.Emirate[] | ListEnumEmirateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Emirate[] | ListEnumEmirateFieldRefInput<$PrismaModel>
    not?: NestedEnumEmirateFilter<$PrismaModel> | $Enums.Emirate
  }

  export type EnumLegalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalType | EnumLegalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalTypeFilter<$PrismaModel> | $Enums.LegalType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumVatFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.VatFrequency | EnumVatFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.VatFrequency[] | ListEnumVatFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.VatFrequency[] | ListEnumVatFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumVatFrequencyFilter<$PrismaModel> | $Enums.VatFrequency
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type BeneficiaryListRelationFilter = {
    every?: BeneficiaryWhereInput
    some?: BeneficiaryWhereInput
    none?: BeneficiaryWhereInput
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type DailyClosingListRelationFilter = {
    every?: DailyClosingWhereInput
    some?: DailyClosingWhereInput
    none?: DailyClosingWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ExpenseCategoryListRelationFilter = {
    every?: ExpenseCategoryWhereInput
    some?: ExpenseCategoryWhereInput
    none?: ExpenseCategoryWhereInput
  }

  export type FinancialPeriodListRelationFilter = {
    every?: FinancialPeriodWhereInput
    some?: FinancialPeriodWhereInput
    none?: FinancialPeriodWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type JournalEntryListRelationFilter = {
    every?: JournalEntryWhereInput
    some?: JournalEntryWhereInput
    none?: JournalEntryWhereInput
  }

  export type PartnerListRelationFilter = {
    every?: PartnerWhereInput
    some?: PartnerWhereInput
    none?: PartnerWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type VoucherListRelationFilter = {
    every?: VoucherWhereInput
    some?: VoucherWhereInput
    none?: VoucherWhereInput
  }

  export type VoucherPaymentListRelationFilter = {
    every?: VoucherPaymentWhereInput
    some?: VoucherPaymentWhereInput
    none?: VoucherPaymentWhereInput
  }

  export type WorkTypeListRelationFilter = {
    every?: WorkTypeWhereInput
    some?: WorkTypeWhereInput
    none?: WorkTypeWhereInput
  }

  export type BusinessCardListRelationFilter = {
    every?: BusinessCardWhereInput
    some?: BusinessCardWhereInput
    none?: BusinessCardWhereInput
  }

  export type QuotationListRelationFilter = {
    every?: QuotationWhereInput
    some?: QuotationWhereInput
    none?: QuotationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BeneficiaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyClosingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    trn?: SortOrder
    isActive?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingMethod?: SortOrder
    accountingModel?: SortOrder
    allowBackDated?: SortOrder
    auditRetentionDays?: SortOrder
    baseCurrency?: SortOrder
    decimalPrecision?: SortOrder
    emirate?: SortOrder
    establishmentCard?: SortOrder
    fiscalYearStart?: SortOrder
    invoiceFooter?: SortOrder
    invoiceHeader?: SortOrder
    legalType?: SortOrder
    logo?: SortOrder
    nameAr?: SortOrder
    stampImage?: SortOrder
    startDate?: SortOrder
    tradeLicense?: SortOrder
    vatFilingStart?: SortOrder
    vatRate?: SortOrder
    vatRegistered?: SortOrder
    vatRegistrationDate?: SortOrder
    vatReturnFreq?: SortOrder
    website?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    auditRetentionDays?: SortOrder
    decimalPrecision?: SortOrder
    fiscalYearStart?: SortOrder
    vatRate?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    trn?: SortOrder
    isActive?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingMethod?: SortOrder
    accountingModel?: SortOrder
    allowBackDated?: SortOrder
    auditRetentionDays?: SortOrder
    baseCurrency?: SortOrder
    decimalPrecision?: SortOrder
    emirate?: SortOrder
    establishmentCard?: SortOrder
    fiscalYearStart?: SortOrder
    invoiceFooter?: SortOrder
    invoiceHeader?: SortOrder
    legalType?: SortOrder
    logo?: SortOrder
    nameAr?: SortOrder
    stampImage?: SortOrder
    startDate?: SortOrder
    tradeLicense?: SortOrder
    vatFilingStart?: SortOrder
    vatRate?: SortOrder
    vatRegistered?: SortOrder
    vatRegistrationDate?: SortOrder
    vatReturnFreq?: SortOrder
    website?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    trn?: SortOrder
    isActive?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingMethod?: SortOrder
    accountingModel?: SortOrder
    allowBackDated?: SortOrder
    auditRetentionDays?: SortOrder
    baseCurrency?: SortOrder
    decimalPrecision?: SortOrder
    emirate?: SortOrder
    establishmentCard?: SortOrder
    fiscalYearStart?: SortOrder
    invoiceFooter?: SortOrder
    invoiceHeader?: SortOrder
    legalType?: SortOrder
    logo?: SortOrder
    nameAr?: SortOrder
    stampImage?: SortOrder
    startDate?: SortOrder
    tradeLicense?: SortOrder
    vatFilingStart?: SortOrder
    vatRate?: SortOrder
    vatRegistered?: SortOrder
    vatRegistrationDate?: SortOrder
    vatReturnFreq?: SortOrder
    website?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    auditRetentionDays?: SortOrder
    decimalPrecision?: SortOrder
    fiscalYearStart?: SortOrder
    vatRate?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAccountingMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingMethod | EnumAccountingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingMethod[] | ListEnumAccountingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingMethod[] | ListEnumAccountingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingMethodWithAggregatesFilter<$PrismaModel> | $Enums.AccountingMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountingMethodFilter<$PrismaModel>
    _max?: NestedEnumAccountingMethodFilter<$PrismaModel>
  }

  export type EnumAccountingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingModel | EnumAccountingModelFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingModel[] | ListEnumAccountingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingModel[] | ListEnumAccountingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingModelWithAggregatesFilter<$PrismaModel> | $Enums.AccountingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountingModelFilter<$PrismaModel>
    _max?: NestedEnumAccountingModelFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumEmirateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Emirate | EnumEmirateFieldRefInput<$PrismaModel>
    in?: $Enums.Emirate[] | ListEnumEmirateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Emirate[] | ListEnumEmirateFieldRefInput<$PrismaModel>
    not?: NestedEnumEmirateWithAggregatesFilter<$PrismaModel> | $Enums.Emirate
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmirateFilter<$PrismaModel>
    _max?: NestedEnumEmirateFilter<$PrismaModel>
  }

  export type EnumLegalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalType | EnumLegalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalTypeWithAggregatesFilter<$PrismaModel> | $Enums.LegalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLegalTypeFilter<$PrismaModel>
    _max?: NestedEnumLegalTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumVatFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VatFrequency | EnumVatFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.VatFrequency[] | ListEnumVatFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.VatFrequency[] | ListEnumVatFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumVatFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.VatFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVatFrequencyFilter<$PrismaModel>
    _max?: NestedEnumVatFrequencyFilter<$PrismaModel>
  }

  export type EnumClosingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClosingStatus | EnumClosingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClosingStatus[] | ListEnumClosingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClosingStatus[] | ListEnumClosingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClosingStatusFilter<$PrismaModel> | $Enums.ClosingStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type DailyClosingCompanyIdBranchIdDateCompoundUniqueInput = {
    companyId: string
    branchId: string
    date: Date | string
  }

  export type DailyClosingCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    openingCash?: SortOrder
    cashIn?: SortOrder
    cashOut?: SortOrder
    closingCash?: SortOrder
    bankIn?: SortOrder
    posIn?: SortOrder
    totalSales?: SortOrder
    totalVat?: SortOrder
    totalGovFee?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyClosingAvgOrderByAggregateInput = {
    openingCash?: SortOrder
    cashIn?: SortOrder
    cashOut?: SortOrder
    closingCash?: SortOrder
    bankIn?: SortOrder
    posIn?: SortOrder
    totalSales?: SortOrder
    totalVat?: SortOrder
    totalGovFee?: SortOrder
  }

  export type DailyClosingMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    openingCash?: SortOrder
    cashIn?: SortOrder
    cashOut?: SortOrder
    closingCash?: SortOrder
    bankIn?: SortOrder
    posIn?: SortOrder
    totalSales?: SortOrder
    totalVat?: SortOrder
    totalGovFee?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyClosingMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    openingCash?: SortOrder
    cashIn?: SortOrder
    cashOut?: SortOrder
    closingCash?: SortOrder
    bankIn?: SortOrder
    posIn?: SortOrder
    totalSales?: SortOrder
    totalVat?: SortOrder
    totalGovFee?: SortOrder
    closedById?: SortOrder
    closedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyClosingSumOrderByAggregateInput = {
    openingCash?: SortOrder
    cashIn?: SortOrder
    cashOut?: SortOrder
    closingCash?: SortOrder
    bankIn?: SortOrder
    posIn?: SortOrder
    totalSales?: SortOrder
    totalVat?: SortOrder
    totalGovFee?: SortOrder
  }

  export type EnumClosingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClosingStatus | EnumClosingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClosingStatus[] | ListEnumClosingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClosingStatus[] | ListEnumClosingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClosingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClosingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClosingStatusFilter<$PrismaModel>
    _max?: NestedEnumClosingStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumBranchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeFilter<$PrismaModel> | $Enums.BranchType
  }

  export type LedgerTransactionListRelationFilter = {
    every?: LedgerTransactionWhereInput
    some?: LedgerTransactionWhereInput
    none?: LedgerTransactionWhereInput
  }

  export type LedgerTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: SortOrder
    allowCrossBranch?: SortOrder
    cashCounterEnabled?: SortOrder
    email?: SortOrder
    emirate?: SortOrder
    googleMapLink?: SortOrder
    invoicePrefix?: SortOrder
    managerId?: SortOrder
    nextInvoiceNumber?: SortOrder
    openingCashBalance?: SortOrder
    receiptPrefix?: SortOrder
    separateNumbering?: SortOrder
    type?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    nextInvoiceNumber?: SortOrder
    openingCashBalance?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: SortOrder
    allowCrossBranch?: SortOrder
    cashCounterEnabled?: SortOrder
    email?: SortOrder
    emirate?: SortOrder
    googleMapLink?: SortOrder
    invoicePrefix?: SortOrder
    managerId?: SortOrder
    nextInvoiceNumber?: SortOrder
    openingCashBalance?: SortOrder
    receiptPrefix?: SortOrder
    separateNumbering?: SortOrder
    type?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    location?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: SortOrder
    allowCrossBranch?: SortOrder
    cashCounterEnabled?: SortOrder
    email?: SortOrder
    emirate?: SortOrder
    googleMapLink?: SortOrder
    invoicePrefix?: SortOrder
    managerId?: SortOrder
    nextInvoiceNumber?: SortOrder
    openingCashBalance?: SortOrder
    receiptPrefix?: SortOrder
    separateNumbering?: SortOrder
    type?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    nextInvoiceNumber?: SortOrder
    openingCashBalance?: SortOrder
  }

  export type EnumBranchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel> | $Enums.BranchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBranchTypeFilter<$PrismaModel>
    _max?: NestedEnumBranchTypeFilter<$PrismaModel>
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionModuleActionCompoundUniqueInput = {
    module: string
    action: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    module?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumUserRole_LegacyFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole_Legacy | EnumUserRole_LegacyFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole_Legacy[] | ListEnumUserRole_LegacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole_Legacy[] | ListEnumUserRole_LegacyFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRole_LegacyFilter<$PrismaModel> | $Enums.UserRole_Legacy
  }

  export type ApprovalRequestListRelationFilter = {
    every?: ApprovalRequestWhereInput
    some?: ApprovalRequestWhereInput
    none?: ApprovalRequestWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type ApprovalRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    forcePasswordChange?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    lastLoginUserAgent?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    failedLoginResetAt?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    forcePasswordChange?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    lastLoginUserAgent?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    failedLoginResetAt?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    forcePasswordChange?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    lastLoginUserAgent?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    failedLoginResetAt?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
  }

  export type EnumUserRole_LegacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole_Legacy | EnumUserRole_LegacyFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole_Legacy[] | ListEnumUserRole_LegacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole_Legacy[] | ListEnumUserRole_LegacyFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRole_LegacyWithAggregatesFilter<$PrismaModel> | $Enums.UserRole_Legacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRole_LegacyFilter<$PrismaModel>
    _max?: NestedEnumUserRole_LegacyFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    isValid?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    isValid?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    isValid?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    recordId?: SortOrder
    recordType?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    recordId?: SortOrder
    recordType?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    recordId?: SortOrder
    recordType?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type ApprovalRequestCountOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    module?: SortOrder
    action?: SortOrder
    recordId?: SortOrder
    recordType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    module?: SortOrder
    action?: SortOrder
    recordId?: SortOrder
    recordType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalRequestMinOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    approverId?: SortOrder
    module?: SortOrder
    action?: SortOrder
    recordId?: SortOrder
    recordType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type FinancialPeriodCompanyIdYearMonthCompoundUniqueInput = {
    companyId: string
    year: number
    month: number
  }

  export type FinancialPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingLocked?: SortOrder
    accountingLockedAt?: SortOrder
    accountingLockedById?: SortOrder
    isYearEndClosed?: SortOrder
    lastUnlockReason?: SortOrder
    lastUnlockedAt?: SortOrder
    lastUnlockedById?: SortOrder
    periodEnd?: SortOrder
    periodStart?: SortOrder
    vatLocked?: SortOrder
    vatLockedAt?: SortOrder
    vatLockedById?: SortOrder
    yearEndClosedAt?: SortOrder
    yearEndClosedById?: SortOrder
  }

  export type FinancialPeriodAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
  }

  export type FinancialPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingLocked?: SortOrder
    accountingLockedAt?: SortOrder
    accountingLockedById?: SortOrder
    isYearEndClosed?: SortOrder
    lastUnlockReason?: SortOrder
    lastUnlockedAt?: SortOrder
    lastUnlockedById?: SortOrder
    periodEnd?: SortOrder
    periodStart?: SortOrder
    vatLocked?: SortOrder
    vatLockedAt?: SortOrder
    vatLockedById?: SortOrder
    yearEndClosedAt?: SortOrder
    yearEndClosedById?: SortOrder
  }

  export type FinancialPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingLocked?: SortOrder
    accountingLockedAt?: SortOrder
    accountingLockedById?: SortOrder
    isYearEndClosed?: SortOrder
    lastUnlockReason?: SortOrder
    lastUnlockedAt?: SortOrder
    lastUnlockedById?: SortOrder
    periodEnd?: SortOrder
    periodStart?: SortOrder
    vatLocked?: SortOrder
    vatLockedAt?: SortOrder
    vatLockedById?: SortOrder
    yearEndClosedAt?: SortOrder
    yearEndClosedById?: SortOrder
  }

  export type FinancialPeriodSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type AccountNullableRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type QuotationNullableRelationFilter = {
    is?: QuotationWhereInput | null
    isNot?: QuotationWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    agentId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    paymentMethod?: SortOrder
    paymentRef?: SortOrder
    bankName?: SortOrder
    status?: SortOrder
    govtFeeAccountId?: SortOrder
    govtFeeRef?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    agentId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    paymentMethod?: SortOrder
    paymentRef?: SortOrder
    bankName?: SortOrder
    status?: SortOrder
    govtFeeAccountId?: SortOrder
    govtFeeRef?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    agentId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    paymentMethod?: SortOrder
    paymentRef?: SortOrder
    bankName?: SortOrder
    status?: SortOrder
    govtFeeAccountId?: SortOrder
    govtFeeRef?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumAdvanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvanceStatus | EnumAdvanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvanceStatus[] | ListEnumAdvanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvanceStatus[] | ListEnumAdvanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvanceStatusFilter<$PrismaModel> | $Enums.AdvanceStatus
  }

  export type BeneficiaryNullableRelationFilter = {
    is?: BeneficiaryWhereInput | null
    isNot?: BeneficiaryWhereInput | null
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PartnerNullableRelationFilter = {
    is?: PartnerWhereInput | null
    isNot?: PartnerWhereInput | null
  }

  export type WorkTypeNullableRelationFilter = {
    is?: WorkTypeWhereInput | null
    isNot?: WorkTypeWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    invoiceId?: SortOrder
    invNo?: SortOrder
    date?: SortOrder
    enteredById?: SortOrder
    beneficiaryId?: SortOrder
    partnerId?: SortOrder
    workTypeId?: SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    vat?: SortOrder
    total?: SortOrder
    type?: SortOrder
    receiptNo?: SortOrder
    govtFeeAccountId?: SortOrder
    govtFeeRef?: SortOrder
    paymentMethod?: SortOrder
    cardId?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    advanceStatus?: SortOrder
    advanceAmount?: SortOrder
    customerName?: SortOrder
    applicantName?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVatApplicable?: SortOrder
    vatRate?: SortOrder
    quantity?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    govFee?: SortOrder
    typingCharge?: SortOrder
    vat?: SortOrder
    total?: SortOrder
    advanceAmount?: SortOrder
    vatRate?: SortOrder
    quantity?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    invoiceId?: SortOrder
    invNo?: SortOrder
    date?: SortOrder
    enteredById?: SortOrder
    beneficiaryId?: SortOrder
    partnerId?: SortOrder
    workTypeId?: SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    vat?: SortOrder
    total?: SortOrder
    type?: SortOrder
    receiptNo?: SortOrder
    govtFeeAccountId?: SortOrder
    govtFeeRef?: SortOrder
    paymentMethod?: SortOrder
    cardId?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    advanceStatus?: SortOrder
    advanceAmount?: SortOrder
    customerName?: SortOrder
    applicantName?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVatApplicable?: SortOrder
    vatRate?: SortOrder
    quantity?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    invoiceId?: SortOrder
    invNo?: SortOrder
    date?: SortOrder
    enteredById?: SortOrder
    beneficiaryId?: SortOrder
    partnerId?: SortOrder
    workTypeId?: SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    vat?: SortOrder
    total?: SortOrder
    type?: SortOrder
    receiptNo?: SortOrder
    govtFeeAccountId?: SortOrder
    govtFeeRef?: SortOrder
    paymentMethod?: SortOrder
    cardId?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    advanceStatus?: SortOrder
    advanceAmount?: SortOrder
    customerName?: SortOrder
    applicantName?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVatApplicable?: SortOrder
    vatRate?: SortOrder
    quantity?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    govFee?: SortOrder
    typingCharge?: SortOrder
    vat?: SortOrder
    total?: SortOrder
    advanceAmount?: SortOrder
    vatRate?: SortOrder
    quantity?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumAdvanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvanceStatus | EnumAdvanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvanceStatus[] | ListEnumAdvanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvanceStatus[] | ListEnumAdvanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdvanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdvanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAdvanceStatusFilter<$PrismaModel>
  }

  export type QuotationItemListRelationFilter = {
    every?: QuotationItemWhereInput
    some?: QuotationItemWhereInput
    none?: QuotationItemWhereInput
  }

  export type QuotationItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkTypeCompanyIdDescriptionCompoundUniqueInput = {
    companyId: string
    description: string
  }

  export type WorkTypeCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    description?: SortOrder
    presetGovFee?: SortOrder
    presetTypingCharge?: SortOrder
    vatApplicable?: SortOrder
    vatRate?: SortOrder
  }

  export type WorkTypeAvgOrderByAggregateInput = {
    presetGovFee?: SortOrder
    presetTypingCharge?: SortOrder
    vatRate?: SortOrder
  }

  export type WorkTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    description?: SortOrder
    presetGovFee?: SortOrder
    presetTypingCharge?: SortOrder
    vatApplicable?: SortOrder
    vatRate?: SortOrder
  }

  export type WorkTypeMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    description?: SortOrder
    presetGovFee?: SortOrder
    presetTypingCharge?: SortOrder
    vatApplicable?: SortOrder
    vatRate?: SortOrder
  }

  export type WorkTypeSumOrderByAggregateInput = {
    presetGovFee?: SortOrder
    presetTypingCharge?: SortOrder
    vatRate?: SortOrder
  }

  export type BeneficiaryCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    details?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    partnerId?: SortOrder
  }

  export type BeneficiaryMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    details?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    partnerId?: SortOrder
  }

  export type BeneficiaryMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    details?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    partnerId?: SortOrder
  }

  export type EnumPartnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeFilter<$PrismaModel> | $Enums.PartnerType
  }

  export type PartnerCompanyIdNameCompoundUniqueInput = {
    companyId: string
    name: string
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type EnumPartnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerTypeFilter<$PrismaModel>
    _max?: NestedEnumPartnerTypeFilter<$PrismaModel>
  }

  export type ExpenseCategoryRelationFilter = {
    is?: ExpenseCategoryWhereInput
    isNot?: ExpenseCategoryWhereInput
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    categoryId?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    categoryId?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    categoryId?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type VoucherItemListRelationFilter = {
    every?: VoucherItemWhereInput
    some?: VoucherItemWhereInput
    none?: VoucherItemWhereInput
  }

  export type VoucherItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseCategoryCompanyIdNameCompoundUniqueInput = {
    companyId: string
    name: string
  }

  export type ExpenseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ledgerAccountId?: SortOrder
  }

  export type ExpenseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ledgerAccountId?: SortOrder
  }

  export type ExpenseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ledgerAccountId?: SortOrder
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type EnumAccountCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountCategory | EnumAccountCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AccountCategory[] | ListEnumAccountCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountCategory[] | ListEnumAccountCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountCategoryFilter<$PrismaModel> | $Enums.AccountCategory
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AccountCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    branchId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    iban?: SortOrder
    isPostable?: SortOrder
    isSystem?: SortOrder
    linkedBranchIds?: SortOrder
    merchantId?: SortOrder
    parentAccountId?: SortOrder
    swiftCode?: SortOrder
    terminalId?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    branchId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    iban?: SortOrder
    isPostable?: SortOrder
    isSystem?: SortOrder
    merchantId?: SortOrder
    parentAccountId?: SortOrder
    swiftCode?: SortOrder
    terminalId?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    branchId?: SortOrder
    category?: SortOrder
    code?: SortOrder
    iban?: SortOrder
    isPostable?: SortOrder
    isSystem?: SortOrder
    merchantId?: SortOrder
    parentAccountId?: SortOrder
    swiftCode?: SortOrder
    terminalId?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumAccountCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountCategory | EnumAccountCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AccountCategory[] | ListEnumAccountCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountCategory[] | ListEnumAccountCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AccountCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountCategoryFilter<$PrismaModel>
    _max?: NestedEnumAccountCategoryFilter<$PrismaModel>
  }

  export type EnumJournalEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalEntryType | EnumJournalEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalEntryType[] | ListEnumJournalEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalEntryType[] | ListEnumJournalEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalEntryTypeFilter<$PrismaModel> | $Enums.JournalEntryType
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    postingDate?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    type?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    reversedEntryId?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    postingDate?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    type?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    reversedEntryId?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    postingDate?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    type?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    reversedEntryId?: SortOrder
  }

  export type EnumJournalEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalEntryType | EnumJournalEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalEntryType[] | ListEnumJournalEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalEntryType[] | ListEnumJournalEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.JournalEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumJournalEntryTypeFilter<$PrismaModel>
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type JournalEntryRelationFilter = {
    is?: JournalEntryWhereInput
    isNot?: JournalEntryWhereInput
  }

  export type BusinessCardNullableRelationFilter = {
    is?: BusinessCardWhereInput | null
    isNot?: BusinessCardWhereInput | null
  }

  export type LedgerTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    partnerId?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    cardId?: SortOrder
  }

  export type LedgerTransactionAvgOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type LedgerTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    partnerId?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    cardId?: SortOrder
  }

  export type LedgerTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    journalEntryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    partnerId?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    cardId?: SortOrder
  }

  export type LedgerTransactionSumOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type EnumVoucherStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherStatus | EnumVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherStatusFilter<$PrismaModel> | $Enums.VoucherStatus
  }

  export type EnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type VendorNullableRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    voucherNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    description?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    type?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billUrl?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    description?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    type?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billUrl?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    voucherNo?: SortOrder
    date?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    description?: SortOrder
    vendorId?: SortOrder
    vendorName?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    type?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billUrl?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    total?: SortOrder
    paidAmount?: SortOrder
    balance?: SortOrder
  }

  export type EnumVoucherStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherStatus | EnumVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherStatusWithAggregatesFilter<$PrismaModel> | $Enums.VoucherStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherStatusFilter<$PrismaModel>
    _max?: NestedEnumVoucherStatusFilter<$PrismaModel>
  }

  export type EnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type VoucherRelationFilter = {
    is?: VoucherWhereInput
    isNot?: VoucherWhereInput
  }

  export type VoucherItemCountOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    categoryId?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    isVatApplicable?: SortOrder
    vatAmount?: SortOrder
    vatRate?: SortOrder
  }

  export type VoucherItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    amount?: SortOrder
    vatAmount?: SortOrder
    vatRate?: SortOrder
  }

  export type VoucherItemMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    categoryId?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    isVatApplicable?: SortOrder
    vatAmount?: SortOrder
    vatRate?: SortOrder
  }

  export type VoucherItemMinOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    categoryId?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    isVatApplicable?: SortOrder
    vatAmount?: SortOrder
    vatRate?: SortOrder
  }

  export type VoucherItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    amount?: SortOrder
    vatAmount?: SortOrder
    vatRate?: SortOrder
  }

  export type VendorCompanyIdNameCompoundUniqueInput = {
    companyId: string
    name: string
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherPaymentCompanyIdReceiptNoCompoundUniqueInput = {
    companyId: string
    receiptNo: string
  }

  export type VoucherPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    receiptNo?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type VoucherPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type VoucherPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    receiptNo?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type VoucherPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    accountId?: SortOrder
    receiptNo?: SortOrder
    enteredById?: SortOrder
    createdAt?: SortOrder
    companyId?: SortOrder
  }

  export type VoucherPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CardType | EnumCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCardTypeFilter<$PrismaModel> | $Enums.CardType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BusinessCardCompanyIdLedgerAccountIdCompoundUniqueInput = {
    companyId: string
    ledgerAccountId: string
  }

  export type BusinessCardCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    issuingBank?: SortOrder
    last4Digits?: SortOrder
    creditLimit?: SortOrder
    currency?: SortOrder
    statementCycleDay?: SortOrder
    paymentDueDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ledgerAccountId?: SortOrder
  }

  export type BusinessCardAvgOrderByAggregateInput = {
    creditLimit?: SortOrder
    statementCycleDay?: SortOrder
    paymentDueDays?: SortOrder
  }

  export type BusinessCardMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    issuingBank?: SortOrder
    last4Digits?: SortOrder
    creditLimit?: SortOrder
    currency?: SortOrder
    statementCycleDay?: SortOrder
    paymentDueDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ledgerAccountId?: SortOrder
  }

  export type BusinessCardMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    issuingBank?: SortOrder
    last4Digits?: SortOrder
    creditLimit?: SortOrder
    currency?: SortOrder
    statementCycleDay?: SortOrder
    paymentDueDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ledgerAccountId?: SortOrder
  }

  export type BusinessCardSumOrderByAggregateInput = {
    creditLimit?: SortOrder
    statementCycleDay?: SortOrder
    paymentDueDays?: SortOrder
  }

  export type EnumCardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardType | EnumCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCardTypeWithAggregatesFilter<$PrismaModel> | $Enums.CardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardTypeFilter<$PrismaModel>
    _max?: NestedEnumCardTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumQuotationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusFilter<$PrismaModel> | $Enums.QuotationStatus
  }

  export type QuotationCountOrderByAggregateInput = {
    id?: SortOrder
    quotationNo?: SortOrder
    date?: SortOrder
    validUntil?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    partnerId?: SortOrder
    beneficiaryName?: SortOrder
    salespersonId?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    totalGovFee?: SortOrder
    totalTax?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrder
    termsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
    acceptedAt?: SortOrder
    convertedAt?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    invoicedAmount?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuotationAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    totalGovFee?: SortOrder
    totalTax?: SortOrder
    grandTotal?: SortOrder
    invoicedAmount?: SortOrder
  }

  export type QuotationMaxOrderByAggregateInput = {
    id?: SortOrder
    quotationNo?: SortOrder
    date?: SortOrder
    validUntil?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    partnerId?: SortOrder
    beneficiaryName?: SortOrder
    salespersonId?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    totalGovFee?: SortOrder
    totalTax?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrder
    termsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
    acceptedAt?: SortOrder
    convertedAt?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    invoicedAmount?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuotationMinOrderByAggregateInput = {
    id?: SortOrder
    quotationNo?: SortOrder
    date?: SortOrder
    validUntil?: SortOrder
    companyId?: SortOrder
    branchId?: SortOrder
    partnerId?: SortOrder
    beneficiaryName?: SortOrder
    salespersonId?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    totalGovFee?: SortOrder
    totalTax?: SortOrder
    grandTotal?: SortOrder
    notes?: SortOrder
    termsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
    acceptedAt?: SortOrder
    convertedAt?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    invoicedAmount?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuotationSumOrderByAggregateInput = {
    subtotal?: SortOrder
    totalGovFee?: SortOrder
    totalTax?: SortOrder
    grandTotal?: SortOrder
    invoicedAmount?: SortOrder
  }

  export type EnumQuotationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationStatusFilter<$PrismaModel>
  }

  export type QuotationRelationFilter = {
    is?: QuotationWhereInput
    isNot?: QuotationWhereInput
  }

  export type QuotationItemCountOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    workTypeId?: SortOrder
    description?: SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    isVatApplicable?: SortOrder
    quantity?: SortOrder
  }

  export type QuotationItemAvgOrderByAggregateInput = {
    govFee?: SortOrder
    typingCharge?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    quantity?: SortOrder
  }

  export type QuotationItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    workTypeId?: SortOrder
    description?: SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    isVatApplicable?: SortOrder
    quantity?: SortOrder
  }

  export type QuotationItemMinOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    workTypeId?: SortOrder
    description?: SortOrder
    govFee?: SortOrder
    typingCharge?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    isVatApplicable?: SortOrder
    quantity?: SortOrder
  }

  export type QuotationItemSumOrderByAggregateInput = {
    govFee?: SortOrder
    typingCharge?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    quantity?: SortOrder
  }

  export type AccountCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BeneficiaryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BeneficiaryCreateWithoutCompanyInput, BeneficiaryUncheckedCreateWithoutCompanyInput> | BeneficiaryCreateWithoutCompanyInput[] | BeneficiaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCompanyInput | BeneficiaryCreateOrConnectWithoutCompanyInput[]
    createMany?: BeneficiaryCreateManyCompanyInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type BranchCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type DailyClosingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DailyClosingCreateWithoutCompanyInput, DailyClosingUncheckedCreateWithoutCompanyInput> | DailyClosingCreateWithoutCompanyInput[] | DailyClosingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutCompanyInput | DailyClosingCreateOrConnectWithoutCompanyInput[]
    createMany?: DailyClosingCreateManyCompanyInputEnvelope
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseCategoryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput> | ExpenseCategoryCreateWithoutCompanyInput[] | ExpenseCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutCompanyInput | ExpenseCategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCategoryCreateManyCompanyInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type FinancialPeriodCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput> | FinancialPeriodCreateWithoutCompanyInput[] | FinancialPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutCompanyInput | FinancialPeriodCreateOrConnectWithoutCompanyInput[]
    createMany?: FinancialPeriodCreateManyCompanyInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type JournalEntryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type PartnerCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PartnerCreateWithoutCompanyInput, PartnerUncheckedCreateWithoutCompanyInput> | PartnerCreateWithoutCompanyInput[] | PartnerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutCompanyInput | PartnerCreateOrConnectWithoutCompanyInput[]
    createMany?: PartnerCreateManyCompanyInputEnvelope
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput> | TransactionCreateWithoutCompanyInput[] | TransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCompanyInput | TransactionCreateOrConnectWithoutCompanyInput[]
    createMany?: TransactionCreateManyCompanyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VendorCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type VoucherCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput> | VoucherCreateWithoutCompanyInput[] | VoucherUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutCompanyInput | VoucherCreateOrConnectWithoutCompanyInput[]
    createMany?: VoucherCreateManyCompanyInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type VoucherPaymentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VoucherPaymentCreateWithoutCompanyInput, VoucherPaymentUncheckedCreateWithoutCompanyInput> | VoucherPaymentCreateWithoutCompanyInput[] | VoucherPaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutCompanyInput | VoucherPaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: VoucherPaymentCreateManyCompanyInputEnvelope
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
  }

  export type WorkTypeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WorkTypeCreateWithoutCompanyInput, WorkTypeUncheckedCreateWithoutCompanyInput> | WorkTypeCreateWithoutCompanyInput[] | WorkTypeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkTypeCreateOrConnectWithoutCompanyInput | WorkTypeCreateOrConnectWithoutCompanyInput[]
    createMany?: WorkTypeCreateManyCompanyInputEnvelope
    connect?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
  }

  export type BusinessCardCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BusinessCardCreateWithoutCompanyInput, BusinessCardUncheckedCreateWithoutCompanyInput> | BusinessCardCreateWithoutCompanyInput[] | BusinessCardUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BusinessCardCreateOrConnectWithoutCompanyInput | BusinessCardCreateOrConnectWithoutCompanyInput[]
    createMany?: BusinessCardCreateManyCompanyInputEnvelope
    connect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QuotationCreateWithoutCompanyInput, QuotationUncheckedCreateWithoutCompanyInput> | QuotationCreateWithoutCompanyInput[] | QuotationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutCompanyInput | QuotationCreateOrConnectWithoutCompanyInput[]
    createMany?: QuotationCreateManyCompanyInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BeneficiaryCreateWithoutCompanyInput, BeneficiaryUncheckedCreateWithoutCompanyInput> | BeneficiaryCreateWithoutCompanyInput[] | BeneficiaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCompanyInput | BeneficiaryCreateOrConnectWithoutCompanyInput[]
    createMany?: BeneficiaryCreateManyCompanyInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type DailyClosingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DailyClosingCreateWithoutCompanyInput, DailyClosingUncheckedCreateWithoutCompanyInput> | DailyClosingCreateWithoutCompanyInput[] | DailyClosingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutCompanyInput | DailyClosingCreateOrConnectWithoutCompanyInput[]
    createMany?: DailyClosingCreateManyCompanyInputEnvelope
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput> | ExpenseCategoryCreateWithoutCompanyInput[] | ExpenseCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutCompanyInput | ExpenseCategoryCreateOrConnectWithoutCompanyInput[]
    createMany?: ExpenseCategoryCreateManyCompanyInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput> | FinancialPeriodCreateWithoutCompanyInput[] | FinancialPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutCompanyInput | FinancialPeriodCreateOrConnectWithoutCompanyInput[]
    createMany?: FinancialPeriodCreateManyCompanyInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type PartnerUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PartnerCreateWithoutCompanyInput, PartnerUncheckedCreateWithoutCompanyInput> | PartnerCreateWithoutCompanyInput[] | PartnerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutCompanyInput | PartnerCreateOrConnectWithoutCompanyInput[]
    createMany?: PartnerCreateManyCompanyInputEnvelope
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput> | TransactionCreateWithoutCompanyInput[] | TransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCompanyInput | TransactionCreateOrConnectWithoutCompanyInput[]
    createMany?: TransactionCreateManyCompanyInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput> | VoucherCreateWithoutCompanyInput[] | VoucherUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutCompanyInput | VoucherCreateOrConnectWithoutCompanyInput[]
    createMany?: VoucherCreateManyCompanyInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VoucherPaymentCreateWithoutCompanyInput, VoucherPaymentUncheckedCreateWithoutCompanyInput> | VoucherPaymentCreateWithoutCompanyInput[] | VoucherPaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutCompanyInput | VoucherPaymentCreateOrConnectWithoutCompanyInput[]
    createMany?: VoucherPaymentCreateManyCompanyInputEnvelope
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
  }

  export type WorkTypeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WorkTypeCreateWithoutCompanyInput, WorkTypeUncheckedCreateWithoutCompanyInput> | WorkTypeCreateWithoutCompanyInput[] | WorkTypeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkTypeCreateOrConnectWithoutCompanyInput | WorkTypeCreateOrConnectWithoutCompanyInput[]
    createMany?: WorkTypeCreateManyCompanyInputEnvelope
    connect?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
  }

  export type BusinessCardUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BusinessCardCreateWithoutCompanyInput, BusinessCardUncheckedCreateWithoutCompanyInput> | BusinessCardCreateWithoutCompanyInput[] | BusinessCardUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BusinessCardCreateOrConnectWithoutCompanyInput | BusinessCardCreateOrConnectWithoutCompanyInput[]
    createMany?: BusinessCardCreateManyCompanyInputEnvelope
    connect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QuotationCreateWithoutCompanyInput, QuotationUncheckedCreateWithoutCompanyInput> | QuotationCreateWithoutCompanyInput[] | QuotationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutCompanyInput | QuotationCreateOrConnectWithoutCompanyInput[]
    createMany?: QuotationCreateManyCompanyInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumAccountingMethodFieldUpdateOperationsInput = {
    set?: $Enums.AccountingMethod
  }

  export type EnumAccountingModelFieldUpdateOperationsInput = {
    set?: $Enums.AccountingModel
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumEmirateFieldUpdateOperationsInput = {
    set?: $Enums.Emirate
  }

  export type EnumLegalTypeFieldUpdateOperationsInput = {
    set?: $Enums.LegalType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVatFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.VatFrequency
  }

  export type AccountUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCompanyInput | AccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCompanyInput | AccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCompanyInput | AccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BeneficiaryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutCompanyInput, BeneficiaryUncheckedCreateWithoutCompanyInput> | BeneficiaryCreateWithoutCompanyInput[] | BeneficiaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCompanyInput | BeneficiaryCreateOrConnectWithoutCompanyInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutCompanyInput | BeneficiaryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BeneficiaryCreateManyCompanyInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutCompanyInput | BeneficiaryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutCompanyInput | BeneficiaryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type BranchUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutCompanyInput | BranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutCompanyInput | BranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutCompanyInput | BranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type DailyClosingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DailyClosingCreateWithoutCompanyInput, DailyClosingUncheckedCreateWithoutCompanyInput> | DailyClosingCreateWithoutCompanyInput[] | DailyClosingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutCompanyInput | DailyClosingCreateOrConnectWithoutCompanyInput[]
    upsert?: DailyClosingUpsertWithWhereUniqueWithoutCompanyInput | DailyClosingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DailyClosingCreateManyCompanyInputEnvelope
    set?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    disconnect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    delete?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    update?: DailyClosingUpdateWithWhereUniqueWithoutCompanyInput | DailyClosingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DailyClosingUpdateManyWithWhereWithoutCompanyInput | DailyClosingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DailyClosingScalarWhereInput | DailyClosingScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCompanyInput | ExpenseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCompanyInput | ExpenseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCompanyInput | ExpenseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseCategoryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput> | ExpenseCategoryCreateWithoutCompanyInput[] | ExpenseCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutCompanyInput | ExpenseCategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput | ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCategoryCreateManyCompanyInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput | ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput | ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type FinancialPeriodUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput> | FinancialPeriodCreateWithoutCompanyInput[] | FinancialPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutCompanyInput | FinancialPeriodCreateOrConnectWithoutCompanyInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput | FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FinancialPeriodCreateManyCompanyInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput | FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutCompanyInput | FinancialPeriodUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCompanyInput | InvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCompanyInput | InvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCompanyInput | InvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type JournalEntryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutCompanyInput | JournalEntryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutCompanyInput | JournalEntryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutCompanyInput | JournalEntryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type PartnerUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PartnerCreateWithoutCompanyInput, PartnerUncheckedCreateWithoutCompanyInput> | PartnerCreateWithoutCompanyInput[] | PartnerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutCompanyInput | PartnerCreateOrConnectWithoutCompanyInput[]
    upsert?: PartnerUpsertWithWhereUniqueWithoutCompanyInput | PartnerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PartnerCreateManyCompanyInputEnvelope
    set?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    disconnect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    delete?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    update?: PartnerUpdateWithWhereUniqueWithoutCompanyInput | PartnerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PartnerUpdateManyWithWhereWithoutCompanyInput | PartnerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput> | TransactionCreateWithoutCompanyInput[] | TransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCompanyInput | TransactionCreateOrConnectWithoutCompanyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCompanyInput | TransactionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransactionCreateManyCompanyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCompanyInput | TransactionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCompanyInput | TransactionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VendorUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutCompanyInput | VendorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutCompanyInput | VendorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutCompanyInput | VendorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type VoucherUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput> | VoucherCreateWithoutCompanyInput[] | VoucherUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutCompanyInput | VoucherCreateOrConnectWithoutCompanyInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutCompanyInput | VoucherUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VoucherCreateManyCompanyInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutCompanyInput | VoucherUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutCompanyInput | VoucherUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type VoucherPaymentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VoucherPaymentCreateWithoutCompanyInput, VoucherPaymentUncheckedCreateWithoutCompanyInput> | VoucherPaymentCreateWithoutCompanyInput[] | VoucherPaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutCompanyInput | VoucherPaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: VoucherPaymentUpsertWithWhereUniqueWithoutCompanyInput | VoucherPaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VoucherPaymentCreateManyCompanyInputEnvelope
    set?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    disconnect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    delete?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    update?: VoucherPaymentUpdateWithWhereUniqueWithoutCompanyInput | VoucherPaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VoucherPaymentUpdateManyWithWhereWithoutCompanyInput | VoucherPaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
  }

  export type WorkTypeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WorkTypeCreateWithoutCompanyInput, WorkTypeUncheckedCreateWithoutCompanyInput> | WorkTypeCreateWithoutCompanyInput[] | WorkTypeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkTypeCreateOrConnectWithoutCompanyInput | WorkTypeCreateOrConnectWithoutCompanyInput[]
    upsert?: WorkTypeUpsertWithWhereUniqueWithoutCompanyInput | WorkTypeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WorkTypeCreateManyCompanyInputEnvelope
    set?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
    disconnect?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
    delete?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
    connect?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
    update?: WorkTypeUpdateWithWhereUniqueWithoutCompanyInput | WorkTypeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WorkTypeUpdateManyWithWhereWithoutCompanyInput | WorkTypeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WorkTypeScalarWhereInput | WorkTypeScalarWhereInput[]
  }

  export type BusinessCardUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BusinessCardCreateWithoutCompanyInput, BusinessCardUncheckedCreateWithoutCompanyInput> | BusinessCardCreateWithoutCompanyInput[] | BusinessCardUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BusinessCardCreateOrConnectWithoutCompanyInput | BusinessCardCreateOrConnectWithoutCompanyInput[]
    upsert?: BusinessCardUpsertWithWhereUniqueWithoutCompanyInput | BusinessCardUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BusinessCardCreateManyCompanyInputEnvelope
    set?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    disconnect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    delete?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    connect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    update?: BusinessCardUpdateWithWhereUniqueWithoutCompanyInput | BusinessCardUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BusinessCardUpdateManyWithWhereWithoutCompanyInput | BusinessCardUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BusinessCardScalarWhereInput | BusinessCardScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QuotationCreateWithoutCompanyInput, QuotationUncheckedCreateWithoutCompanyInput> | QuotationCreateWithoutCompanyInput[] | QuotationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutCompanyInput | QuotationCreateOrConnectWithoutCompanyInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutCompanyInput | QuotationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: QuotationCreateManyCompanyInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutCompanyInput | QuotationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutCompanyInput | QuotationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput> | AccountCreateWithoutCompanyInput[] | AccountUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCompanyInput | AccountCreateOrConnectWithoutCompanyInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCompanyInput | AccountUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AccountCreateManyCompanyInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCompanyInput | AccountUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCompanyInput | AccountUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutCompanyInput, BeneficiaryUncheckedCreateWithoutCompanyInput> | BeneficiaryCreateWithoutCompanyInput[] | BeneficiaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCompanyInput | BeneficiaryCreateOrConnectWithoutCompanyInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutCompanyInput | BeneficiaryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BeneficiaryCreateManyCompanyInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutCompanyInput | BeneficiaryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutCompanyInput | BeneficiaryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput> | BranchCreateWithoutCompanyInput[] | BranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutCompanyInput | BranchCreateOrConnectWithoutCompanyInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutCompanyInput | BranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BranchCreateManyCompanyInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutCompanyInput | BranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutCompanyInput | BranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DailyClosingCreateWithoutCompanyInput, DailyClosingUncheckedCreateWithoutCompanyInput> | DailyClosingCreateWithoutCompanyInput[] | DailyClosingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutCompanyInput | DailyClosingCreateOrConnectWithoutCompanyInput[]
    upsert?: DailyClosingUpsertWithWhereUniqueWithoutCompanyInput | DailyClosingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DailyClosingCreateManyCompanyInputEnvelope
    set?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    disconnect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    delete?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    update?: DailyClosingUpdateWithWhereUniqueWithoutCompanyInput | DailyClosingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DailyClosingUpdateManyWithWhereWithoutCompanyInput | DailyClosingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DailyClosingScalarWhereInput | DailyClosingScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput> | ExpenseCreateWithoutCompanyInput[] | ExpenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCompanyInput | ExpenseCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCompanyInput | ExpenseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCreateManyCompanyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCompanyInput | ExpenseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCompanyInput | ExpenseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput> | ExpenseCategoryCreateWithoutCompanyInput[] | ExpenseCategoryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutCompanyInput | ExpenseCategoryCreateOrConnectWithoutCompanyInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput | ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ExpenseCategoryCreateManyCompanyInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput | ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput | ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput> | FinancialPeriodCreateWithoutCompanyInput[] | FinancialPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutCompanyInput | FinancialPeriodCreateOrConnectWithoutCompanyInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput | FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FinancialPeriodCreateManyCompanyInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput | FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutCompanyInput | FinancialPeriodUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCompanyInput | InvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCompanyInput | InvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCompanyInput | InvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput> | JournalEntryCreateWithoutCompanyInput[] | JournalEntryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutCompanyInput | JournalEntryCreateOrConnectWithoutCompanyInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutCompanyInput | JournalEntryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JournalEntryCreateManyCompanyInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutCompanyInput | JournalEntryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutCompanyInput | JournalEntryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type PartnerUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PartnerCreateWithoutCompanyInput, PartnerUncheckedCreateWithoutCompanyInput> | PartnerCreateWithoutCompanyInput[] | PartnerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutCompanyInput | PartnerCreateOrConnectWithoutCompanyInput[]
    upsert?: PartnerUpsertWithWhereUniqueWithoutCompanyInput | PartnerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PartnerCreateManyCompanyInputEnvelope
    set?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    disconnect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    delete?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    update?: PartnerUpdateWithWhereUniqueWithoutCompanyInput | PartnerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PartnerUpdateManyWithWhereWithoutCompanyInput | PartnerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput> | TransactionCreateWithoutCompanyInput[] | TransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCompanyInput | TransactionCreateOrConnectWithoutCompanyInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCompanyInput | TransactionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransactionCreateManyCompanyInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCompanyInput | TransactionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCompanyInput | TransactionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutCompanyInput | VendorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutCompanyInput | VendorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutCompanyInput | VendorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput> | VoucherCreateWithoutCompanyInput[] | VoucherUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutCompanyInput | VoucherCreateOrConnectWithoutCompanyInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutCompanyInput | VoucherUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VoucherCreateManyCompanyInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutCompanyInput | VoucherUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutCompanyInput | VoucherUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VoucherPaymentCreateWithoutCompanyInput, VoucherPaymentUncheckedCreateWithoutCompanyInput> | VoucherPaymentCreateWithoutCompanyInput[] | VoucherPaymentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutCompanyInput | VoucherPaymentCreateOrConnectWithoutCompanyInput[]
    upsert?: VoucherPaymentUpsertWithWhereUniqueWithoutCompanyInput | VoucherPaymentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VoucherPaymentCreateManyCompanyInputEnvelope
    set?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    disconnect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    delete?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    update?: VoucherPaymentUpdateWithWhereUniqueWithoutCompanyInput | VoucherPaymentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VoucherPaymentUpdateManyWithWhereWithoutCompanyInput | VoucherPaymentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
  }

  export type WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WorkTypeCreateWithoutCompanyInput, WorkTypeUncheckedCreateWithoutCompanyInput> | WorkTypeCreateWithoutCompanyInput[] | WorkTypeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkTypeCreateOrConnectWithoutCompanyInput | WorkTypeCreateOrConnectWithoutCompanyInput[]
    upsert?: WorkTypeUpsertWithWhereUniqueWithoutCompanyInput | WorkTypeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WorkTypeCreateManyCompanyInputEnvelope
    set?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
    disconnect?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
    delete?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
    connect?: WorkTypeWhereUniqueInput | WorkTypeWhereUniqueInput[]
    update?: WorkTypeUpdateWithWhereUniqueWithoutCompanyInput | WorkTypeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WorkTypeUpdateManyWithWhereWithoutCompanyInput | WorkTypeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WorkTypeScalarWhereInput | WorkTypeScalarWhereInput[]
  }

  export type BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BusinessCardCreateWithoutCompanyInput, BusinessCardUncheckedCreateWithoutCompanyInput> | BusinessCardCreateWithoutCompanyInput[] | BusinessCardUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BusinessCardCreateOrConnectWithoutCompanyInput | BusinessCardCreateOrConnectWithoutCompanyInput[]
    upsert?: BusinessCardUpsertWithWhereUniqueWithoutCompanyInput | BusinessCardUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BusinessCardCreateManyCompanyInputEnvelope
    set?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    disconnect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    delete?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    connect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    update?: BusinessCardUpdateWithWhereUniqueWithoutCompanyInput | BusinessCardUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BusinessCardUpdateManyWithWhereWithoutCompanyInput | BusinessCardUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BusinessCardScalarWhereInput | BusinessCardScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QuotationCreateWithoutCompanyInput, QuotationUncheckedCreateWithoutCompanyInput> | QuotationCreateWithoutCompanyInput[] | QuotationUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutCompanyInput | QuotationCreateOrConnectWithoutCompanyInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutCompanyInput | QuotationUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: QuotationCreateManyCompanyInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutCompanyInput | QuotationUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutCompanyInput | QuotationUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutDailyClosingsInput = {
    create?: XOR<BranchCreateWithoutDailyClosingsInput, BranchUncheckedCreateWithoutDailyClosingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDailyClosingsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDailyClosingsInput = {
    create?: XOR<UserCreateWithoutDailyClosingsInput, UserUncheckedCreateWithoutDailyClosingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyClosingsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutDailyClosingsInput = {
    create?: XOR<CompanyCreateWithoutDailyClosingsInput, CompanyUncheckedCreateWithoutDailyClosingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDailyClosingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumClosingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClosingStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BranchUpdateOneRequiredWithoutDailyClosingsNestedInput = {
    create?: XOR<BranchCreateWithoutDailyClosingsInput, BranchUncheckedCreateWithoutDailyClosingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDailyClosingsInput
    upsert?: BranchUpsertWithoutDailyClosingsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDailyClosingsInput, BranchUpdateWithoutDailyClosingsInput>, BranchUncheckedUpdateWithoutDailyClosingsInput>
  }

  export type UserUpdateOneWithoutDailyClosingsNestedInput = {
    create?: XOR<UserCreateWithoutDailyClosingsInput, UserUncheckedCreateWithoutDailyClosingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyClosingsInput
    upsert?: UserUpsertWithoutDailyClosingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyClosingsInput, UserUpdateWithoutDailyClosingsInput>, UserUncheckedUpdateWithoutDailyClosingsInput>
  }

  export type CompanyUpdateOneRequiredWithoutDailyClosingsNestedInput = {
    create?: XOR<CompanyCreateWithoutDailyClosingsInput, CompanyUncheckedCreateWithoutDailyClosingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDailyClosingsInput
    upsert?: CompanyUpsertWithoutDailyClosingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDailyClosingsInput, CompanyUpdateWithoutDailyClosingsInput>, CompanyUncheckedUpdateWithoutDailyClosingsInput>
  }

  export type CompanyCreateNestedOneWithoutBranchesInput = {
    create?: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBranchesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedBranchesInput = {
    create?: XOR<UserCreateWithoutManagedBranchesInput, UserUncheckedCreateWithoutManagedBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type DailyClosingCreateNestedManyWithoutBranchInput = {
    create?: XOR<DailyClosingCreateWithoutBranchInput, DailyClosingUncheckedCreateWithoutBranchInput> | DailyClosingCreateWithoutBranchInput[] | DailyClosingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutBranchInput | DailyClosingCreateOrConnectWithoutBranchInput[]
    createMany?: DailyClosingCreateManyBranchInputEnvelope
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutBranchInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    createMany?: ExpenseCreateManyBranchInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutBranchInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type JournalEntryCreateNestedManyWithoutBranchInput = {
    create?: XOR<JournalEntryCreateWithoutBranchInput, JournalEntryUncheckedCreateWithoutBranchInput> | JournalEntryCreateWithoutBranchInput[] | JournalEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutBranchInput | JournalEntryCreateOrConnectWithoutBranchInput[]
    createMany?: JournalEntryCreateManyBranchInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type LedgerTransactionCreateNestedManyWithoutBranchInput = {
    create?: XOR<LedgerTransactionCreateWithoutBranchInput, LedgerTransactionUncheckedCreateWithoutBranchInput> | LedgerTransactionCreateWithoutBranchInput[] | LedgerTransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutBranchInput | LedgerTransactionCreateOrConnectWithoutBranchInput[]
    createMany?: LedgerTransactionCreateManyBranchInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutBranchInput = {
    create?: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput> | TransactionCreateWithoutBranchInput[] | TransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBranchInput | TransactionCreateOrConnectWithoutBranchInput[]
    createMany?: TransactionCreateManyBranchInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VoucherCreateNestedManyWithoutBranchInput = {
    create?: XOR<VoucherCreateWithoutBranchInput, VoucherUncheckedCreateWithoutBranchInput> | VoucherCreateWithoutBranchInput[] | VoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutBranchInput | VoucherCreateOrConnectWithoutBranchInput[]
    createMany?: VoucherCreateManyBranchInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutBranchInput = {
    create?: XOR<QuotationCreateWithoutBranchInput, QuotationUncheckedCreateWithoutBranchInput> | QuotationCreateWithoutBranchInput[] | QuotationUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutBranchInput | QuotationCreateOrConnectWithoutBranchInput[]
    createMany?: QuotationCreateManyBranchInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type DailyClosingUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DailyClosingCreateWithoutBranchInput, DailyClosingUncheckedCreateWithoutBranchInput> | DailyClosingCreateWithoutBranchInput[] | DailyClosingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutBranchInput | DailyClosingCreateOrConnectWithoutBranchInput[]
    createMany?: DailyClosingCreateManyBranchInputEnvelope
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    createMany?: ExpenseCreateManyBranchInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<JournalEntryCreateWithoutBranchInput, JournalEntryUncheckedCreateWithoutBranchInput> | JournalEntryCreateWithoutBranchInput[] | JournalEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutBranchInput | JournalEntryCreateOrConnectWithoutBranchInput[]
    createMany?: JournalEntryCreateManyBranchInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<LedgerTransactionCreateWithoutBranchInput, LedgerTransactionUncheckedCreateWithoutBranchInput> | LedgerTransactionCreateWithoutBranchInput[] | LedgerTransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutBranchInput | LedgerTransactionCreateOrConnectWithoutBranchInput[]
    createMany?: LedgerTransactionCreateManyBranchInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput> | TransactionCreateWithoutBranchInput[] | TransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBranchInput | TransactionCreateOrConnectWithoutBranchInput[]
    createMany?: TransactionCreateManyBranchInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<VoucherCreateWithoutBranchInput, VoucherUncheckedCreateWithoutBranchInput> | VoucherCreateWithoutBranchInput[] | VoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutBranchInput | VoucherCreateOrConnectWithoutBranchInput[]
    createMany?: VoucherCreateManyBranchInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<QuotationCreateWithoutBranchInput, QuotationUncheckedCreateWithoutBranchInput> | QuotationCreateWithoutBranchInput[] | QuotationUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutBranchInput | QuotationCreateOrConnectWithoutBranchInput[]
    createMany?: QuotationCreateManyBranchInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type EnumBranchTypeFieldUpdateOperationsInput = {
    set?: $Enums.BranchType
  }

  export type CompanyUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBranchesInput
    upsert?: CompanyUpsertWithoutBranchesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBranchesInput, CompanyUpdateWithoutBranchesInput>, CompanyUncheckedUpdateWithoutBranchesInput>
  }

  export type UserUpdateOneWithoutManagedBranchesNestedInput = {
    create?: XOR<UserCreateWithoutManagedBranchesInput, UserUncheckedCreateWithoutManagedBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedBranchesInput
    upsert?: UserUpsertWithoutManagedBranchesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedBranchesInput, UserUpdateWithoutManagedBranchesInput>, UserUncheckedUpdateWithoutManagedBranchesInput>
  }

  export type DailyClosingUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DailyClosingCreateWithoutBranchInput, DailyClosingUncheckedCreateWithoutBranchInput> | DailyClosingCreateWithoutBranchInput[] | DailyClosingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutBranchInput | DailyClosingCreateOrConnectWithoutBranchInput[]
    upsert?: DailyClosingUpsertWithWhereUniqueWithoutBranchInput | DailyClosingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DailyClosingCreateManyBranchInputEnvelope
    set?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    disconnect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    delete?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    update?: DailyClosingUpdateWithWhereUniqueWithoutBranchInput | DailyClosingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DailyClosingUpdateManyWithWhereWithoutBranchInput | DailyClosingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DailyClosingScalarWhereInput | DailyClosingScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutBranchInput | ExpenseUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ExpenseCreateManyBranchInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutBranchInput | ExpenseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutBranchInput | ExpenseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutBranchInput | InvoiceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutBranchInput | InvoiceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutBranchInput | InvoiceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type JournalEntryUpdateManyWithoutBranchNestedInput = {
    create?: XOR<JournalEntryCreateWithoutBranchInput, JournalEntryUncheckedCreateWithoutBranchInput> | JournalEntryCreateWithoutBranchInput[] | JournalEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutBranchInput | JournalEntryCreateOrConnectWithoutBranchInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutBranchInput | JournalEntryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: JournalEntryCreateManyBranchInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutBranchInput | JournalEntryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutBranchInput | JournalEntryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type LedgerTransactionUpdateManyWithoutBranchNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutBranchInput, LedgerTransactionUncheckedCreateWithoutBranchInput> | LedgerTransactionCreateWithoutBranchInput[] | LedgerTransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutBranchInput | LedgerTransactionCreateOrConnectWithoutBranchInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutBranchInput | LedgerTransactionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: LedgerTransactionCreateManyBranchInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutBranchInput | LedgerTransactionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutBranchInput | LedgerTransactionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput> | TransactionCreateWithoutBranchInput[] | TransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBranchInput | TransactionCreateOrConnectWithoutBranchInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBranchInput | TransactionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TransactionCreateManyBranchInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBranchInput | TransactionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBranchInput | TransactionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VoucherUpdateManyWithoutBranchNestedInput = {
    create?: XOR<VoucherCreateWithoutBranchInput, VoucherUncheckedCreateWithoutBranchInput> | VoucherCreateWithoutBranchInput[] | VoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutBranchInput | VoucherCreateOrConnectWithoutBranchInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutBranchInput | VoucherUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: VoucherCreateManyBranchInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutBranchInput | VoucherUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutBranchInput | VoucherUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutBranchNestedInput = {
    create?: XOR<QuotationCreateWithoutBranchInput, QuotationUncheckedCreateWithoutBranchInput> | QuotationCreateWithoutBranchInput[] | QuotationUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutBranchInput | QuotationCreateOrConnectWithoutBranchInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutBranchInput | QuotationUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: QuotationCreateManyBranchInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutBranchInput | QuotationUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutBranchInput | QuotationUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type DailyClosingUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DailyClosingCreateWithoutBranchInput, DailyClosingUncheckedCreateWithoutBranchInput> | DailyClosingCreateWithoutBranchInput[] | DailyClosingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutBranchInput | DailyClosingCreateOrConnectWithoutBranchInput[]
    upsert?: DailyClosingUpsertWithWhereUniqueWithoutBranchInput | DailyClosingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DailyClosingCreateManyBranchInputEnvelope
    set?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    disconnect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    delete?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    update?: DailyClosingUpdateWithWhereUniqueWithoutBranchInput | DailyClosingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DailyClosingUpdateManyWithWhereWithoutBranchInput | DailyClosingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DailyClosingScalarWhereInput | DailyClosingScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput> | ExpenseCreateWithoutBranchInput[] | ExpenseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutBranchInput | ExpenseCreateOrConnectWithoutBranchInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutBranchInput | ExpenseUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ExpenseCreateManyBranchInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutBranchInput | ExpenseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutBranchInput | ExpenseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutBranchInput | InvoiceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutBranchInput | InvoiceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutBranchInput | InvoiceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type JournalEntryUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<JournalEntryCreateWithoutBranchInput, JournalEntryUncheckedCreateWithoutBranchInput> | JournalEntryCreateWithoutBranchInput[] | JournalEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutBranchInput | JournalEntryCreateOrConnectWithoutBranchInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutBranchInput | JournalEntryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: JournalEntryCreateManyBranchInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutBranchInput | JournalEntryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutBranchInput | JournalEntryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutBranchInput, LedgerTransactionUncheckedCreateWithoutBranchInput> | LedgerTransactionCreateWithoutBranchInput[] | LedgerTransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutBranchInput | LedgerTransactionCreateOrConnectWithoutBranchInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutBranchInput | LedgerTransactionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: LedgerTransactionCreateManyBranchInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutBranchInput | LedgerTransactionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutBranchInput | LedgerTransactionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput> | TransactionCreateWithoutBranchInput[] | TransactionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBranchInput | TransactionCreateOrConnectWithoutBranchInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBranchInput | TransactionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TransactionCreateManyBranchInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBranchInput | TransactionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBranchInput | TransactionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<VoucherCreateWithoutBranchInput, VoucherUncheckedCreateWithoutBranchInput> | VoucherCreateWithoutBranchInput[] | VoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutBranchInput | VoucherCreateOrConnectWithoutBranchInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutBranchInput | VoucherUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: VoucherCreateManyBranchInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutBranchInput | VoucherUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutBranchInput | VoucherUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<QuotationCreateWithoutBranchInput, QuotationUncheckedCreateWithoutBranchInput> | QuotationCreateWithoutBranchInput[] | QuotationUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutBranchInput | QuotationCreateOrConnectWithoutBranchInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutBranchInput | QuotationUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: QuotationCreateManyBranchInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutBranchInput | QuotationUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutBranchInput | QuotationUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type ApprovalRequestCreateNestedManyWithoutApproverInput = {
    create?: XOR<ApprovalRequestCreateWithoutApproverInput, ApprovalRequestUncheckedCreateWithoutApproverInput> | ApprovalRequestCreateWithoutApproverInput[] | ApprovalRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutApproverInput | ApprovalRequestCreateOrConnectWithoutApproverInput[]
    createMany?: ApprovalRequestCreateManyApproverInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput> | ApprovalRequestCreateWithoutRequesterInput[] | ApprovalRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequesterInput | ApprovalRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: ApprovalRequestCreateManyRequesterInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BranchCreateNestedManyWithoutManagerInput = {
    create?: XOR<BranchCreateWithoutManagerInput, BranchUncheckedCreateWithoutManagerInput> | BranchCreateWithoutManagerInput[] | BranchUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutManagerInput | BranchCreateOrConnectWithoutManagerInput[]
    createMany?: BranchCreateManyManagerInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type DailyClosingCreateNestedManyWithoutClosedByInput = {
    create?: XOR<DailyClosingCreateWithoutClosedByInput, DailyClosingUncheckedCreateWithoutClosedByInput> | DailyClosingCreateWithoutClosedByInput[] | DailyClosingUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutClosedByInput | DailyClosingCreateOrConnectWithoutClosedByInput[]
    createMany?: DailyClosingCreateManyClosedByInputEnvelope
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutEnteredByInput = {
    create?: XOR<ExpenseCreateWithoutEnteredByInput, ExpenseUncheckedCreateWithoutEnteredByInput> | ExpenseCreateWithoutEnteredByInput[] | ExpenseUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutEnteredByInput | ExpenseCreateOrConnectWithoutEnteredByInput[]
    createMany?: ExpenseCreateManyEnteredByInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput = {
    create?: XOR<FinancialPeriodCreateWithoutAccountingLockedByInput, FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput> | FinancialPeriodCreateWithoutAccountingLockedByInput[] | FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput | FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput[]
    createMany?: FinancialPeriodCreateManyAccountingLockedByInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput = {
    create?: XOR<FinancialPeriodCreateWithoutLastUnlockedByInput, FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput> | FinancialPeriodCreateWithoutLastUnlockedByInput[] | FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput | FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput[]
    createMany?: FinancialPeriodCreateManyLastUnlockedByInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type FinancialPeriodCreateNestedManyWithoutVatLockedByInput = {
    create?: XOR<FinancialPeriodCreateWithoutVatLockedByInput, FinancialPeriodUncheckedCreateWithoutVatLockedByInput> | FinancialPeriodCreateWithoutVatLockedByInput[] | FinancialPeriodUncheckedCreateWithoutVatLockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutVatLockedByInput | FinancialPeriodCreateOrConnectWithoutVatLockedByInput[]
    createMany?: FinancialPeriodCreateManyVatLockedByInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput = {
    create?: XOR<FinancialPeriodCreateWithoutYearEndClosedByInput, FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput> | FinancialPeriodCreateWithoutYearEndClosedByInput[] | FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput | FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput[]
    createMany?: FinancialPeriodCreateManyYearEndClosedByInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutAgentInput = {
    create?: XOR<InvoiceCreateWithoutAgentInput, InvoiceUncheckedCreateWithoutAgentInput> | InvoiceCreateWithoutAgentInput[] | InvoiceUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAgentInput | InvoiceCreateOrConnectWithoutAgentInput[]
    createMany?: InvoiceCreateManyAgentInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutEnteredByInput = {
    create?: XOR<TransactionCreateWithoutEnteredByInput, TransactionUncheckedCreateWithoutEnteredByInput> | TransactionCreateWithoutEnteredByInput[] | TransactionUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutEnteredByInput | TransactionCreateOrConnectWithoutEnteredByInput[]
    createMany?: TransactionCreateManyEnteredByInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type VoucherCreateNestedManyWithoutEnteredByInput = {
    create?: XOR<VoucherCreateWithoutEnteredByInput, VoucherUncheckedCreateWithoutEnteredByInput> | VoucherCreateWithoutEnteredByInput[] | VoucherUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutEnteredByInput | VoucherCreateOrConnectWithoutEnteredByInput[]
    createMany?: VoucherCreateManyEnteredByInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type VoucherPaymentCreateNestedManyWithoutEnteredByInput = {
    create?: XOR<VoucherPaymentCreateWithoutEnteredByInput, VoucherPaymentUncheckedCreateWithoutEnteredByInput> | VoucherPaymentCreateWithoutEnteredByInput[] | VoucherPaymentUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutEnteredByInput | VoucherPaymentCreateOrConnectWithoutEnteredByInput[]
    createMany?: VoucherPaymentCreateManyEnteredByInputEnvelope
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutSalespersonInput = {
    create?: XOR<QuotationCreateWithoutSalespersonInput, QuotationUncheckedCreateWithoutSalespersonInput> | QuotationCreateWithoutSalespersonInput[] | QuotationUncheckedCreateWithoutSalespersonInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutSalespersonInput | QuotationCreateOrConnectWithoutSalespersonInput[]
    createMany?: QuotationCreateManySalespersonInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput> | QuotationCreateWithoutApprovedByInput[] | QuotationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutApprovedByInput | QuotationCreateOrConnectWithoutApprovedByInput[]
    createMany?: QuotationCreateManyApprovedByInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ApprovalRequestCreateWithoutApproverInput, ApprovalRequestUncheckedCreateWithoutApproverInput> | ApprovalRequestCreateWithoutApproverInput[] | ApprovalRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutApproverInput | ApprovalRequestCreateOrConnectWithoutApproverInput[]
    createMany?: ApprovalRequestCreateManyApproverInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput> | ApprovalRequestCreateWithoutRequesterInput[] | ApprovalRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequesterInput | ApprovalRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: ApprovalRequestCreateManyRequesterInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<BranchCreateWithoutManagerInput, BranchUncheckedCreateWithoutManagerInput> | BranchCreateWithoutManagerInput[] | BranchUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutManagerInput | BranchCreateOrConnectWithoutManagerInput[]
    createMany?: BranchCreateManyManagerInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type DailyClosingUncheckedCreateNestedManyWithoutClosedByInput = {
    create?: XOR<DailyClosingCreateWithoutClosedByInput, DailyClosingUncheckedCreateWithoutClosedByInput> | DailyClosingCreateWithoutClosedByInput[] | DailyClosingUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutClosedByInput | DailyClosingCreateOrConnectWithoutClosedByInput[]
    createMany?: DailyClosingCreateManyClosedByInputEnvelope
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutEnteredByInput = {
    create?: XOR<ExpenseCreateWithoutEnteredByInput, ExpenseUncheckedCreateWithoutEnteredByInput> | ExpenseCreateWithoutEnteredByInput[] | ExpenseUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutEnteredByInput | ExpenseCreateOrConnectWithoutEnteredByInput[]
    createMany?: ExpenseCreateManyEnteredByInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput = {
    create?: XOR<FinancialPeriodCreateWithoutAccountingLockedByInput, FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput> | FinancialPeriodCreateWithoutAccountingLockedByInput[] | FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput | FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput[]
    createMany?: FinancialPeriodCreateManyAccountingLockedByInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput = {
    create?: XOR<FinancialPeriodCreateWithoutLastUnlockedByInput, FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput> | FinancialPeriodCreateWithoutLastUnlockedByInput[] | FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput | FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput[]
    createMany?: FinancialPeriodCreateManyLastUnlockedByInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput = {
    create?: XOR<FinancialPeriodCreateWithoutVatLockedByInput, FinancialPeriodUncheckedCreateWithoutVatLockedByInput> | FinancialPeriodCreateWithoutVatLockedByInput[] | FinancialPeriodUncheckedCreateWithoutVatLockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutVatLockedByInput | FinancialPeriodCreateOrConnectWithoutVatLockedByInput[]
    createMany?: FinancialPeriodCreateManyVatLockedByInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput = {
    create?: XOR<FinancialPeriodCreateWithoutYearEndClosedByInput, FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput> | FinancialPeriodCreateWithoutYearEndClosedByInput[] | FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput | FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput[]
    createMany?: FinancialPeriodCreateManyYearEndClosedByInputEnvelope
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<InvoiceCreateWithoutAgentInput, InvoiceUncheckedCreateWithoutAgentInput> | InvoiceCreateWithoutAgentInput[] | InvoiceUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAgentInput | InvoiceCreateOrConnectWithoutAgentInput[]
    createMany?: InvoiceCreateManyAgentInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutEnteredByInput = {
    create?: XOR<TransactionCreateWithoutEnteredByInput, TransactionUncheckedCreateWithoutEnteredByInput> | TransactionCreateWithoutEnteredByInput[] | TransactionUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutEnteredByInput | TransactionCreateOrConnectWithoutEnteredByInput[]
    createMany?: TransactionCreateManyEnteredByInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutEnteredByInput = {
    create?: XOR<VoucherCreateWithoutEnteredByInput, VoucherUncheckedCreateWithoutEnteredByInput> | VoucherCreateWithoutEnteredByInput[] | VoucherUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutEnteredByInput | VoucherCreateOrConnectWithoutEnteredByInput[]
    createMany?: VoucherCreateManyEnteredByInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput = {
    create?: XOR<VoucherPaymentCreateWithoutEnteredByInput, VoucherPaymentUncheckedCreateWithoutEnteredByInput> | VoucherPaymentCreateWithoutEnteredByInput[] | VoucherPaymentUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutEnteredByInput | VoucherPaymentCreateOrConnectWithoutEnteredByInput[]
    createMany?: VoucherPaymentCreateManyEnteredByInputEnvelope
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutSalespersonInput = {
    create?: XOR<QuotationCreateWithoutSalespersonInput, QuotationUncheckedCreateWithoutSalespersonInput> | QuotationCreateWithoutSalespersonInput[] | QuotationUncheckedCreateWithoutSalespersonInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutSalespersonInput | QuotationCreateOrConnectWithoutSalespersonInput[]
    createMany?: QuotationCreateManySalespersonInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput> | QuotationCreateWithoutApprovedByInput[] | QuotationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutApprovedByInput | QuotationCreateOrConnectWithoutApprovedByInput[]
    createMany?: QuotationCreateManyApprovedByInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type EnumUserRole_LegacyFieldUpdateOperationsInput = {
    set?: $Enums.UserRole_Legacy
  }

  export type ApprovalRequestUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutApproverInput, ApprovalRequestUncheckedCreateWithoutApproverInput> | ApprovalRequestCreateWithoutApproverInput[] | ApprovalRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutApproverInput | ApprovalRequestCreateOrConnectWithoutApproverInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutApproverInput | ApprovalRequestUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ApprovalRequestCreateManyApproverInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutApproverInput | ApprovalRequestUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutApproverInput | ApprovalRequestUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalRequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput> | ApprovalRequestCreateWithoutRequesterInput[] | ApprovalRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequesterInput | ApprovalRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput | ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: ApprovalRequestCreateManyRequesterInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput | ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutRequesterInput | ApprovalRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BranchUpdateManyWithoutManagerNestedInput = {
    create?: XOR<BranchCreateWithoutManagerInput, BranchUncheckedCreateWithoutManagerInput> | BranchCreateWithoutManagerInput[] | BranchUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutManagerInput | BranchCreateOrConnectWithoutManagerInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutManagerInput | BranchUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: BranchCreateManyManagerInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutManagerInput | BranchUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutManagerInput | BranchUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type DailyClosingUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<DailyClosingCreateWithoutClosedByInput, DailyClosingUncheckedCreateWithoutClosedByInput> | DailyClosingCreateWithoutClosedByInput[] | DailyClosingUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutClosedByInput | DailyClosingCreateOrConnectWithoutClosedByInput[]
    upsert?: DailyClosingUpsertWithWhereUniqueWithoutClosedByInput | DailyClosingUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: DailyClosingCreateManyClosedByInputEnvelope
    set?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    disconnect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    delete?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    update?: DailyClosingUpdateWithWhereUniqueWithoutClosedByInput | DailyClosingUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: DailyClosingUpdateManyWithWhereWithoutClosedByInput | DailyClosingUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: DailyClosingScalarWhereInput | DailyClosingScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutEnteredByNestedInput = {
    create?: XOR<ExpenseCreateWithoutEnteredByInput, ExpenseUncheckedCreateWithoutEnteredByInput> | ExpenseCreateWithoutEnteredByInput[] | ExpenseUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutEnteredByInput | ExpenseCreateOrConnectWithoutEnteredByInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutEnteredByInput | ExpenseUpsertWithWhereUniqueWithoutEnteredByInput[]
    createMany?: ExpenseCreateManyEnteredByInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutEnteredByInput | ExpenseUpdateWithWhereUniqueWithoutEnteredByInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutEnteredByInput | ExpenseUpdateManyWithWhereWithoutEnteredByInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutAccountingLockedByInput, FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput> | FinancialPeriodCreateWithoutAccountingLockedByInput[] | FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput | FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutAccountingLockedByInput | FinancialPeriodUpsertWithWhereUniqueWithoutAccountingLockedByInput[]
    createMany?: FinancialPeriodCreateManyAccountingLockedByInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutAccountingLockedByInput | FinancialPeriodUpdateWithWhereUniqueWithoutAccountingLockedByInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutAccountingLockedByInput | FinancialPeriodUpdateManyWithWhereWithoutAccountingLockedByInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutLastUnlockedByInput, FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput> | FinancialPeriodCreateWithoutLastUnlockedByInput[] | FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput | FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutLastUnlockedByInput | FinancialPeriodUpsertWithWhereUniqueWithoutLastUnlockedByInput[]
    createMany?: FinancialPeriodCreateManyLastUnlockedByInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutLastUnlockedByInput | FinancialPeriodUpdateWithWhereUniqueWithoutLastUnlockedByInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutLastUnlockedByInput | FinancialPeriodUpdateManyWithWhereWithoutLastUnlockedByInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type FinancialPeriodUpdateManyWithoutVatLockedByNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutVatLockedByInput, FinancialPeriodUncheckedCreateWithoutVatLockedByInput> | FinancialPeriodCreateWithoutVatLockedByInput[] | FinancialPeriodUncheckedCreateWithoutVatLockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutVatLockedByInput | FinancialPeriodCreateOrConnectWithoutVatLockedByInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutVatLockedByInput | FinancialPeriodUpsertWithWhereUniqueWithoutVatLockedByInput[]
    createMany?: FinancialPeriodCreateManyVatLockedByInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutVatLockedByInput | FinancialPeriodUpdateWithWhereUniqueWithoutVatLockedByInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutVatLockedByInput | FinancialPeriodUpdateManyWithWhereWithoutVatLockedByInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutYearEndClosedByInput, FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput> | FinancialPeriodCreateWithoutYearEndClosedByInput[] | FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput | FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutYearEndClosedByInput | FinancialPeriodUpsertWithWhereUniqueWithoutYearEndClosedByInput[]
    createMany?: FinancialPeriodCreateManyYearEndClosedByInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutYearEndClosedByInput | FinancialPeriodUpdateWithWhereUniqueWithoutYearEndClosedByInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutYearEndClosedByInput | FinancialPeriodUpdateManyWithWhereWithoutYearEndClosedByInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutAgentNestedInput = {
    create?: XOR<InvoiceCreateWithoutAgentInput, InvoiceUncheckedCreateWithoutAgentInput> | InvoiceCreateWithoutAgentInput[] | InvoiceUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAgentInput | InvoiceCreateOrConnectWithoutAgentInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutAgentInput | InvoiceUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: InvoiceCreateManyAgentInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutAgentInput | InvoiceUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutAgentInput | InvoiceUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutEnteredByNestedInput = {
    create?: XOR<TransactionCreateWithoutEnteredByInput, TransactionUncheckedCreateWithoutEnteredByInput> | TransactionCreateWithoutEnteredByInput[] | TransactionUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutEnteredByInput | TransactionCreateOrConnectWithoutEnteredByInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutEnteredByInput | TransactionUpsertWithWhereUniqueWithoutEnteredByInput[]
    createMany?: TransactionCreateManyEnteredByInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutEnteredByInput | TransactionUpdateWithWhereUniqueWithoutEnteredByInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutEnteredByInput | TransactionUpdateManyWithWhereWithoutEnteredByInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type VoucherUpdateManyWithoutEnteredByNestedInput = {
    create?: XOR<VoucherCreateWithoutEnteredByInput, VoucherUncheckedCreateWithoutEnteredByInput> | VoucherCreateWithoutEnteredByInput[] | VoucherUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutEnteredByInput | VoucherCreateOrConnectWithoutEnteredByInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutEnteredByInput | VoucherUpsertWithWhereUniqueWithoutEnteredByInput[]
    createMany?: VoucherCreateManyEnteredByInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutEnteredByInput | VoucherUpdateWithWhereUniqueWithoutEnteredByInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutEnteredByInput | VoucherUpdateManyWithWhereWithoutEnteredByInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type VoucherPaymentUpdateManyWithoutEnteredByNestedInput = {
    create?: XOR<VoucherPaymentCreateWithoutEnteredByInput, VoucherPaymentUncheckedCreateWithoutEnteredByInput> | VoucherPaymentCreateWithoutEnteredByInput[] | VoucherPaymentUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutEnteredByInput | VoucherPaymentCreateOrConnectWithoutEnteredByInput[]
    upsert?: VoucherPaymentUpsertWithWhereUniqueWithoutEnteredByInput | VoucherPaymentUpsertWithWhereUniqueWithoutEnteredByInput[]
    createMany?: VoucherPaymentCreateManyEnteredByInputEnvelope
    set?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    disconnect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    delete?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    update?: VoucherPaymentUpdateWithWhereUniqueWithoutEnteredByInput | VoucherPaymentUpdateWithWhereUniqueWithoutEnteredByInput[]
    updateMany?: VoucherPaymentUpdateManyWithWhereWithoutEnteredByInput | VoucherPaymentUpdateManyWithWhereWithoutEnteredByInput[]
    deleteMany?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutSalespersonNestedInput = {
    create?: XOR<QuotationCreateWithoutSalespersonInput, QuotationUncheckedCreateWithoutSalespersonInput> | QuotationCreateWithoutSalespersonInput[] | QuotationUncheckedCreateWithoutSalespersonInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutSalespersonInput | QuotationCreateOrConnectWithoutSalespersonInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutSalespersonInput | QuotationUpsertWithWhereUniqueWithoutSalespersonInput[]
    createMany?: QuotationCreateManySalespersonInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutSalespersonInput | QuotationUpdateWithWhereUniqueWithoutSalespersonInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutSalespersonInput | QuotationUpdateManyWithWhereWithoutSalespersonInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput> | QuotationCreateWithoutApprovedByInput[] | QuotationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutApprovedByInput | QuotationCreateOrConnectWithoutApprovedByInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutApprovedByInput | QuotationUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: QuotationCreateManyApprovedByInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutApprovedByInput | QuotationUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutApprovedByInput | QuotationUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutApproverInput, ApprovalRequestUncheckedCreateWithoutApproverInput> | ApprovalRequestCreateWithoutApproverInput[] | ApprovalRequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutApproverInput | ApprovalRequestCreateOrConnectWithoutApproverInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutApproverInput | ApprovalRequestUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ApprovalRequestCreateManyApproverInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutApproverInput | ApprovalRequestUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutApproverInput | ApprovalRequestUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput> | ApprovalRequestCreateWithoutRequesterInput[] | ApprovalRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequesterInput | ApprovalRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput | ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: ApprovalRequestCreateManyRequesterInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput | ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutRequesterInput | ApprovalRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<BranchCreateWithoutManagerInput, BranchUncheckedCreateWithoutManagerInput> | BranchCreateWithoutManagerInput[] | BranchUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutManagerInput | BranchCreateOrConnectWithoutManagerInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutManagerInput | BranchUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: BranchCreateManyManagerInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutManagerInput | BranchUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutManagerInput | BranchUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<DailyClosingCreateWithoutClosedByInput, DailyClosingUncheckedCreateWithoutClosedByInput> | DailyClosingCreateWithoutClosedByInput[] | DailyClosingUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: DailyClosingCreateOrConnectWithoutClosedByInput | DailyClosingCreateOrConnectWithoutClosedByInput[]
    upsert?: DailyClosingUpsertWithWhereUniqueWithoutClosedByInput | DailyClosingUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: DailyClosingCreateManyClosedByInputEnvelope
    set?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    disconnect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    delete?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    connect?: DailyClosingWhereUniqueInput | DailyClosingWhereUniqueInput[]
    update?: DailyClosingUpdateWithWhereUniqueWithoutClosedByInput | DailyClosingUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: DailyClosingUpdateManyWithWhereWithoutClosedByInput | DailyClosingUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: DailyClosingScalarWhereInput | DailyClosingScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput = {
    create?: XOR<ExpenseCreateWithoutEnteredByInput, ExpenseUncheckedCreateWithoutEnteredByInput> | ExpenseCreateWithoutEnteredByInput[] | ExpenseUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutEnteredByInput | ExpenseCreateOrConnectWithoutEnteredByInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutEnteredByInput | ExpenseUpsertWithWhereUniqueWithoutEnteredByInput[]
    createMany?: ExpenseCreateManyEnteredByInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutEnteredByInput | ExpenseUpdateWithWhereUniqueWithoutEnteredByInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutEnteredByInput | ExpenseUpdateManyWithWhereWithoutEnteredByInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutAccountingLockedByInput, FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput> | FinancialPeriodCreateWithoutAccountingLockedByInput[] | FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput | FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutAccountingLockedByInput | FinancialPeriodUpsertWithWhereUniqueWithoutAccountingLockedByInput[]
    createMany?: FinancialPeriodCreateManyAccountingLockedByInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutAccountingLockedByInput | FinancialPeriodUpdateWithWhereUniqueWithoutAccountingLockedByInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutAccountingLockedByInput | FinancialPeriodUpdateManyWithWhereWithoutAccountingLockedByInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutLastUnlockedByInput, FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput> | FinancialPeriodCreateWithoutLastUnlockedByInput[] | FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput | FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutLastUnlockedByInput | FinancialPeriodUpsertWithWhereUniqueWithoutLastUnlockedByInput[]
    createMany?: FinancialPeriodCreateManyLastUnlockedByInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutLastUnlockedByInput | FinancialPeriodUpdateWithWhereUniqueWithoutLastUnlockedByInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutLastUnlockedByInput | FinancialPeriodUpdateManyWithWhereWithoutLastUnlockedByInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutVatLockedByInput, FinancialPeriodUncheckedCreateWithoutVatLockedByInput> | FinancialPeriodCreateWithoutVatLockedByInput[] | FinancialPeriodUncheckedCreateWithoutVatLockedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutVatLockedByInput | FinancialPeriodCreateOrConnectWithoutVatLockedByInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutVatLockedByInput | FinancialPeriodUpsertWithWhereUniqueWithoutVatLockedByInput[]
    createMany?: FinancialPeriodCreateManyVatLockedByInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutVatLockedByInput | FinancialPeriodUpdateWithWhereUniqueWithoutVatLockedByInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutVatLockedByInput | FinancialPeriodUpdateManyWithWhereWithoutVatLockedByInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput = {
    create?: XOR<FinancialPeriodCreateWithoutYearEndClosedByInput, FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput> | FinancialPeriodCreateWithoutYearEndClosedByInput[] | FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput[]
    connectOrCreate?: FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput | FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput[]
    upsert?: FinancialPeriodUpsertWithWhereUniqueWithoutYearEndClosedByInput | FinancialPeriodUpsertWithWhereUniqueWithoutYearEndClosedByInput[]
    createMany?: FinancialPeriodCreateManyYearEndClosedByInputEnvelope
    set?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    disconnect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    delete?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    connect?: FinancialPeriodWhereUniqueInput | FinancialPeriodWhereUniqueInput[]
    update?: FinancialPeriodUpdateWithWhereUniqueWithoutYearEndClosedByInput | FinancialPeriodUpdateWithWhereUniqueWithoutYearEndClosedByInput[]
    updateMany?: FinancialPeriodUpdateManyWithWhereWithoutYearEndClosedByInput | FinancialPeriodUpdateManyWithWhereWithoutYearEndClosedByInput[]
    deleteMany?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<InvoiceCreateWithoutAgentInput, InvoiceUncheckedCreateWithoutAgentInput> | InvoiceCreateWithoutAgentInput[] | InvoiceUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAgentInput | InvoiceCreateOrConnectWithoutAgentInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutAgentInput | InvoiceUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: InvoiceCreateManyAgentInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutAgentInput | InvoiceUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutAgentInput | InvoiceUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutEnteredByNestedInput = {
    create?: XOR<TransactionCreateWithoutEnteredByInput, TransactionUncheckedCreateWithoutEnteredByInput> | TransactionCreateWithoutEnteredByInput[] | TransactionUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutEnteredByInput | TransactionCreateOrConnectWithoutEnteredByInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutEnteredByInput | TransactionUpsertWithWhereUniqueWithoutEnteredByInput[]
    createMany?: TransactionCreateManyEnteredByInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutEnteredByInput | TransactionUpdateWithWhereUniqueWithoutEnteredByInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutEnteredByInput | TransactionUpdateManyWithWhereWithoutEnteredByInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutEnteredByNestedInput = {
    create?: XOR<VoucherCreateWithoutEnteredByInput, VoucherUncheckedCreateWithoutEnteredByInput> | VoucherCreateWithoutEnteredByInput[] | VoucherUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutEnteredByInput | VoucherCreateOrConnectWithoutEnteredByInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutEnteredByInput | VoucherUpsertWithWhereUniqueWithoutEnteredByInput[]
    createMany?: VoucherCreateManyEnteredByInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutEnteredByInput | VoucherUpdateWithWhereUniqueWithoutEnteredByInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutEnteredByInput | VoucherUpdateManyWithWhereWithoutEnteredByInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput = {
    create?: XOR<VoucherPaymentCreateWithoutEnteredByInput, VoucherPaymentUncheckedCreateWithoutEnteredByInput> | VoucherPaymentCreateWithoutEnteredByInput[] | VoucherPaymentUncheckedCreateWithoutEnteredByInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutEnteredByInput | VoucherPaymentCreateOrConnectWithoutEnteredByInput[]
    upsert?: VoucherPaymentUpsertWithWhereUniqueWithoutEnteredByInput | VoucherPaymentUpsertWithWhereUniqueWithoutEnteredByInput[]
    createMany?: VoucherPaymentCreateManyEnteredByInputEnvelope
    set?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    disconnect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    delete?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    update?: VoucherPaymentUpdateWithWhereUniqueWithoutEnteredByInput | VoucherPaymentUpdateWithWhereUniqueWithoutEnteredByInput[]
    updateMany?: VoucherPaymentUpdateManyWithWhereWithoutEnteredByInput | VoucherPaymentUpdateManyWithWhereWithoutEnteredByInput[]
    deleteMany?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutSalespersonNestedInput = {
    create?: XOR<QuotationCreateWithoutSalespersonInput, QuotationUncheckedCreateWithoutSalespersonInput> | QuotationCreateWithoutSalespersonInput[] | QuotationUncheckedCreateWithoutSalespersonInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutSalespersonInput | QuotationCreateOrConnectWithoutSalespersonInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutSalespersonInput | QuotationUpsertWithWhereUniqueWithoutSalespersonInput[]
    createMany?: QuotationCreateManySalespersonInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutSalespersonInput | QuotationUpdateWithWhereUniqueWithoutSalespersonInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutSalespersonInput | QuotationUpdateManyWithWhereWithoutSalespersonInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput> | QuotationCreateWithoutApprovedByInput[] | QuotationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutApprovedByInput | QuotationCreateOrConnectWithoutApprovedByInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutApprovedByInput | QuotationUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: QuotationCreateManyApprovedByInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutApprovedByInput | QuotationUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutApprovedByInput | QuotationUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type CompanyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    upsert?: CompanyUpsertWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogsInput, CompanyUpdateWithoutAuditLogsInput>, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutApprovalActionsInput = {
    create?: XOR<UserCreateWithoutApprovalActionsInput, UserUncheckedCreateWithoutApprovalActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalActionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalRequestsInput = {
    create?: XOR<UserCreateWithoutApprovalRequestsInput, UserUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type UserUpdateOneWithoutApprovalActionsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalActionsInput, UserUncheckedCreateWithoutApprovalActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalActionsInput
    upsert?: UserUpsertWithoutApprovalActionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalActionsInput, UserUpdateWithoutApprovalActionsInput>, UserUncheckedUpdateWithoutApprovalActionsInput>
  }

  export type UserUpdateOneRequiredWithoutApprovalRequestsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalRequestsInput, UserUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalRequestsInput
    upsert?: UserUpsertWithoutApprovalRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalRequestsInput, UserUpdateWithoutApprovalRequestsInput>, UserUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type UserCreateNestedOneWithoutAccountingLockedPeriodsInput = {
    create?: XOR<UserCreateWithoutAccountingLockedPeriodsInput, UserUncheckedCreateWithoutAccountingLockedPeriodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountingLockedPeriodsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutFinancialPeriodsInput = {
    create?: XOR<CompanyCreateWithoutFinancialPeriodsInput, CompanyUncheckedCreateWithoutFinancialPeriodsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialPeriodsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUnlockedPeriodsInput = {
    create?: XOR<UserCreateWithoutUnlockedPeriodsInput, UserUncheckedCreateWithoutUnlockedPeriodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUnlockedPeriodsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVatLockedPeriodsInput = {
    create?: XOR<UserCreateWithoutVatLockedPeriodsInput, UserUncheckedCreateWithoutVatLockedPeriodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVatLockedPeriodsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutYearEndClosedPeriodsInput = {
    create?: XOR<UserCreateWithoutYearEndClosedPeriodsInput, UserUncheckedCreateWithoutYearEndClosedPeriodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutYearEndClosedPeriodsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAccountingLockedPeriodsNestedInput = {
    create?: XOR<UserCreateWithoutAccountingLockedPeriodsInput, UserUncheckedCreateWithoutAccountingLockedPeriodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountingLockedPeriodsInput
    upsert?: UserUpsertWithoutAccountingLockedPeriodsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountingLockedPeriodsInput, UserUpdateWithoutAccountingLockedPeriodsInput>, UserUncheckedUpdateWithoutAccountingLockedPeriodsInput>
  }

  export type CompanyUpdateOneRequiredWithoutFinancialPeriodsNestedInput = {
    create?: XOR<CompanyCreateWithoutFinancialPeriodsInput, CompanyUncheckedCreateWithoutFinancialPeriodsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFinancialPeriodsInput
    upsert?: CompanyUpsertWithoutFinancialPeriodsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFinancialPeriodsInput, CompanyUpdateWithoutFinancialPeriodsInput>, CompanyUncheckedUpdateWithoutFinancialPeriodsInput>
  }

  export type UserUpdateOneWithoutUnlockedPeriodsNestedInput = {
    create?: XOR<UserCreateWithoutUnlockedPeriodsInput, UserUncheckedCreateWithoutUnlockedPeriodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUnlockedPeriodsInput
    upsert?: UserUpsertWithoutUnlockedPeriodsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUnlockedPeriodsInput, UserUpdateWithoutUnlockedPeriodsInput>, UserUncheckedUpdateWithoutUnlockedPeriodsInput>
  }

  export type UserUpdateOneWithoutVatLockedPeriodsNestedInput = {
    create?: XOR<UserCreateWithoutVatLockedPeriodsInput, UserUncheckedCreateWithoutVatLockedPeriodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVatLockedPeriodsInput
    upsert?: UserUpsertWithoutVatLockedPeriodsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVatLockedPeriodsInput, UserUpdateWithoutVatLockedPeriodsInput>, UserUncheckedUpdateWithoutVatLockedPeriodsInput>
  }

  export type UserUpdateOneWithoutYearEndClosedPeriodsNestedInput = {
    create?: XOR<UserCreateWithoutYearEndClosedPeriodsInput, UserUncheckedCreateWithoutYearEndClosedPeriodsInput>
    connectOrCreate?: UserCreateOrConnectWithoutYearEndClosedPeriodsInput
    upsert?: UserUpsertWithoutYearEndClosedPeriodsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutYearEndClosedPeriodsInput, UserUpdateWithoutYearEndClosedPeriodsInput>, UserUncheckedUpdateWithoutYearEndClosedPeriodsInput>
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInvoicesInput
    connect?: BranchWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutInvoicesGovtFeeInput = {
    create?: XOR<AccountCreateWithoutInvoicesGovtFeeInput, AccountUncheckedCreateWithoutInvoicesGovtFeeInput>
    connectOrCreate?: AccountCreateOrConnectWithoutInvoicesGovtFeeInput
    connect?: AccountWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type QuotationCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<QuotationCreateWithoutInvoicesInput, QuotationUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutInvoicesInput
    connect?: QuotationWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type UserUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type BranchUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInvoicesInput
    upsert?: BranchUpsertWithoutInvoicesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutInvoicesInput, BranchUpdateWithoutInvoicesInput>, BranchUncheckedUpdateWithoutInvoicesInput>
  }

  export type CompanyUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    upsert?: CompanyUpsertWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInvoicesInput, CompanyUpdateWithoutInvoicesInput>, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type AccountUpdateOneWithoutInvoicesGovtFeeNestedInput = {
    create?: XOR<AccountCreateWithoutInvoicesGovtFeeInput, AccountUncheckedCreateWithoutInvoicesGovtFeeInput>
    connectOrCreate?: AccountCreateOrConnectWithoutInvoicesGovtFeeInput
    upsert?: AccountUpsertWithoutInvoicesGovtFeeInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutInvoicesGovtFeeInput, AccountUpdateWithoutInvoicesGovtFeeInput>, AccountUncheckedUpdateWithoutInvoicesGovtFeeInput>
  }

  export type TransactionUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type QuotationUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<QuotationCreateWithoutInvoicesInput, QuotationUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutInvoicesInput
    upsert?: QuotationUpsertWithoutInvoicesInput
    disconnect?: QuotationWhereInput | boolean
    delete?: QuotationWhereInput | boolean
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutInvoicesInput, QuotationUpdateWithoutInvoicesInput>, QuotationUncheckedUpdateWithoutInvoicesInput>
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BeneficiaryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BeneficiaryCreateWithoutTransactionsInput, BeneficiaryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutTransactionsInput
    connect?: BeneficiaryWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BranchCreateWithoutTransactionsInput, BranchUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTransactionsInput
    connect?: BranchWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CompanyCreateWithoutTransactionsInput, CompanyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransactionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutTransactionsGovtFeeInput = {
    create?: XOR<AccountCreateWithoutTransactionsGovtFeeInput, AccountUncheckedCreateWithoutTransactionsGovtFeeInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsGovtFeeInput
    connect?: AccountWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PartnerCreateWithoutTransactionsInput, PartnerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutTransactionsInput
    connect?: PartnerWhereUniqueInput
  }

  export type WorkTypeCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WorkTypeCreateWithoutTransactionsInput, WorkTypeUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WorkTypeCreateOrConnectWithoutTransactionsInput
    connect?: WorkTypeWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumAdvanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdvanceStatus
  }

  export type BeneficiaryUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutTransactionsInput, BeneficiaryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutTransactionsInput
    upsert?: BeneficiaryUpsertWithoutTransactionsInput
    disconnect?: BeneficiaryWhereInput | boolean
    delete?: BeneficiaryWhereInput | boolean
    connect?: BeneficiaryWhereUniqueInput
    update?: XOR<XOR<BeneficiaryUpdateToOneWithWhereWithoutTransactionsInput, BeneficiaryUpdateWithoutTransactionsInput>, BeneficiaryUncheckedUpdateWithoutTransactionsInput>
  }

  export type BranchUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<BranchCreateWithoutTransactionsInput, BranchUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTransactionsInput
    upsert?: BranchUpsertWithoutTransactionsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutTransactionsInput, BranchUpdateWithoutTransactionsInput>, BranchUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    upsert?: AccountUpsertWithoutTransactionsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTransactionsInput, AccountUpdateWithoutTransactionsInput>, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type CompanyUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CompanyCreateWithoutTransactionsInput, CompanyUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransactionsInput
    upsert?: CompanyUpsertWithoutTransactionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTransactionsInput, CompanyUpdateWithoutTransactionsInput>, CompanyUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateOneWithoutTransactionsGovtFeeNestedInput = {
    create?: XOR<AccountCreateWithoutTransactionsGovtFeeInput, AccountUncheckedCreateWithoutTransactionsGovtFeeInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsGovtFeeInput
    upsert?: AccountUpsertWithoutTransactionsGovtFeeInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTransactionsGovtFeeInput, AccountUpdateWithoutTransactionsGovtFeeInput>, AccountUncheckedUpdateWithoutTransactionsGovtFeeInput>
  }

  export type InvoiceUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    upsert?: InvoiceUpsertWithoutTransactionsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTransactionsInput, InvoiceUpdateWithoutTransactionsInput>, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type PartnerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<PartnerCreateWithoutTransactionsInput, PartnerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutTransactionsInput
    upsert?: PartnerUpsertWithoutTransactionsInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutTransactionsInput, PartnerUpdateWithoutTransactionsInput>, PartnerUncheckedUpdateWithoutTransactionsInput>
  }

  export type WorkTypeUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<WorkTypeCreateWithoutTransactionsInput, WorkTypeUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WorkTypeCreateOrConnectWithoutTransactionsInput
    upsert?: WorkTypeUpsertWithoutTransactionsInput
    disconnect?: WorkTypeWhereInput | boolean
    delete?: WorkTypeWhereInput | boolean
    connect?: WorkTypeWhereUniqueInput
    update?: XOR<XOR<WorkTypeUpdateToOneWithWhereWithoutTransactionsInput, WorkTypeUpdateWithoutTransactionsInput>, WorkTypeUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionCreateNestedManyWithoutWorkTypeInput = {
    create?: XOR<TransactionCreateWithoutWorkTypeInput, TransactionUncheckedCreateWithoutWorkTypeInput> | TransactionCreateWithoutWorkTypeInput[] | TransactionUncheckedCreateWithoutWorkTypeInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWorkTypeInput | TransactionCreateOrConnectWithoutWorkTypeInput[]
    createMany?: TransactionCreateManyWorkTypeInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type QuotationItemCreateNestedManyWithoutWorkTypeInput = {
    create?: XOR<QuotationItemCreateWithoutWorkTypeInput, QuotationItemUncheckedCreateWithoutWorkTypeInput> | QuotationItemCreateWithoutWorkTypeInput[] | QuotationItemUncheckedCreateWithoutWorkTypeInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutWorkTypeInput | QuotationItemCreateOrConnectWithoutWorkTypeInput[]
    createMany?: QuotationItemCreateManyWorkTypeInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutWorkTypesInput = {
    create?: XOR<CompanyCreateWithoutWorkTypesInput, CompanyUncheckedCreateWithoutWorkTypesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWorkTypesInput
    connect?: CompanyWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutWorkTypeInput = {
    create?: XOR<TransactionCreateWithoutWorkTypeInput, TransactionUncheckedCreateWithoutWorkTypeInput> | TransactionCreateWithoutWorkTypeInput[] | TransactionUncheckedCreateWithoutWorkTypeInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWorkTypeInput | TransactionCreateOrConnectWithoutWorkTypeInput[]
    createMany?: TransactionCreateManyWorkTypeInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type QuotationItemUncheckedCreateNestedManyWithoutWorkTypeInput = {
    create?: XOR<QuotationItemCreateWithoutWorkTypeInput, QuotationItemUncheckedCreateWithoutWorkTypeInput> | QuotationItemCreateWithoutWorkTypeInput[] | QuotationItemUncheckedCreateWithoutWorkTypeInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutWorkTypeInput | QuotationItemCreateOrConnectWithoutWorkTypeInput[]
    createMany?: QuotationItemCreateManyWorkTypeInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutWorkTypeNestedInput = {
    create?: XOR<TransactionCreateWithoutWorkTypeInput, TransactionUncheckedCreateWithoutWorkTypeInput> | TransactionCreateWithoutWorkTypeInput[] | TransactionUncheckedCreateWithoutWorkTypeInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWorkTypeInput | TransactionCreateOrConnectWithoutWorkTypeInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutWorkTypeInput | TransactionUpsertWithWhereUniqueWithoutWorkTypeInput[]
    createMany?: TransactionCreateManyWorkTypeInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutWorkTypeInput | TransactionUpdateWithWhereUniqueWithoutWorkTypeInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutWorkTypeInput | TransactionUpdateManyWithWhereWithoutWorkTypeInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type QuotationItemUpdateManyWithoutWorkTypeNestedInput = {
    create?: XOR<QuotationItemCreateWithoutWorkTypeInput, QuotationItemUncheckedCreateWithoutWorkTypeInput> | QuotationItemCreateWithoutWorkTypeInput[] | QuotationItemUncheckedCreateWithoutWorkTypeInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutWorkTypeInput | QuotationItemCreateOrConnectWithoutWorkTypeInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutWorkTypeInput | QuotationItemUpsertWithWhereUniqueWithoutWorkTypeInput[]
    createMany?: QuotationItemCreateManyWorkTypeInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutWorkTypeInput | QuotationItemUpdateWithWhereUniqueWithoutWorkTypeInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutWorkTypeInput | QuotationItemUpdateManyWithWhereWithoutWorkTypeInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutWorkTypesNestedInput = {
    create?: XOR<CompanyCreateWithoutWorkTypesInput, CompanyUncheckedCreateWithoutWorkTypesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWorkTypesInput
    upsert?: CompanyUpsertWithoutWorkTypesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWorkTypesInput, CompanyUpdateWithoutWorkTypesInput>, CompanyUncheckedUpdateWithoutWorkTypesInput>
  }

  export type TransactionUncheckedUpdateManyWithoutWorkTypeNestedInput = {
    create?: XOR<TransactionCreateWithoutWorkTypeInput, TransactionUncheckedCreateWithoutWorkTypeInput> | TransactionCreateWithoutWorkTypeInput[] | TransactionUncheckedCreateWithoutWorkTypeInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWorkTypeInput | TransactionCreateOrConnectWithoutWorkTypeInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutWorkTypeInput | TransactionUpsertWithWhereUniqueWithoutWorkTypeInput[]
    createMany?: TransactionCreateManyWorkTypeInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutWorkTypeInput | TransactionUpdateWithWhereUniqueWithoutWorkTypeInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutWorkTypeInput | TransactionUpdateManyWithWhereWithoutWorkTypeInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type QuotationItemUncheckedUpdateManyWithoutWorkTypeNestedInput = {
    create?: XOR<QuotationItemCreateWithoutWorkTypeInput, QuotationItemUncheckedCreateWithoutWorkTypeInput> | QuotationItemCreateWithoutWorkTypeInput[] | QuotationItemUncheckedCreateWithoutWorkTypeInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutWorkTypeInput | QuotationItemCreateOrConnectWithoutWorkTypeInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutWorkTypeInput | QuotationItemUpsertWithWhereUniqueWithoutWorkTypeInput[]
    createMany?: QuotationItemCreateManyWorkTypeInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutWorkTypeInput | QuotationItemUpdateWithWhereUniqueWithoutWorkTypeInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutWorkTypeInput | QuotationItemUpdateManyWithWhereWithoutWorkTypeInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutBeneficiariesInput = {
    create?: XOR<CompanyCreateWithoutBeneficiariesInput, CompanyUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBeneficiariesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutBeneficiariesInput = {
    create?: XOR<PartnerCreateWithoutBeneficiariesInput, PartnerUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutBeneficiariesInput
    connect?: PartnerWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutBeneficiaryInput = {
    create?: XOR<TransactionCreateWithoutBeneficiaryInput, TransactionUncheckedCreateWithoutBeneficiaryInput> | TransactionCreateWithoutBeneficiaryInput[] | TransactionUncheckedCreateWithoutBeneficiaryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBeneficiaryInput | TransactionCreateOrConnectWithoutBeneficiaryInput[]
    createMany?: TransactionCreateManyBeneficiaryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBeneficiaryInput = {
    create?: XOR<TransactionCreateWithoutBeneficiaryInput, TransactionUncheckedCreateWithoutBeneficiaryInput> | TransactionCreateWithoutBeneficiaryInput[] | TransactionUncheckedCreateWithoutBeneficiaryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBeneficiaryInput | TransactionCreateOrConnectWithoutBeneficiaryInput[]
    createMany?: TransactionCreateManyBeneficiaryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutBeneficiariesNestedInput = {
    create?: XOR<CompanyCreateWithoutBeneficiariesInput, CompanyUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBeneficiariesInput
    upsert?: CompanyUpsertWithoutBeneficiariesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBeneficiariesInput, CompanyUpdateWithoutBeneficiariesInput>, CompanyUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type PartnerUpdateOneWithoutBeneficiariesNestedInput = {
    create?: XOR<PartnerCreateWithoutBeneficiariesInput, PartnerUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutBeneficiariesInput
    upsert?: PartnerUpsertWithoutBeneficiariesInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutBeneficiariesInput, PartnerUpdateWithoutBeneficiariesInput>, PartnerUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type TransactionUpdateManyWithoutBeneficiaryNestedInput = {
    create?: XOR<TransactionCreateWithoutBeneficiaryInput, TransactionUncheckedCreateWithoutBeneficiaryInput> | TransactionCreateWithoutBeneficiaryInput[] | TransactionUncheckedCreateWithoutBeneficiaryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBeneficiaryInput | TransactionCreateOrConnectWithoutBeneficiaryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBeneficiaryInput | TransactionUpsertWithWhereUniqueWithoutBeneficiaryInput[]
    createMany?: TransactionCreateManyBeneficiaryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBeneficiaryInput | TransactionUpdateWithWhereUniqueWithoutBeneficiaryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBeneficiaryInput | TransactionUpdateManyWithWhereWithoutBeneficiaryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBeneficiaryNestedInput = {
    create?: XOR<TransactionCreateWithoutBeneficiaryInput, TransactionUncheckedCreateWithoutBeneficiaryInput> | TransactionCreateWithoutBeneficiaryInput[] | TransactionUncheckedCreateWithoutBeneficiaryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBeneficiaryInput | TransactionCreateOrConnectWithoutBeneficiaryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBeneficiaryInput | TransactionUpsertWithWhereUniqueWithoutBeneficiaryInput[]
    createMany?: TransactionCreateManyBeneficiaryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBeneficiaryInput | TransactionUpdateWithWhereUniqueWithoutBeneficiaryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBeneficiaryInput | TransactionUpdateManyWithWhereWithoutBeneficiaryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BeneficiaryCreateNestedManyWithoutPartnerInput = {
    create?: XOR<BeneficiaryCreateWithoutPartnerInput, BeneficiaryUncheckedCreateWithoutPartnerInput> | BeneficiaryCreateWithoutPartnerInput[] | BeneficiaryUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutPartnerInput | BeneficiaryCreateOrConnectWithoutPartnerInput[]
    createMany?: BeneficiaryCreateManyPartnerInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type LedgerTransactionCreateNestedManyWithoutPartnerInput = {
    create?: XOR<LedgerTransactionCreateWithoutPartnerInput, LedgerTransactionUncheckedCreateWithoutPartnerInput> | LedgerTransactionCreateWithoutPartnerInput[] | LedgerTransactionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutPartnerInput | LedgerTransactionCreateOrConnectWithoutPartnerInput[]
    createMany?: LedgerTransactionCreateManyPartnerInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutPartnersInput = {
    create?: XOR<CompanyCreateWithoutPartnersInput, CompanyUncheckedCreateWithoutPartnersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPartnersInput
    connect?: CompanyWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutPartnerInput = {
    create?: XOR<TransactionCreateWithoutPartnerInput, TransactionUncheckedCreateWithoutPartnerInput> | TransactionCreateWithoutPartnerInput[] | TransactionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPartnerInput | TransactionCreateOrConnectWithoutPartnerInput[]
    createMany?: TransactionCreateManyPartnerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutPartnerInput = {
    create?: XOR<QuotationCreateWithoutPartnerInput, QuotationUncheckedCreateWithoutPartnerInput> | QuotationCreateWithoutPartnerInput[] | QuotationUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutPartnerInput | QuotationCreateOrConnectWithoutPartnerInput[]
    createMany?: QuotationCreateManyPartnerInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<BeneficiaryCreateWithoutPartnerInput, BeneficiaryUncheckedCreateWithoutPartnerInput> | BeneficiaryCreateWithoutPartnerInput[] | BeneficiaryUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutPartnerInput | BeneficiaryCreateOrConnectWithoutPartnerInput[]
    createMany?: BeneficiaryCreateManyPartnerInputEnvelope
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
  }

  export type LedgerTransactionUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<LedgerTransactionCreateWithoutPartnerInput, LedgerTransactionUncheckedCreateWithoutPartnerInput> | LedgerTransactionCreateWithoutPartnerInput[] | LedgerTransactionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutPartnerInput | LedgerTransactionCreateOrConnectWithoutPartnerInput[]
    createMany?: LedgerTransactionCreateManyPartnerInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<TransactionCreateWithoutPartnerInput, TransactionUncheckedCreateWithoutPartnerInput> | TransactionCreateWithoutPartnerInput[] | TransactionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPartnerInput | TransactionCreateOrConnectWithoutPartnerInput[]
    createMany?: TransactionCreateManyPartnerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<QuotationCreateWithoutPartnerInput, QuotationUncheckedCreateWithoutPartnerInput> | QuotationCreateWithoutPartnerInput[] | QuotationUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutPartnerInput | QuotationCreateOrConnectWithoutPartnerInput[]
    createMany?: QuotationCreateManyPartnerInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type EnumPartnerTypeFieldUpdateOperationsInput = {
    set?: $Enums.PartnerType
  }

  export type BeneficiaryUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutPartnerInput, BeneficiaryUncheckedCreateWithoutPartnerInput> | BeneficiaryCreateWithoutPartnerInput[] | BeneficiaryUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutPartnerInput | BeneficiaryCreateOrConnectWithoutPartnerInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutPartnerInput | BeneficiaryUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: BeneficiaryCreateManyPartnerInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutPartnerInput | BeneficiaryUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutPartnerInput | BeneficiaryUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type LedgerTransactionUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutPartnerInput, LedgerTransactionUncheckedCreateWithoutPartnerInput> | LedgerTransactionCreateWithoutPartnerInput[] | LedgerTransactionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutPartnerInput | LedgerTransactionCreateOrConnectWithoutPartnerInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutPartnerInput | LedgerTransactionUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: LedgerTransactionCreateManyPartnerInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutPartnerInput | LedgerTransactionUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutPartnerInput | LedgerTransactionUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPartnersNestedInput = {
    create?: XOR<CompanyCreateWithoutPartnersInput, CompanyUncheckedCreateWithoutPartnersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPartnersInput
    upsert?: CompanyUpsertWithoutPartnersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPartnersInput, CompanyUpdateWithoutPartnersInput>, CompanyUncheckedUpdateWithoutPartnersInput>
  }

  export type TransactionUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<TransactionCreateWithoutPartnerInput, TransactionUncheckedCreateWithoutPartnerInput> | TransactionCreateWithoutPartnerInput[] | TransactionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPartnerInput | TransactionCreateOrConnectWithoutPartnerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPartnerInput | TransactionUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: TransactionCreateManyPartnerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPartnerInput | TransactionUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPartnerInput | TransactionUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<QuotationCreateWithoutPartnerInput, QuotationUncheckedCreateWithoutPartnerInput> | QuotationCreateWithoutPartnerInput[] | QuotationUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutPartnerInput | QuotationCreateOrConnectWithoutPartnerInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutPartnerInput | QuotationUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: QuotationCreateManyPartnerInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutPartnerInput | QuotationUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutPartnerInput | QuotationUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type BeneficiaryUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<BeneficiaryCreateWithoutPartnerInput, BeneficiaryUncheckedCreateWithoutPartnerInput> | BeneficiaryCreateWithoutPartnerInput[] | BeneficiaryUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutPartnerInput | BeneficiaryCreateOrConnectWithoutPartnerInput[]
    upsert?: BeneficiaryUpsertWithWhereUniqueWithoutPartnerInput | BeneficiaryUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: BeneficiaryCreateManyPartnerInputEnvelope
    set?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    disconnect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    delete?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    connect?: BeneficiaryWhereUniqueInput | BeneficiaryWhereUniqueInput[]
    update?: BeneficiaryUpdateWithWhereUniqueWithoutPartnerInput | BeneficiaryUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: BeneficiaryUpdateManyWithWhereWithoutPartnerInput | BeneficiaryUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutPartnerInput, LedgerTransactionUncheckedCreateWithoutPartnerInput> | LedgerTransactionCreateWithoutPartnerInput[] | LedgerTransactionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutPartnerInput | LedgerTransactionCreateOrConnectWithoutPartnerInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutPartnerInput | LedgerTransactionUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: LedgerTransactionCreateManyPartnerInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutPartnerInput | LedgerTransactionUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutPartnerInput | LedgerTransactionUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<TransactionCreateWithoutPartnerInput, TransactionUncheckedCreateWithoutPartnerInput> | TransactionCreateWithoutPartnerInput[] | TransactionUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPartnerInput | TransactionCreateOrConnectWithoutPartnerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPartnerInput | TransactionUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: TransactionCreateManyPartnerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPartnerInput | TransactionUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPartnerInput | TransactionUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<QuotationCreateWithoutPartnerInput, QuotationUncheckedCreateWithoutPartnerInput> | QuotationCreateWithoutPartnerInput[] | QuotationUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutPartnerInput | QuotationCreateOrConnectWithoutPartnerInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutPartnerInput | QuotationUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: QuotationCreateManyPartnerInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutPartnerInput | QuotationUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutPartnerInput | QuotationUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutExpensesInput = {
    create?: XOR<AccountCreateWithoutExpensesInput, AccountUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutExpensesInput
    connect?: AccountWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutExpensesInput = {
    create?: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutExpensesInput
    connect?: BranchWhereUniqueInput
  }

  export type ExpenseCategoryCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutExpensesInput = {
    create?: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpensesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExpensesInput = {
    create?: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesInput
    connect?: UserWhereUniqueInput
  }

  export type AccountUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<AccountCreateWithoutExpensesInput, AccountUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutExpensesInput
    upsert?: AccountUpsertWithoutExpensesInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutExpensesInput, AccountUpdateWithoutExpensesInput>, AccountUncheckedUpdateWithoutExpensesInput>
  }

  export type BranchUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutExpensesInput
    upsert?: BranchUpsertWithoutExpensesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutExpensesInput, BranchUpdateWithoutExpensesInput>, BranchUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    upsert?: ExpenseCategoryUpsertWithoutExpensesInput
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput, ExpenseCategoryUpdateWithoutExpensesInput>, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type CompanyUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpensesInput
    upsert?: CompanyUpsertWithoutExpensesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutExpensesInput, CompanyUpdateWithoutExpensesInput>, CompanyUncheckedUpdateWithoutExpensesInput>
  }

  export type UserUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesInput
    upsert?: UserUpsertWithoutExpensesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpensesInput, UserUpdateWithoutExpensesInput>, UserUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutExpenseCategoriesInput = {
    create?: XOR<CompanyCreateWithoutExpenseCategoriesInput, CompanyUncheckedCreateWithoutExpenseCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpenseCategoriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutExpenseCategoriesInput = {
    create?: XOR<AccountCreateWithoutExpenseCategoriesInput, AccountUncheckedCreateWithoutExpenseCategoriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutExpenseCategoriesInput
    connect?: AccountWhereUniqueInput
  }

  export type VoucherItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<VoucherItemCreateWithoutCategoryInput, VoucherItemUncheckedCreateWithoutCategoryInput> | VoucherItemCreateWithoutCategoryInput[] | VoucherItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VoucherItemCreateOrConnectWithoutCategoryInput | VoucherItemCreateOrConnectWithoutCategoryInput[]
    createMany?: VoucherItemCreateManyCategoryInputEnvelope
    connect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type VoucherItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<VoucherItemCreateWithoutCategoryInput, VoucherItemUncheckedCreateWithoutCategoryInput> | VoucherItemCreateWithoutCategoryInput[] | VoucherItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VoucherItemCreateOrConnectWithoutCategoryInput | VoucherItemCreateOrConnectWithoutCategoryInput[]
    createMany?: VoucherItemCreateManyCategoryInputEnvelope
    connect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
  }

  export type ExpenseUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCategoryInput | ExpenseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCategoryInput | ExpenseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCategoryInput | ExpenseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutExpenseCategoriesNestedInput = {
    create?: XOR<CompanyCreateWithoutExpenseCategoriesInput, CompanyUncheckedCreateWithoutExpenseCategoriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutExpenseCategoriesInput
    upsert?: CompanyUpsertWithoutExpenseCategoriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutExpenseCategoriesInput, CompanyUpdateWithoutExpenseCategoriesInput>, CompanyUncheckedUpdateWithoutExpenseCategoriesInput>
  }

  export type AccountUpdateOneWithoutExpenseCategoriesNestedInput = {
    create?: XOR<AccountCreateWithoutExpenseCategoriesInput, AccountUncheckedCreateWithoutExpenseCategoriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutExpenseCategoriesInput
    upsert?: AccountUpsertWithoutExpenseCategoriesInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutExpenseCategoriesInput, AccountUpdateWithoutExpenseCategoriesInput>, AccountUncheckedUpdateWithoutExpenseCategoriesInput>
  }

  export type VoucherItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<VoucherItemCreateWithoutCategoryInput, VoucherItemUncheckedCreateWithoutCategoryInput> | VoucherItemCreateWithoutCategoryInput[] | VoucherItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VoucherItemCreateOrConnectWithoutCategoryInput | VoucherItemCreateOrConnectWithoutCategoryInput[]
    upsert?: VoucherItemUpsertWithWhereUniqueWithoutCategoryInput | VoucherItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: VoucherItemCreateManyCategoryInputEnvelope
    set?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    disconnect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    delete?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    connect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    update?: VoucherItemUpdateWithWhereUniqueWithoutCategoryInput | VoucherItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: VoucherItemUpdateManyWithWhereWithoutCategoryInput | VoucherItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: VoucherItemScalarWhereInput | VoucherItemScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCategoryInput | ExpenseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCategoryInput | ExpenseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCategoryInput | ExpenseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type VoucherItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<VoucherItemCreateWithoutCategoryInput, VoucherItemUncheckedCreateWithoutCategoryInput> | VoucherItemCreateWithoutCategoryInput[] | VoucherItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VoucherItemCreateOrConnectWithoutCategoryInput | VoucherItemCreateOrConnectWithoutCategoryInput[]
    upsert?: VoucherItemUpsertWithWhereUniqueWithoutCategoryInput | VoucherItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: VoucherItemCreateManyCategoryInputEnvelope
    set?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    disconnect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    delete?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    connect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    update?: VoucherItemUpdateWithWhereUniqueWithoutCategoryInput | VoucherItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: VoucherItemUpdateManyWithWhereWithoutCategoryInput | VoucherItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: VoucherItemScalarWhereInput | VoucherItemScalarWhereInput[]
  }

  export type AccountCreatelinkedBranchIdsInput = {
    set: string[]
  }

  export type CompanyCreateNestedOneWithoutAccountsInput = {
    create?: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAccountsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutChildAccountsInput = {
    create?: XOR<AccountCreateWithoutChildAccountsInput, AccountUncheckedCreateWithoutChildAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildAccountsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutParentAccountInput = {
    create?: XOR<AccountCreateWithoutParentAccountInput, AccountUncheckedCreateWithoutParentAccountInput> | AccountCreateWithoutParentAccountInput[] | AccountUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentAccountInput | AccountCreateOrConnectWithoutParentAccountInput[]
    createMany?: AccountCreateManyParentAccountInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutAccountInput = {
    create?: XOR<ExpenseCreateWithoutAccountInput, ExpenseUncheckedCreateWithoutAccountInput> | ExpenseCreateWithoutAccountInput[] | ExpenseUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutAccountInput | ExpenseCreateOrConnectWithoutAccountInput[]
    createMany?: ExpenseCreateManyAccountInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput = {
    create?: XOR<ExpenseCategoryCreateWithoutLedgerAccountInput, ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput> | ExpenseCategoryCreateWithoutLedgerAccountInput[] | ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput | ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput[]
    createMany?: ExpenseCategoryCreateManyLedgerAccountInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutGovtFeeAccountInput = {
    create?: XOR<InvoiceCreateWithoutGovtFeeAccountInput, InvoiceUncheckedCreateWithoutGovtFeeAccountInput> | InvoiceCreateWithoutGovtFeeAccountInput[] | InvoiceUncheckedCreateWithoutGovtFeeAccountInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutGovtFeeAccountInput | InvoiceCreateOrConnectWithoutGovtFeeAccountInput[]
    createMany?: InvoiceCreateManyGovtFeeAccountInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerTransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<LedgerTransactionCreateWithoutAccountInput, LedgerTransactionUncheckedCreateWithoutAccountInput> | LedgerTransactionCreateWithoutAccountInput[] | LedgerTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutAccountInput | LedgerTransactionCreateOrConnectWithoutAccountInput[]
    createMany?: LedgerTransactionCreateManyAccountInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutGovtFeeAccountInput = {
    create?: XOR<TransactionCreateWithoutGovtFeeAccountInput, TransactionUncheckedCreateWithoutGovtFeeAccountInput> | TransactionCreateWithoutGovtFeeAccountInput[] | TransactionUncheckedCreateWithoutGovtFeeAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGovtFeeAccountInput | TransactionCreateOrConnectWithoutGovtFeeAccountInput[]
    createMany?: TransactionCreateManyGovtFeeAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type VoucherCreateNestedManyWithoutAccountInput = {
    create?: XOR<VoucherCreateWithoutAccountInput, VoucherUncheckedCreateWithoutAccountInput> | VoucherCreateWithoutAccountInput[] | VoucherUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutAccountInput | VoucherCreateOrConnectWithoutAccountInput[]
    createMany?: VoucherCreateManyAccountInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type VoucherPaymentCreateNestedManyWithoutAccountInput = {
    create?: XOR<VoucherPaymentCreateWithoutAccountInput, VoucherPaymentUncheckedCreateWithoutAccountInput> | VoucherPaymentCreateWithoutAccountInput[] | VoucherPaymentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutAccountInput | VoucherPaymentCreateOrConnectWithoutAccountInput[]
    createMany?: VoucherPaymentCreateManyAccountInputEnvelope
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
  }

  export type BusinessCardCreateNestedManyWithoutLedgerAccountInput = {
    create?: XOR<BusinessCardCreateWithoutLedgerAccountInput, BusinessCardUncheckedCreateWithoutLedgerAccountInput> | BusinessCardCreateWithoutLedgerAccountInput[] | BusinessCardUncheckedCreateWithoutLedgerAccountInput[]
    connectOrCreate?: BusinessCardCreateOrConnectWithoutLedgerAccountInput | BusinessCardCreateOrConnectWithoutLedgerAccountInput[]
    createMany?: BusinessCardCreateManyLedgerAccountInputEnvelope
    connect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutParentAccountInput = {
    create?: XOR<AccountCreateWithoutParentAccountInput, AccountUncheckedCreateWithoutParentAccountInput> | AccountCreateWithoutParentAccountInput[] | AccountUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentAccountInput | AccountCreateOrConnectWithoutParentAccountInput[]
    createMany?: AccountCreateManyParentAccountInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ExpenseCreateWithoutAccountInput, ExpenseUncheckedCreateWithoutAccountInput> | ExpenseCreateWithoutAccountInput[] | ExpenseUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutAccountInput | ExpenseCreateOrConnectWithoutAccountInput[]
    createMany?: ExpenseCreateManyAccountInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput = {
    create?: XOR<ExpenseCategoryCreateWithoutLedgerAccountInput, ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput> | ExpenseCategoryCreateWithoutLedgerAccountInput[] | ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput | ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput[]
    createMany?: ExpenseCategoryCreateManyLedgerAccountInputEnvelope
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput = {
    create?: XOR<InvoiceCreateWithoutGovtFeeAccountInput, InvoiceUncheckedCreateWithoutGovtFeeAccountInput> | InvoiceCreateWithoutGovtFeeAccountInput[] | InvoiceUncheckedCreateWithoutGovtFeeAccountInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutGovtFeeAccountInput | InvoiceCreateOrConnectWithoutGovtFeeAccountInput[]
    createMany?: InvoiceCreateManyGovtFeeAccountInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<LedgerTransactionCreateWithoutAccountInput, LedgerTransactionUncheckedCreateWithoutAccountInput> | LedgerTransactionCreateWithoutAccountInput[] | LedgerTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutAccountInput | LedgerTransactionCreateOrConnectWithoutAccountInput[]
    createMany?: LedgerTransactionCreateManyAccountInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput = {
    create?: XOR<TransactionCreateWithoutGovtFeeAccountInput, TransactionUncheckedCreateWithoutGovtFeeAccountInput> | TransactionCreateWithoutGovtFeeAccountInput[] | TransactionUncheckedCreateWithoutGovtFeeAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGovtFeeAccountInput | TransactionCreateOrConnectWithoutGovtFeeAccountInput[]
    createMany?: TransactionCreateManyGovtFeeAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<VoucherCreateWithoutAccountInput, VoucherUncheckedCreateWithoutAccountInput> | VoucherCreateWithoutAccountInput[] | VoucherUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutAccountInput | VoucherCreateOrConnectWithoutAccountInput[]
    createMany?: VoucherCreateManyAccountInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<VoucherPaymentCreateWithoutAccountInput, VoucherPaymentUncheckedCreateWithoutAccountInput> | VoucherPaymentCreateWithoutAccountInput[] | VoucherPaymentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutAccountInput | VoucherPaymentCreateOrConnectWithoutAccountInput[]
    createMany?: VoucherPaymentCreateManyAccountInputEnvelope
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
  }

  export type BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput = {
    create?: XOR<BusinessCardCreateWithoutLedgerAccountInput, BusinessCardUncheckedCreateWithoutLedgerAccountInput> | BusinessCardCreateWithoutLedgerAccountInput[] | BusinessCardUncheckedCreateWithoutLedgerAccountInput[]
    connectOrCreate?: BusinessCardCreateOrConnectWithoutLedgerAccountInput | BusinessCardCreateOrConnectWithoutLedgerAccountInput[]
    createMany?: BusinessCardCreateManyLedgerAccountInputEnvelope
    connect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type EnumAccountCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AccountCategory
  }

  export type AccountUpdatelinkedBranchIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompanyUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAccountsInput
    upsert?: CompanyUpsertWithoutAccountsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAccountsInput, CompanyUpdateWithoutAccountsInput>, CompanyUncheckedUpdateWithoutAccountsInput>
  }

  export type AccountUpdateOneWithoutChildAccountsNestedInput = {
    create?: XOR<AccountCreateWithoutChildAccountsInput, AccountUncheckedCreateWithoutChildAccountsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildAccountsInput
    upsert?: AccountUpsertWithoutChildAccountsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutChildAccountsInput, AccountUpdateWithoutChildAccountsInput>, AccountUncheckedUpdateWithoutChildAccountsInput>
  }

  export type AccountUpdateManyWithoutParentAccountNestedInput = {
    create?: XOR<AccountCreateWithoutParentAccountInput, AccountUncheckedCreateWithoutParentAccountInput> | AccountCreateWithoutParentAccountInput[] | AccountUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentAccountInput | AccountCreateOrConnectWithoutParentAccountInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentAccountInput | AccountUpsertWithWhereUniqueWithoutParentAccountInput[]
    createMany?: AccountCreateManyParentAccountInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentAccountInput | AccountUpdateWithWhereUniqueWithoutParentAccountInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentAccountInput | AccountUpdateManyWithWhereWithoutParentAccountInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ExpenseCreateWithoutAccountInput, ExpenseUncheckedCreateWithoutAccountInput> | ExpenseCreateWithoutAccountInput[] | ExpenseUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutAccountInput | ExpenseCreateOrConnectWithoutAccountInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutAccountInput | ExpenseUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ExpenseCreateManyAccountInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutAccountInput | ExpenseUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutAccountInput | ExpenseUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutLedgerAccountInput, ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput> | ExpenseCategoryCreateWithoutLedgerAccountInput[] | ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput | ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutLedgerAccountInput | ExpenseCategoryUpsertWithWhereUniqueWithoutLedgerAccountInput[]
    createMany?: ExpenseCategoryCreateManyLedgerAccountInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutLedgerAccountInput | ExpenseCategoryUpdateWithWhereUniqueWithoutLedgerAccountInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutLedgerAccountInput | ExpenseCategoryUpdateManyWithWhereWithoutLedgerAccountInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutGovtFeeAccountNestedInput = {
    create?: XOR<InvoiceCreateWithoutGovtFeeAccountInput, InvoiceUncheckedCreateWithoutGovtFeeAccountInput> | InvoiceCreateWithoutGovtFeeAccountInput[] | InvoiceUncheckedCreateWithoutGovtFeeAccountInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutGovtFeeAccountInput | InvoiceCreateOrConnectWithoutGovtFeeAccountInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutGovtFeeAccountInput | InvoiceUpsertWithWhereUniqueWithoutGovtFeeAccountInput[]
    createMany?: InvoiceCreateManyGovtFeeAccountInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutGovtFeeAccountInput | InvoiceUpdateWithWhereUniqueWithoutGovtFeeAccountInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutGovtFeeAccountInput | InvoiceUpdateManyWithWhereWithoutGovtFeeAccountInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerTransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutAccountInput, LedgerTransactionUncheckedCreateWithoutAccountInput> | LedgerTransactionCreateWithoutAccountInput[] | LedgerTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutAccountInput | LedgerTransactionCreateOrConnectWithoutAccountInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutAccountInput | LedgerTransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: LedgerTransactionCreateManyAccountInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutAccountInput | LedgerTransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutAccountInput | LedgerTransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutGovtFeeAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutGovtFeeAccountInput, TransactionUncheckedCreateWithoutGovtFeeAccountInput> | TransactionCreateWithoutGovtFeeAccountInput[] | TransactionUncheckedCreateWithoutGovtFeeAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGovtFeeAccountInput | TransactionCreateOrConnectWithoutGovtFeeAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGovtFeeAccountInput | TransactionUpsertWithWhereUniqueWithoutGovtFeeAccountInput[]
    createMany?: TransactionCreateManyGovtFeeAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGovtFeeAccountInput | TransactionUpdateWithWhereUniqueWithoutGovtFeeAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGovtFeeAccountInput | TransactionUpdateManyWithWhereWithoutGovtFeeAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type VoucherUpdateManyWithoutAccountNestedInput = {
    create?: XOR<VoucherCreateWithoutAccountInput, VoucherUncheckedCreateWithoutAccountInput> | VoucherCreateWithoutAccountInput[] | VoucherUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutAccountInput | VoucherCreateOrConnectWithoutAccountInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutAccountInput | VoucherUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: VoucherCreateManyAccountInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutAccountInput | VoucherUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutAccountInput | VoucherUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type VoucherPaymentUpdateManyWithoutAccountNestedInput = {
    create?: XOR<VoucherPaymentCreateWithoutAccountInput, VoucherPaymentUncheckedCreateWithoutAccountInput> | VoucherPaymentCreateWithoutAccountInput[] | VoucherPaymentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutAccountInput | VoucherPaymentCreateOrConnectWithoutAccountInput[]
    upsert?: VoucherPaymentUpsertWithWhereUniqueWithoutAccountInput | VoucherPaymentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: VoucherPaymentCreateManyAccountInputEnvelope
    set?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    disconnect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    delete?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    update?: VoucherPaymentUpdateWithWhereUniqueWithoutAccountInput | VoucherPaymentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: VoucherPaymentUpdateManyWithWhereWithoutAccountInput | VoucherPaymentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
  }

  export type BusinessCardUpdateManyWithoutLedgerAccountNestedInput = {
    create?: XOR<BusinessCardCreateWithoutLedgerAccountInput, BusinessCardUncheckedCreateWithoutLedgerAccountInput> | BusinessCardCreateWithoutLedgerAccountInput[] | BusinessCardUncheckedCreateWithoutLedgerAccountInput[]
    connectOrCreate?: BusinessCardCreateOrConnectWithoutLedgerAccountInput | BusinessCardCreateOrConnectWithoutLedgerAccountInput[]
    upsert?: BusinessCardUpsertWithWhereUniqueWithoutLedgerAccountInput | BusinessCardUpsertWithWhereUniqueWithoutLedgerAccountInput[]
    createMany?: BusinessCardCreateManyLedgerAccountInputEnvelope
    set?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    disconnect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    delete?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    connect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    update?: BusinessCardUpdateWithWhereUniqueWithoutLedgerAccountInput | BusinessCardUpdateWithWhereUniqueWithoutLedgerAccountInput[]
    updateMany?: BusinessCardUpdateManyWithWhereWithoutLedgerAccountInput | BusinessCardUpdateManyWithWhereWithoutLedgerAccountInput[]
    deleteMany?: BusinessCardScalarWhereInput | BusinessCardScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutParentAccountNestedInput = {
    create?: XOR<AccountCreateWithoutParentAccountInput, AccountUncheckedCreateWithoutParentAccountInput> | AccountCreateWithoutParentAccountInput[] | AccountUncheckedCreateWithoutParentAccountInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentAccountInput | AccountCreateOrConnectWithoutParentAccountInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentAccountInput | AccountUpsertWithWhereUniqueWithoutParentAccountInput[]
    createMany?: AccountCreateManyParentAccountInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentAccountInput | AccountUpdateWithWhereUniqueWithoutParentAccountInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentAccountInput | AccountUpdateManyWithWhereWithoutParentAccountInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ExpenseCreateWithoutAccountInput, ExpenseUncheckedCreateWithoutAccountInput> | ExpenseCreateWithoutAccountInput[] | ExpenseUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutAccountInput | ExpenseCreateOrConnectWithoutAccountInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutAccountInput | ExpenseUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ExpenseCreateManyAccountInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutAccountInput | ExpenseUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutAccountInput | ExpenseUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutLedgerAccountInput, ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput> | ExpenseCategoryCreateWithoutLedgerAccountInput[] | ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput[]
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput | ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput[]
    upsert?: ExpenseCategoryUpsertWithWhereUniqueWithoutLedgerAccountInput | ExpenseCategoryUpsertWithWhereUniqueWithoutLedgerAccountInput[]
    createMany?: ExpenseCategoryCreateManyLedgerAccountInputEnvelope
    set?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    disconnect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    delete?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    connect?: ExpenseCategoryWhereUniqueInput | ExpenseCategoryWhereUniqueInput[]
    update?: ExpenseCategoryUpdateWithWhereUniqueWithoutLedgerAccountInput | ExpenseCategoryUpdateWithWhereUniqueWithoutLedgerAccountInput[]
    updateMany?: ExpenseCategoryUpdateManyWithWhereWithoutLedgerAccountInput | ExpenseCategoryUpdateManyWithWhereWithoutLedgerAccountInput[]
    deleteMany?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput = {
    create?: XOR<InvoiceCreateWithoutGovtFeeAccountInput, InvoiceUncheckedCreateWithoutGovtFeeAccountInput> | InvoiceCreateWithoutGovtFeeAccountInput[] | InvoiceUncheckedCreateWithoutGovtFeeAccountInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutGovtFeeAccountInput | InvoiceCreateOrConnectWithoutGovtFeeAccountInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutGovtFeeAccountInput | InvoiceUpsertWithWhereUniqueWithoutGovtFeeAccountInput[]
    createMany?: InvoiceCreateManyGovtFeeAccountInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutGovtFeeAccountInput | InvoiceUpdateWithWhereUniqueWithoutGovtFeeAccountInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutGovtFeeAccountInput | InvoiceUpdateManyWithWhereWithoutGovtFeeAccountInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutAccountInput, LedgerTransactionUncheckedCreateWithoutAccountInput> | LedgerTransactionCreateWithoutAccountInput[] | LedgerTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutAccountInput | LedgerTransactionCreateOrConnectWithoutAccountInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutAccountInput | LedgerTransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: LedgerTransactionCreateManyAccountInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutAccountInput | LedgerTransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutAccountInput | LedgerTransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutGovtFeeAccountInput, TransactionUncheckedCreateWithoutGovtFeeAccountInput> | TransactionCreateWithoutGovtFeeAccountInput[] | TransactionUncheckedCreateWithoutGovtFeeAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGovtFeeAccountInput | TransactionCreateOrConnectWithoutGovtFeeAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGovtFeeAccountInput | TransactionUpsertWithWhereUniqueWithoutGovtFeeAccountInput[]
    createMany?: TransactionCreateManyGovtFeeAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGovtFeeAccountInput | TransactionUpdateWithWhereUniqueWithoutGovtFeeAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGovtFeeAccountInput | TransactionUpdateManyWithWhereWithoutGovtFeeAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<VoucherCreateWithoutAccountInput, VoucherUncheckedCreateWithoutAccountInput> | VoucherCreateWithoutAccountInput[] | VoucherUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutAccountInput | VoucherCreateOrConnectWithoutAccountInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutAccountInput | VoucherUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: VoucherCreateManyAccountInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutAccountInput | VoucherUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutAccountInput | VoucherUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<VoucherPaymentCreateWithoutAccountInput, VoucherPaymentUncheckedCreateWithoutAccountInput> | VoucherPaymentCreateWithoutAccountInput[] | VoucherPaymentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutAccountInput | VoucherPaymentCreateOrConnectWithoutAccountInput[]
    upsert?: VoucherPaymentUpsertWithWhereUniqueWithoutAccountInput | VoucherPaymentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: VoucherPaymentCreateManyAccountInputEnvelope
    set?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    disconnect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    delete?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    update?: VoucherPaymentUpdateWithWhereUniqueWithoutAccountInput | VoucherPaymentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: VoucherPaymentUpdateManyWithWhereWithoutAccountInput | VoucherPaymentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
  }

  export type BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput = {
    create?: XOR<BusinessCardCreateWithoutLedgerAccountInput, BusinessCardUncheckedCreateWithoutLedgerAccountInput> | BusinessCardCreateWithoutLedgerAccountInput[] | BusinessCardUncheckedCreateWithoutLedgerAccountInput[]
    connectOrCreate?: BusinessCardCreateOrConnectWithoutLedgerAccountInput | BusinessCardCreateOrConnectWithoutLedgerAccountInput[]
    upsert?: BusinessCardUpsertWithWhereUniqueWithoutLedgerAccountInput | BusinessCardUpsertWithWhereUniqueWithoutLedgerAccountInput[]
    createMany?: BusinessCardCreateManyLedgerAccountInputEnvelope
    set?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    disconnect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    delete?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    connect?: BusinessCardWhereUniqueInput | BusinessCardWhereUniqueInput[]
    update?: BusinessCardUpdateWithWhereUniqueWithoutLedgerAccountInput | BusinessCardUpdateWithWhereUniqueWithoutLedgerAccountInput[]
    updateMany?: BusinessCardUpdateManyWithWhereWithoutLedgerAccountInput | BusinessCardUpdateManyWithWhereWithoutLedgerAccountInput[]
    deleteMany?: BusinessCardScalarWhereInput | BusinessCardScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<BranchCreateWithoutJournalEntriesInput, BranchUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutJournalEntriesInput
    connect?: BranchWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJournalEntriesInput
    connect?: CompanyWhereUniqueInput
  }

  export type LedgerTransactionCreateNestedManyWithoutJournalEntryInput = {
    create?: XOR<LedgerTransactionCreateWithoutJournalEntryInput, LedgerTransactionUncheckedCreateWithoutJournalEntryInput> | LedgerTransactionCreateWithoutJournalEntryInput[] | LedgerTransactionUncheckedCreateWithoutJournalEntryInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutJournalEntryInput | LedgerTransactionCreateOrConnectWithoutJournalEntryInput[]
    createMany?: LedgerTransactionCreateManyJournalEntryInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type LedgerTransactionUncheckedCreateNestedManyWithoutJournalEntryInput = {
    create?: XOR<LedgerTransactionCreateWithoutJournalEntryInput, LedgerTransactionUncheckedCreateWithoutJournalEntryInput> | LedgerTransactionCreateWithoutJournalEntryInput[] | LedgerTransactionUncheckedCreateWithoutJournalEntryInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutJournalEntryInput | LedgerTransactionCreateOrConnectWithoutJournalEntryInput[]
    createMany?: LedgerTransactionCreateManyJournalEntryInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type EnumJournalEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.JournalEntryType
  }

  export type BranchUpdateOneWithoutJournalEntriesNestedInput = {
    create?: XOR<BranchCreateWithoutJournalEntriesInput, BranchUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutJournalEntriesInput
    upsert?: BranchUpsertWithoutJournalEntriesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutJournalEntriesInput, BranchUpdateWithoutJournalEntriesInput>, BranchUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput = {
    create?: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJournalEntriesInput
    upsert?: CompanyUpsertWithoutJournalEntriesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutJournalEntriesInput, CompanyUpdateWithoutJournalEntriesInput>, CompanyUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type LedgerTransactionUpdateManyWithoutJournalEntryNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutJournalEntryInput, LedgerTransactionUncheckedCreateWithoutJournalEntryInput> | LedgerTransactionCreateWithoutJournalEntryInput[] | LedgerTransactionUncheckedCreateWithoutJournalEntryInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutJournalEntryInput | LedgerTransactionCreateOrConnectWithoutJournalEntryInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutJournalEntryInput | LedgerTransactionUpsertWithWhereUniqueWithoutJournalEntryInput[]
    createMany?: LedgerTransactionCreateManyJournalEntryInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutJournalEntryInput | LedgerTransactionUpdateWithWhereUniqueWithoutJournalEntryInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutJournalEntryInput | LedgerTransactionUpdateManyWithWhereWithoutJournalEntryInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutJournalEntryNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutJournalEntryInput, LedgerTransactionUncheckedCreateWithoutJournalEntryInput> | LedgerTransactionCreateWithoutJournalEntryInput[] | LedgerTransactionUncheckedCreateWithoutJournalEntryInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutJournalEntryInput | LedgerTransactionCreateOrConnectWithoutJournalEntryInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutJournalEntryInput | LedgerTransactionUpsertWithWhereUniqueWithoutJournalEntryInput[]
    createMany?: LedgerTransactionCreateManyJournalEntryInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutJournalEntryInput | LedgerTransactionUpdateWithWhereUniqueWithoutJournalEntryInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutJournalEntryInput | LedgerTransactionUpdateManyWithWhereWithoutJournalEntryInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutLedgerTransactionsInput = {
    create?: XOR<AccountCreateWithoutLedgerTransactionsInput, AccountUncheckedCreateWithoutLedgerTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutLedgerTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutLedgerTransactionsInput = {
    create?: XOR<BranchCreateWithoutLedgerTransactionsInput, BranchUncheckedCreateWithoutLedgerTransactionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutLedgerTransactionsInput
    connect?: BranchWhereUniqueInput
  }

  export type JournalEntryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<JournalEntryCreateWithoutTransactionsInput, JournalEntryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutTransactionsInput
    connect?: JournalEntryWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutLedgerTransactionsInput = {
    create?: XOR<PartnerCreateWithoutLedgerTransactionsInput, PartnerUncheckedCreateWithoutLedgerTransactionsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutLedgerTransactionsInput
    connect?: PartnerWhereUniqueInput
  }

  export type BusinessCardCreateNestedOneWithoutLedgerTransactionsInput = {
    create?: XOR<BusinessCardCreateWithoutLedgerTransactionsInput, BusinessCardUncheckedCreateWithoutLedgerTransactionsInput>
    connectOrCreate?: BusinessCardCreateOrConnectWithoutLedgerTransactionsInput
    connect?: BusinessCardWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutLedgerTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutLedgerTransactionsInput, AccountUncheckedCreateWithoutLedgerTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutLedgerTransactionsInput
    upsert?: AccountUpsertWithoutLedgerTransactionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutLedgerTransactionsInput, AccountUpdateWithoutLedgerTransactionsInput>, AccountUncheckedUpdateWithoutLedgerTransactionsInput>
  }

  export type BranchUpdateOneWithoutLedgerTransactionsNestedInput = {
    create?: XOR<BranchCreateWithoutLedgerTransactionsInput, BranchUncheckedCreateWithoutLedgerTransactionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutLedgerTransactionsInput
    upsert?: BranchUpsertWithoutLedgerTransactionsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutLedgerTransactionsInput, BranchUpdateWithoutLedgerTransactionsInput>, BranchUncheckedUpdateWithoutLedgerTransactionsInput>
  }

  export type JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<JournalEntryCreateWithoutTransactionsInput, JournalEntryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutTransactionsInput
    upsert?: JournalEntryUpsertWithoutTransactionsInput
    connect?: JournalEntryWhereUniqueInput
    update?: XOR<XOR<JournalEntryUpdateToOneWithWhereWithoutTransactionsInput, JournalEntryUpdateWithoutTransactionsInput>, JournalEntryUncheckedUpdateWithoutTransactionsInput>
  }

  export type PartnerUpdateOneWithoutLedgerTransactionsNestedInput = {
    create?: XOR<PartnerCreateWithoutLedgerTransactionsInput, PartnerUncheckedCreateWithoutLedgerTransactionsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutLedgerTransactionsInput
    upsert?: PartnerUpsertWithoutLedgerTransactionsInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutLedgerTransactionsInput, PartnerUpdateWithoutLedgerTransactionsInput>, PartnerUncheckedUpdateWithoutLedgerTransactionsInput>
  }

  export type BusinessCardUpdateOneWithoutLedgerTransactionsNestedInput = {
    create?: XOR<BusinessCardCreateWithoutLedgerTransactionsInput, BusinessCardUncheckedCreateWithoutLedgerTransactionsInput>
    connectOrCreate?: BusinessCardCreateOrConnectWithoutLedgerTransactionsInput
    upsert?: BusinessCardUpsertWithoutLedgerTransactionsInput
    disconnect?: BusinessCardWhereInput | boolean
    delete?: BusinessCardWhereInput | boolean
    connect?: BusinessCardWhereUniqueInput
    update?: XOR<XOR<BusinessCardUpdateToOneWithWhereWithoutLedgerTransactionsInput, BusinessCardUpdateWithoutLedgerTransactionsInput>, BusinessCardUncheckedUpdateWithoutLedgerTransactionsInput>
  }

  export type AccountCreateNestedOneWithoutVouchersInput = {
    create?: XOR<AccountCreateWithoutVouchersInput, AccountUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVouchersInput
    connect?: AccountWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutVouchersInput = {
    create?: XOR<BranchCreateWithoutVouchersInput, BranchUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutVouchersInput
    connect?: BranchWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutVouchersInput = {
    create?: XOR<CompanyCreateWithoutVouchersInput, CompanyUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVouchersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVouchersInput = {
    create?: XOR<UserCreateWithoutVouchersInput, UserUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVouchersInput
    connect?: UserWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutVouchersInput = {
    create?: XOR<VendorCreateWithoutVouchersInput, VendorUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVouchersInput
    connect?: VendorWhereUniqueInput
  }

  export type VoucherItemCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherItemCreateWithoutVoucherInput, VoucherItemUncheckedCreateWithoutVoucherInput> | VoucherItemCreateWithoutVoucherInput[] | VoucherItemUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherItemCreateOrConnectWithoutVoucherInput | VoucherItemCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherItemCreateManyVoucherInputEnvelope
    connect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
  }

  export type VoucherPaymentCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherPaymentCreateWithoutVoucherInput, VoucherPaymentUncheckedCreateWithoutVoucherInput> | VoucherPaymentCreateWithoutVoucherInput[] | VoucherPaymentUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutVoucherInput | VoucherPaymentCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherPaymentCreateManyVoucherInputEnvelope
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
  }

  export type VoucherItemUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherItemCreateWithoutVoucherInput, VoucherItemUncheckedCreateWithoutVoucherInput> | VoucherItemCreateWithoutVoucherInput[] | VoucherItemUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherItemCreateOrConnectWithoutVoucherInput | VoucherItemCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherItemCreateManyVoucherInputEnvelope
    connect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
  }

  export type VoucherPaymentUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherPaymentCreateWithoutVoucherInput, VoucherPaymentUncheckedCreateWithoutVoucherInput> | VoucherPaymentCreateWithoutVoucherInput[] | VoucherPaymentUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutVoucherInput | VoucherPaymentCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherPaymentCreateManyVoucherInputEnvelope
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
  }

  export type EnumVoucherStatusFieldUpdateOperationsInput = {
    set?: $Enums.VoucherStatus
  }

  export type EnumVoucherTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoucherType
  }

  export type AccountUpdateOneWithoutVouchersNestedInput = {
    create?: XOR<AccountCreateWithoutVouchersInput, AccountUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVouchersInput
    upsert?: AccountUpsertWithoutVouchersInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutVouchersInput, AccountUpdateWithoutVouchersInput>, AccountUncheckedUpdateWithoutVouchersInput>
  }

  export type BranchUpdateOneWithoutVouchersNestedInput = {
    create?: XOR<BranchCreateWithoutVouchersInput, BranchUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutVouchersInput
    upsert?: BranchUpsertWithoutVouchersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutVouchersInput, BranchUpdateWithoutVouchersInput>, BranchUncheckedUpdateWithoutVouchersInput>
  }

  export type CompanyUpdateOneRequiredWithoutVouchersNestedInput = {
    create?: XOR<CompanyCreateWithoutVouchersInput, CompanyUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVouchersInput
    upsert?: CompanyUpsertWithoutVouchersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVouchersInput, CompanyUpdateWithoutVouchersInput>, CompanyUncheckedUpdateWithoutVouchersInput>
  }

  export type UserUpdateOneRequiredWithoutVouchersNestedInput = {
    create?: XOR<UserCreateWithoutVouchersInput, UserUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVouchersInput
    upsert?: UserUpsertWithoutVouchersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVouchersInput, UserUpdateWithoutVouchersInput>, UserUncheckedUpdateWithoutVouchersInput>
  }

  export type VendorUpdateOneWithoutVouchersNestedInput = {
    create?: XOR<VendorCreateWithoutVouchersInput, VendorUncheckedCreateWithoutVouchersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVouchersInput
    upsert?: VendorUpsertWithoutVouchersInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVouchersInput, VendorUpdateWithoutVouchersInput>, VendorUncheckedUpdateWithoutVouchersInput>
  }

  export type VoucherItemUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherItemCreateWithoutVoucherInput, VoucherItemUncheckedCreateWithoutVoucherInput> | VoucherItemCreateWithoutVoucherInput[] | VoucherItemUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherItemCreateOrConnectWithoutVoucherInput | VoucherItemCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherItemUpsertWithWhereUniqueWithoutVoucherInput | VoucherItemUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherItemCreateManyVoucherInputEnvelope
    set?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    disconnect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    delete?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    connect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    update?: VoucherItemUpdateWithWhereUniqueWithoutVoucherInput | VoucherItemUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherItemUpdateManyWithWhereWithoutVoucherInput | VoucherItemUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherItemScalarWhereInput | VoucherItemScalarWhereInput[]
  }

  export type VoucherPaymentUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherPaymentCreateWithoutVoucherInput, VoucherPaymentUncheckedCreateWithoutVoucherInput> | VoucherPaymentCreateWithoutVoucherInput[] | VoucherPaymentUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutVoucherInput | VoucherPaymentCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherPaymentUpsertWithWhereUniqueWithoutVoucherInput | VoucherPaymentUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherPaymentCreateManyVoucherInputEnvelope
    set?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    disconnect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    delete?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    update?: VoucherPaymentUpdateWithWhereUniqueWithoutVoucherInput | VoucherPaymentUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherPaymentUpdateManyWithWhereWithoutVoucherInput | VoucherPaymentUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
  }

  export type VoucherItemUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherItemCreateWithoutVoucherInput, VoucherItemUncheckedCreateWithoutVoucherInput> | VoucherItemCreateWithoutVoucherInput[] | VoucherItemUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherItemCreateOrConnectWithoutVoucherInput | VoucherItemCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherItemUpsertWithWhereUniqueWithoutVoucherInput | VoucherItemUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherItemCreateManyVoucherInputEnvelope
    set?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    disconnect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    delete?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    connect?: VoucherItemWhereUniqueInput | VoucherItemWhereUniqueInput[]
    update?: VoucherItemUpdateWithWhereUniqueWithoutVoucherInput | VoucherItemUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherItemUpdateManyWithWhereWithoutVoucherInput | VoucherItemUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherItemScalarWhereInput | VoucherItemScalarWhereInput[]
  }

  export type VoucherPaymentUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherPaymentCreateWithoutVoucherInput, VoucherPaymentUncheckedCreateWithoutVoucherInput> | VoucherPaymentCreateWithoutVoucherInput[] | VoucherPaymentUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherPaymentCreateOrConnectWithoutVoucherInput | VoucherPaymentCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherPaymentUpsertWithWhereUniqueWithoutVoucherInput | VoucherPaymentUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherPaymentCreateManyVoucherInputEnvelope
    set?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    disconnect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    delete?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    connect?: VoucherPaymentWhereUniqueInput | VoucherPaymentWhereUniqueInput[]
    update?: VoucherPaymentUpdateWithWhereUniqueWithoutVoucherInput | VoucherPaymentUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherPaymentUpdateManyWithWhereWithoutVoucherInput | VoucherPaymentUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
  }

  export type ExpenseCategoryCreateNestedOneWithoutVoucherItemsInput = {
    create?: XOR<ExpenseCategoryCreateWithoutVoucherItemsInput, ExpenseCategoryUncheckedCreateWithoutVoucherItemsInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutVoucherItemsInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutItemsInput = {
    create?: XOR<VoucherCreateWithoutItemsInput, VoucherUncheckedCreateWithoutItemsInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutItemsInput
    connect?: VoucherWhereUniqueInput
  }

  export type ExpenseCategoryUpdateOneRequiredWithoutVoucherItemsNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutVoucherItemsInput, ExpenseCategoryUncheckedCreateWithoutVoucherItemsInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutVoucherItemsInput
    upsert?: ExpenseCategoryUpsertWithoutVoucherItemsInput
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutVoucherItemsInput, ExpenseCategoryUpdateWithoutVoucherItemsInput>, ExpenseCategoryUncheckedUpdateWithoutVoucherItemsInput>
  }

  export type VoucherUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<VoucherCreateWithoutItemsInput, VoucherUncheckedCreateWithoutItemsInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutItemsInput
    upsert?: VoucherUpsertWithoutItemsInput
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutItemsInput, VoucherUpdateWithoutItemsInput>, VoucherUncheckedUpdateWithoutItemsInput>
  }

  export type CompanyCreateNestedOneWithoutVendorsInput = {
    create?: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVendorsInput
    connect?: CompanyWhereUniqueInput
  }

  export type VoucherCreateNestedManyWithoutVendorInput = {
    create?: XOR<VoucherCreateWithoutVendorInput, VoucherUncheckedCreateWithoutVendorInput> | VoucherCreateWithoutVendorInput[] | VoucherUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutVendorInput | VoucherCreateOrConnectWithoutVendorInput[]
    createMany?: VoucherCreateManyVendorInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VoucherCreateWithoutVendorInput, VoucherUncheckedCreateWithoutVendorInput> | VoucherCreateWithoutVendorInput[] | VoucherUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutVendorInput | VoucherCreateOrConnectWithoutVendorInput[]
    createMany?: VoucherCreateManyVendorInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVendorsInput
    upsert?: CompanyUpsertWithoutVendorsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVendorsInput, CompanyUpdateWithoutVendorsInput>, CompanyUncheckedUpdateWithoutVendorsInput>
  }

  export type VoucherUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VoucherCreateWithoutVendorInput, VoucherUncheckedCreateWithoutVendorInput> | VoucherCreateWithoutVendorInput[] | VoucherUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutVendorInput | VoucherCreateOrConnectWithoutVendorInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutVendorInput | VoucherUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VoucherCreateManyVendorInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutVendorInput | VoucherUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutVendorInput | VoucherUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VoucherCreateWithoutVendorInput, VoucherUncheckedCreateWithoutVendorInput> | VoucherCreateWithoutVendorInput[] | VoucherUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutVendorInput | VoucherCreateOrConnectWithoutVendorInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutVendorInput | VoucherUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VoucherCreateManyVendorInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutVendorInput | VoucherUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutVendorInput | VoucherUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutVoucherPaymentsInput = {
    create?: XOR<AccountCreateWithoutVoucherPaymentsInput, AccountUncheckedCreateWithoutVoucherPaymentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVoucherPaymentsInput
    connect?: AccountWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutVoucherPaymentsInput = {
    create?: XOR<CompanyCreateWithoutVoucherPaymentsInput, CompanyUncheckedCreateWithoutVoucherPaymentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVoucherPaymentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVoucherPaymentsInput = {
    create?: XOR<UserCreateWithoutVoucherPaymentsInput, UserUncheckedCreateWithoutVoucherPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<VoucherCreateWithoutPaymentsInput, VoucherUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutPaymentsInput
    connect?: VoucherWhereUniqueInput
  }

  export type AccountUpdateOneWithoutVoucherPaymentsNestedInput = {
    create?: XOR<AccountCreateWithoutVoucherPaymentsInput, AccountUncheckedCreateWithoutVoucherPaymentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutVoucherPaymentsInput
    upsert?: AccountUpsertWithoutVoucherPaymentsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutVoucherPaymentsInput, AccountUpdateWithoutVoucherPaymentsInput>, AccountUncheckedUpdateWithoutVoucherPaymentsInput>
  }

  export type CompanyUpdateOneRequiredWithoutVoucherPaymentsNestedInput = {
    create?: XOR<CompanyCreateWithoutVoucherPaymentsInput, CompanyUncheckedCreateWithoutVoucherPaymentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVoucherPaymentsInput
    upsert?: CompanyUpsertWithoutVoucherPaymentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVoucherPaymentsInput, CompanyUpdateWithoutVoucherPaymentsInput>, CompanyUncheckedUpdateWithoutVoucherPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutVoucherPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutVoucherPaymentsInput, UserUncheckedCreateWithoutVoucherPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherPaymentsInput
    upsert?: UserUpsertWithoutVoucherPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoucherPaymentsInput, UserUpdateWithoutVoucherPaymentsInput>, UserUncheckedUpdateWithoutVoucherPaymentsInput>
  }

  export type VoucherUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<VoucherCreateWithoutPaymentsInput, VoucherUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutPaymentsInput
    upsert?: VoucherUpsertWithoutPaymentsInput
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutPaymentsInput, VoucherUpdateWithoutPaymentsInput>, VoucherUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type AccountCreateNestedOneWithoutBusinessCardsInput = {
    create?: XOR<AccountCreateWithoutBusinessCardsInput, AccountUncheckedCreateWithoutBusinessCardsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBusinessCardsInput
    connect?: AccountWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutBusinessCardsInput = {
    create?: XOR<CompanyCreateWithoutBusinessCardsInput, CompanyUncheckedCreateWithoutBusinessCardsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBusinessCardsInput
    connect?: CompanyWhereUniqueInput
  }

  export type LedgerTransactionCreateNestedManyWithoutCardInput = {
    create?: XOR<LedgerTransactionCreateWithoutCardInput, LedgerTransactionUncheckedCreateWithoutCardInput> | LedgerTransactionCreateWithoutCardInput[] | LedgerTransactionUncheckedCreateWithoutCardInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutCardInput | LedgerTransactionCreateOrConnectWithoutCardInput[]
    createMany?: LedgerTransactionCreateManyCardInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type LedgerTransactionUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<LedgerTransactionCreateWithoutCardInput, LedgerTransactionUncheckedCreateWithoutCardInput> | LedgerTransactionCreateWithoutCardInput[] | LedgerTransactionUncheckedCreateWithoutCardInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutCardInput | LedgerTransactionCreateOrConnectWithoutCardInput[]
    createMany?: LedgerTransactionCreateManyCardInputEnvelope
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
  }

  export type EnumCardTypeFieldUpdateOperationsInput = {
    set?: $Enums.CardType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneRequiredWithoutBusinessCardsNestedInput = {
    create?: XOR<AccountCreateWithoutBusinessCardsInput, AccountUncheckedCreateWithoutBusinessCardsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBusinessCardsInput
    upsert?: AccountUpsertWithoutBusinessCardsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutBusinessCardsInput, AccountUpdateWithoutBusinessCardsInput>, AccountUncheckedUpdateWithoutBusinessCardsInput>
  }

  export type CompanyUpdateOneRequiredWithoutBusinessCardsNestedInput = {
    create?: XOR<CompanyCreateWithoutBusinessCardsInput, CompanyUncheckedCreateWithoutBusinessCardsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBusinessCardsInput
    upsert?: CompanyUpsertWithoutBusinessCardsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBusinessCardsInput, CompanyUpdateWithoutBusinessCardsInput>, CompanyUncheckedUpdateWithoutBusinessCardsInput>
  }

  export type LedgerTransactionUpdateManyWithoutCardNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutCardInput, LedgerTransactionUncheckedCreateWithoutCardInput> | LedgerTransactionCreateWithoutCardInput[] | LedgerTransactionUncheckedCreateWithoutCardInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutCardInput | LedgerTransactionCreateOrConnectWithoutCardInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutCardInput | LedgerTransactionUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: LedgerTransactionCreateManyCardInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutCardInput | LedgerTransactionUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutCardInput | LedgerTransactionUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<LedgerTransactionCreateWithoutCardInput, LedgerTransactionUncheckedCreateWithoutCardInput> | LedgerTransactionCreateWithoutCardInput[] | LedgerTransactionUncheckedCreateWithoutCardInput[]
    connectOrCreate?: LedgerTransactionCreateOrConnectWithoutCardInput | LedgerTransactionCreateOrConnectWithoutCardInput[]
    upsert?: LedgerTransactionUpsertWithWhereUniqueWithoutCardInput | LedgerTransactionUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: LedgerTransactionCreateManyCardInputEnvelope
    set?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    disconnect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    delete?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    connect?: LedgerTransactionWhereUniqueInput | LedgerTransactionWhereUniqueInput[]
    update?: LedgerTransactionUpdateWithWhereUniqueWithoutCardInput | LedgerTransactionUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: LedgerTransactionUpdateManyWithWhereWithoutCardInput | LedgerTransactionUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<CompanyCreateWithoutQuotationsInput, CompanyUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQuotationsInput
    connect?: CompanyWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<BranchCreateWithoutQuotationsInput, BranchUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutQuotationsInput
    connect?: BranchWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<PartnerCreateWithoutQuotationsInput, PartnerUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutQuotationsInput
    connect?: PartnerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<UserCreateWithoutQuotationsInput, UserUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotationsInput
    connect?: UserWhereUniqueInput
  }

  export type QuotationItemCreateNestedManyWithoutQuotationInput = {
    create?: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput> | QuotationItemCreateWithoutQuotationInput[] | QuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutQuotationInput | QuotationItemCreateOrConnectWithoutQuotationInput[]
    createMany?: QuotationItemCreateManyQuotationInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutQuotationInput = {
    create?: XOR<InvoiceCreateWithoutQuotationInput, InvoiceUncheckedCreateWithoutQuotationInput> | InvoiceCreateWithoutQuotationInput[] | InvoiceUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutQuotationInput | InvoiceCreateOrConnectWithoutQuotationInput[]
    createMany?: InvoiceCreateManyQuotationInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutApprovedQuotationsInput = {
    create?: XOR<UserCreateWithoutApprovedQuotationsInput, UserUncheckedCreateWithoutApprovedQuotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedQuotationsInput
    connect?: UserWhereUniqueInput
  }

  export type QuotationItemUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput> | QuotationItemCreateWithoutQuotationInput[] | QuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutQuotationInput | QuotationItemCreateOrConnectWithoutQuotationInput[]
    createMany?: QuotationItemCreateManyQuotationInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<InvoiceCreateWithoutQuotationInput, InvoiceUncheckedCreateWithoutQuotationInput> | InvoiceCreateWithoutQuotationInput[] | InvoiceUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutQuotationInput | InvoiceCreateOrConnectWithoutQuotationInput[]
    createMany?: InvoiceCreateManyQuotationInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type EnumQuotationStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuotationStatus
  }

  export type CompanyUpdateOneRequiredWithoutQuotationsNestedInput = {
    create?: XOR<CompanyCreateWithoutQuotationsInput, CompanyUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQuotationsInput
    upsert?: CompanyUpsertWithoutQuotationsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutQuotationsInput, CompanyUpdateWithoutQuotationsInput>, CompanyUncheckedUpdateWithoutQuotationsInput>
  }

  export type BranchUpdateOneWithoutQuotationsNestedInput = {
    create?: XOR<BranchCreateWithoutQuotationsInput, BranchUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutQuotationsInput
    upsert?: BranchUpsertWithoutQuotationsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutQuotationsInput, BranchUpdateWithoutQuotationsInput>, BranchUncheckedUpdateWithoutQuotationsInput>
  }

  export type PartnerUpdateOneWithoutQuotationsNestedInput = {
    create?: XOR<PartnerCreateWithoutQuotationsInput, PartnerUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutQuotationsInput
    upsert?: PartnerUpsertWithoutQuotationsInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutQuotationsInput, PartnerUpdateWithoutQuotationsInput>, PartnerUncheckedUpdateWithoutQuotationsInput>
  }

  export type UserUpdateOneRequiredWithoutQuotationsNestedInput = {
    create?: XOR<UserCreateWithoutQuotationsInput, UserUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuotationsInput
    upsert?: UserUpsertWithoutQuotationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuotationsInput, UserUpdateWithoutQuotationsInput>, UserUncheckedUpdateWithoutQuotationsInput>
  }

  export type QuotationItemUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput> | QuotationItemCreateWithoutQuotationInput[] | QuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutQuotationInput | QuotationItemCreateOrConnectWithoutQuotationInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutQuotationInput | QuotationItemUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: QuotationItemCreateManyQuotationInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutQuotationInput | QuotationItemUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutQuotationInput | QuotationItemUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<InvoiceCreateWithoutQuotationInput, InvoiceUncheckedCreateWithoutQuotationInput> | InvoiceCreateWithoutQuotationInput[] | InvoiceUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutQuotationInput | InvoiceCreateOrConnectWithoutQuotationInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutQuotationInput | InvoiceUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: InvoiceCreateManyQuotationInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutQuotationInput | InvoiceUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutQuotationInput | InvoiceUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserUpdateOneWithoutApprovedQuotationsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedQuotationsInput, UserUncheckedCreateWithoutApprovedQuotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedQuotationsInput
    upsert?: UserUpsertWithoutApprovedQuotationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedQuotationsInput, UserUpdateWithoutApprovedQuotationsInput>, UserUncheckedUpdateWithoutApprovedQuotationsInput>
  }

  export type QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput> | QuotationItemCreateWithoutQuotationInput[] | QuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutQuotationInput | QuotationItemCreateOrConnectWithoutQuotationInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutQuotationInput | QuotationItemUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: QuotationItemCreateManyQuotationInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutQuotationInput | QuotationItemUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutQuotationInput | QuotationItemUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<InvoiceCreateWithoutQuotationInput, InvoiceUncheckedCreateWithoutQuotationInput> | InvoiceCreateWithoutQuotationInput[] | InvoiceUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutQuotationInput | InvoiceCreateOrConnectWithoutQuotationInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutQuotationInput | InvoiceUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: InvoiceCreateManyQuotationInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutQuotationInput | InvoiceUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutQuotationInput | InvoiceUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type QuotationCreateNestedOneWithoutItemsInput = {
    create?: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutItemsInput
    connect?: QuotationWhereUniqueInput
  }

  export type WorkTypeCreateNestedOneWithoutQuotationItemsInput = {
    create?: XOR<WorkTypeCreateWithoutQuotationItemsInput, WorkTypeUncheckedCreateWithoutQuotationItemsInput>
    connectOrCreate?: WorkTypeCreateOrConnectWithoutQuotationItemsInput
    connect?: WorkTypeWhereUniqueInput
  }

  export type QuotationUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutItemsInput
    upsert?: QuotationUpsertWithoutItemsInput
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutItemsInput, QuotationUpdateWithoutItemsInput>, QuotationUncheckedUpdateWithoutItemsInput>
  }

  export type WorkTypeUpdateOneWithoutQuotationItemsNestedInput = {
    create?: XOR<WorkTypeCreateWithoutQuotationItemsInput, WorkTypeUncheckedCreateWithoutQuotationItemsInput>
    connectOrCreate?: WorkTypeCreateOrConnectWithoutQuotationItemsInput
    upsert?: WorkTypeUpsertWithoutQuotationItemsInput
    disconnect?: WorkTypeWhereInput | boolean
    delete?: WorkTypeWhereInput | boolean
    connect?: WorkTypeWhereUniqueInput
    update?: XOR<XOR<WorkTypeUpdateToOneWithWhereWithoutQuotationItemsInput, WorkTypeUpdateWithoutQuotationItemsInput>, WorkTypeUncheckedUpdateWithoutQuotationItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumAccountingMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingMethod | EnumAccountingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingMethod[] | ListEnumAccountingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingMethod[] | ListEnumAccountingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingMethodFilter<$PrismaModel> | $Enums.AccountingMethod
  }

  export type NestedEnumAccountingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingModel | EnumAccountingModelFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingModel[] | ListEnumAccountingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingModel[] | ListEnumAccountingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingModelFilter<$PrismaModel> | $Enums.AccountingModel
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumEmirateFilter<$PrismaModel = never> = {
    equals?: $Enums.Emirate | EnumEmirateFieldRefInput<$PrismaModel>
    in?: $Enums.Emirate[] | ListEnumEmirateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Emirate[] | ListEnumEmirateFieldRefInput<$PrismaModel>
    not?: NestedEnumEmirateFilter<$PrismaModel> | $Enums.Emirate
  }

  export type NestedEnumLegalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalType | EnumLegalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalTypeFilter<$PrismaModel> | $Enums.LegalType
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumVatFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.VatFrequency | EnumVatFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.VatFrequency[] | ListEnumVatFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.VatFrequency[] | ListEnumVatFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumVatFrequencyFilter<$PrismaModel> | $Enums.VatFrequency
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAccountingMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingMethod | EnumAccountingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingMethod[] | ListEnumAccountingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingMethod[] | ListEnumAccountingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingMethodWithAggregatesFilter<$PrismaModel> | $Enums.AccountingMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountingMethodFilter<$PrismaModel>
    _max?: NestedEnumAccountingMethodFilter<$PrismaModel>
  }

  export type NestedEnumAccountingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingModel | EnumAccountingModelFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingModel[] | ListEnumAccountingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingModel[] | ListEnumAccountingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingModelWithAggregatesFilter<$PrismaModel> | $Enums.AccountingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountingModelFilter<$PrismaModel>
    _max?: NestedEnumAccountingModelFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumEmirateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Emirate | EnumEmirateFieldRefInput<$PrismaModel>
    in?: $Enums.Emirate[] | ListEnumEmirateFieldRefInput<$PrismaModel>
    notIn?: $Enums.Emirate[] | ListEnumEmirateFieldRefInput<$PrismaModel>
    not?: NestedEnumEmirateWithAggregatesFilter<$PrismaModel> | $Enums.Emirate
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmirateFilter<$PrismaModel>
    _max?: NestedEnumEmirateFilter<$PrismaModel>
  }

  export type NestedEnumLegalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalType | EnumLegalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalType[] | ListEnumLegalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalTypeWithAggregatesFilter<$PrismaModel> | $Enums.LegalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLegalTypeFilter<$PrismaModel>
    _max?: NestedEnumLegalTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumVatFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VatFrequency | EnumVatFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.VatFrequency[] | ListEnumVatFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.VatFrequency[] | ListEnumVatFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumVatFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.VatFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVatFrequencyFilter<$PrismaModel>
    _max?: NestedEnumVatFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumClosingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClosingStatus | EnumClosingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClosingStatus[] | ListEnumClosingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClosingStatus[] | ListEnumClosingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClosingStatusFilter<$PrismaModel> | $Enums.ClosingStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumClosingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClosingStatus | EnumClosingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClosingStatus[] | ListEnumClosingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClosingStatus[] | ListEnumClosingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClosingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClosingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClosingStatusFilter<$PrismaModel>
    _max?: NestedEnumClosingStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBranchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeFilter<$PrismaModel> | $Enums.BranchType
  }

  export type NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BranchType | EnumBranchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BranchType[] | ListEnumBranchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBranchTypeWithAggregatesFilter<$PrismaModel> | $Enums.BranchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBranchTypeFilter<$PrismaModel>
    _max?: NestedEnumBranchTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserRole_LegacyFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole_Legacy | EnumUserRole_LegacyFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole_Legacy[] | ListEnumUserRole_LegacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole_Legacy[] | ListEnumUserRole_LegacyFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRole_LegacyFilter<$PrismaModel> | $Enums.UserRole_Legacy
  }

  export type NestedEnumUserRole_LegacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole_Legacy | EnumUserRole_LegacyFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole_Legacy[] | ListEnumUserRole_LegacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole_Legacy[] | ListEnumUserRole_LegacyFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRole_LegacyWithAggregatesFilter<$PrismaModel> | $Enums.UserRole_Legacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRole_LegacyFilter<$PrismaModel>
    _max?: NestedEnumUserRole_LegacyFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumAdvanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvanceStatus | EnumAdvanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvanceStatus[] | ListEnumAdvanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvanceStatus[] | ListEnumAdvanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvanceStatusFilter<$PrismaModel> | $Enums.AdvanceStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdvanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdvanceStatus | EnumAdvanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdvanceStatus[] | ListEnumAdvanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdvanceStatus[] | ListEnumAdvanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdvanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdvanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdvanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAdvanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPartnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeFilter<$PrismaModel> | $Enums.PartnerType
  }

  export type NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerTypeFilter<$PrismaModel>
    _max?: NestedEnumPartnerTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumAccountCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountCategory | EnumAccountCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AccountCategory[] | ListEnumAccountCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountCategory[] | ListEnumAccountCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountCategoryFilter<$PrismaModel> | $Enums.AccountCategory
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccountCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountCategory | EnumAccountCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AccountCategory[] | ListEnumAccountCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountCategory[] | ListEnumAccountCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AccountCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountCategoryFilter<$PrismaModel>
    _max?: NestedEnumAccountCategoryFilter<$PrismaModel>
  }

  export type NestedEnumJournalEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalEntryType | EnumJournalEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalEntryType[] | ListEnumJournalEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalEntryType[] | ListEnumJournalEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalEntryTypeFilter<$PrismaModel> | $Enums.JournalEntryType
  }

  export type NestedEnumJournalEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalEntryType | EnumJournalEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JournalEntryType[] | ListEnumJournalEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalEntryType[] | ListEnumJournalEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.JournalEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumJournalEntryTypeFilter<$PrismaModel>
  }

  export type NestedEnumVoucherStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherStatus | EnumVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherStatusFilter<$PrismaModel> | $Enums.VoucherStatus
  }

  export type NestedEnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type NestedEnumVoucherStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherStatus | EnumVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherStatus[] | ListEnumVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherStatusWithAggregatesFilter<$PrismaModel> | $Enums.VoucherStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherStatusFilter<$PrismaModel>
    _max?: NestedEnumVoucherStatusFilter<$PrismaModel>
  }

  export type NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type NestedEnumCardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CardType | EnumCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCardTypeFilter<$PrismaModel> | $Enums.CardType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumCardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardType | EnumCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCardTypeWithAggregatesFilter<$PrismaModel> | $Enums.CardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardTypeFilter<$PrismaModel>
    _max?: NestedEnumCardTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumQuotationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusFilter<$PrismaModel> | $Enums.QuotationStatus
  }

  export type NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationStatusFilter<$PrismaModel>
  }

  export type AccountCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput>
  }

  export type AccountCreateManyCompanyInputEnvelope = {
    data: AccountCreateManyCompanyInput | AccountCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCompanyInput = {
    id?: string
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId?: string | null
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogCreateManyCompanyInputEnvelope = {
    data: AuditLogCreateManyCompanyInput | AuditLogCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BeneficiaryCreateWithoutCompanyInput = {
    id?: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    partner?: PartnerCreateNestedOneWithoutBeneficiariesInput
    transactions?: TransactionCreateNestedManyWithoutBeneficiaryInput
  }

  export type BeneficiaryUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    partnerId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutBeneficiaryInput
  }

  export type BeneficiaryCreateOrConnectWithoutCompanyInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutCompanyInput, BeneficiaryUncheckedCreateWithoutCompanyInput>
  }

  export type BeneficiaryCreateManyCompanyInputEnvelope = {
    data: BeneficiaryCreateManyCompanyInput | BeneficiaryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BranchCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput>
  }

  export type BranchCreateManyCompanyInputEnvelope = {
    data: BranchCreateManyCompanyInput | BranchCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DailyClosingCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDailyClosingsInput
    closedBy?: UserCreateNestedOneWithoutDailyClosingsInput
  }

  export type DailyClosingUncheckedCreateWithoutCompanyInput = {
    id?: string
    branchId: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyClosingCreateOrConnectWithoutCompanyInput = {
    where: DailyClosingWhereUniqueInput
    create: XOR<DailyClosingCreateWithoutCompanyInput, DailyClosingUncheckedCreateWithoutCompanyInput>
  }

  export type DailyClosingCreateManyCompanyInputEnvelope = {
    data: DailyClosingCreateManyCompanyInput | DailyClosingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutCompanyInput = {
    id?: string
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutExpensesInput
    branch?: BranchCreateNestedOneWithoutExpensesInput
    category: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    enteredBy: UserCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutCompanyInput = {
    id?: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseCreateManyCompanyInputEnvelope = {
    data: ExpenseCreateManyCompanyInput | ExpenseCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCategoryCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    expenses?: ExpenseCreateNestedManyWithoutCategoryInput
    ledgerAccount?: AccountCreateNestedOneWithoutExpenseCategoriesInput
    voucherItems?: VoucherItemCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    ledgerAccountId?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCategoryInput
    voucherItems?: VoucherItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutCompanyInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseCategoryCreateManyCompanyInputEnvelope = {
    data: ExpenseCategoryCreateManyCompanyInput | ExpenseCategoryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type FinancialPeriodCreateWithoutCompanyInput = {
    id?: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    yearEndClosedAt?: Date | string | null
    accountingLockedBy?: UserCreateNestedOneWithoutAccountingLockedPeriodsInput
    lastUnlockedBy?: UserCreateNestedOneWithoutUnlockedPeriodsInput
    vatLockedBy?: UserCreateNestedOneWithoutVatLockedPeriodsInput
    yearEndClosedBy?: UserCreateNestedOneWithoutYearEndClosedPeriodsInput
  }

  export type FinancialPeriodUncheckedCreateWithoutCompanyInput = {
    id?: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodCreateOrConnectWithoutCompanyInput = {
    where: FinancialPeriodWhereUniqueInput
    create: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput>
  }

  export type FinancialPeriodCreateManyCompanyInputEnvelope = {
    data: FinancialPeriodCreateManyCompanyInput | FinancialPeriodCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCompanyInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: UserCreateNestedOneWithoutInvoicesInput
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    govtFeeAccount?: AccountCreateNestedOneWithoutInvoicesGovtFeeInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
    quotation?: QuotationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutCompanyInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceCreateManyCompanyInputEnvelope = {
    data: InvoiceCreateManyCompanyInput | InvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type JournalEntryCreateWithoutCompanyInput = {
    id?: string
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
    branch?: BranchCreateNestedOneWithoutJournalEntriesInput
    transactions?: LedgerTransactionCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUncheckedCreateWithoutCompanyInput = {
    id?: string
    branchId?: string | null
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
    transactions?: LedgerTransactionUncheckedCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryCreateOrConnectWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput>
  }

  export type JournalEntryCreateManyCompanyInputEnvelope = {
    data: JournalEntryCreateManyCompanyInput | JournalEntryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PartnerCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPartnerInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutPartnerInput
    transactions?: TransactionCreateNestedManyWithoutPartnerInput
    quotations?: QuotationCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPartnerInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutPartnerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPartnerInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutCompanyInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutCompanyInput, PartnerUncheckedCreateWithoutCompanyInput>
  }

  export type PartnerCreateManyCompanyInputEnvelope = {
    data: PartnerCreateManyCompanyInput | PartnerCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCompanyInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCompanyInput = {
    id?: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutCompanyInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput>
  }

  export type TransactionCreateManyCompanyInputEnvelope = {
    data: TransactionCreateManyCompanyInput | TransactionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutCompanyInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vouchers?: VoucherCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vouchers?: VoucherUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput>
  }

  export type VendorCreateManyCompanyInputEnvelope = {
    data: VendorCreateManyCompanyInput | VendorCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type VoucherCreateWithoutCompanyInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    account?: AccountCreateNestedOneWithoutVouchersInput
    branch?: BranchCreateNestedOneWithoutVouchersInput
    enteredBy: UserCreateNestedOneWithoutVouchersInput
    vendor?: VendorCreateNestedOneWithoutVouchersInput
    items?: VoucherItemCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutCompanyInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    items?: VoucherItemUncheckedCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutCompanyInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput>
  }

  export type VoucherCreateManyCompanyInputEnvelope = {
    data: VoucherCreateManyCompanyInput | VoucherCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type VoucherPaymentCreateWithoutCompanyInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    receiptNo: string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutVoucherPaymentsInput
    enteredBy: UserCreateNestedOneWithoutVoucherPaymentsInput
    voucher: VoucherCreateNestedOneWithoutPaymentsInput
  }

  export type VoucherPaymentUncheckedCreateWithoutCompanyInput = {
    id?: string
    voucherId: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    receiptNo: string
    enteredById: string
    createdAt?: Date | string
  }

  export type VoucherPaymentCreateOrConnectWithoutCompanyInput = {
    where: VoucherPaymentWhereUniqueInput
    create: XOR<VoucherPaymentCreateWithoutCompanyInput, VoucherPaymentUncheckedCreateWithoutCompanyInput>
  }

  export type VoucherPaymentCreateManyCompanyInputEnvelope = {
    data: VoucherPaymentCreateManyCompanyInput | VoucherPaymentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type WorkTypeCreateWithoutCompanyInput = {
    id?: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionCreateNestedManyWithoutWorkTypeInput
    quotationItems?: QuotationItemCreateNestedManyWithoutWorkTypeInput
  }

  export type WorkTypeUncheckedCreateWithoutCompanyInput = {
    id?: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutWorkTypeInput
    quotationItems?: QuotationItemUncheckedCreateNestedManyWithoutWorkTypeInput
  }

  export type WorkTypeCreateOrConnectWithoutCompanyInput = {
    where: WorkTypeWhereUniqueInput
    create: XOR<WorkTypeCreateWithoutCompanyInput, WorkTypeUncheckedCreateWithoutCompanyInput>
  }

  export type WorkTypeCreateManyCompanyInputEnvelope = {
    data: WorkTypeCreateManyCompanyInput | WorkTypeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BusinessCardCreateWithoutCompanyInput = {
    id?: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerAccount: AccountCreateNestedOneWithoutBusinessCardsInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutCardInput
  }

  export type BusinessCardUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerAccountId: string
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutCardInput
  }

  export type BusinessCardCreateOrConnectWithoutCompanyInput = {
    where: BusinessCardWhereUniqueInput
    create: XOR<BusinessCardCreateWithoutCompanyInput, BusinessCardUncheckedCreateWithoutCompanyInput>
  }

  export type BusinessCardCreateManyCompanyInputEnvelope = {
    data: BusinessCardCreateManyCompanyInput | BusinessCardCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutCompanyInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    branch?: BranchCreateNestedOneWithoutQuotationsInput
    partner?: PartnerCreateNestedOneWithoutQuotationsInput
    salesperson: UserCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceCreateNestedManyWithoutQuotationInput
    approvedBy?: UserCreateNestedOneWithoutApprovedQuotationsInput
  }

  export type QuotationUncheckedCreateWithoutCompanyInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutCompanyInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutCompanyInput, QuotationUncheckedCreateWithoutCompanyInput>
  }

  export type QuotationCreateManyCompanyInputEnvelope = {
    data: QuotationCreateManyCompanyInput | QuotationCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutCompanyInput, AccountUncheckedUpdateWithoutCompanyInput>
    create: XOR<AccountCreateWithoutCompanyInput, AccountUncheckedCreateWithoutCompanyInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutCompanyInput, AccountUncheckedUpdateWithoutCompanyInput>
  }

  export type AccountUpdateManyWithWhereWithoutCompanyInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    companyId?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    balance?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"Account"> | string | null
    bankName?: StringNullableFilter<"Account"> | string | null
    branchId?: StringNullableFilter<"Account"> | string | null
    category?: EnumAccountCategoryFilter<"Account"> | $Enums.AccountCategory
    code?: StringFilter<"Account"> | string
    iban?: StringNullableFilter<"Account"> | string | null
    isPostable?: BoolFilter<"Account"> | boolean
    isSystem?: BoolFilter<"Account"> | boolean
    linkedBranchIds?: StringNullableListFilter<"Account">
    merchantId?: StringNullableFilter<"Account"> | string | null
    parentAccountId?: StringNullableFilter<"Account"> | string | null
    swiftCode?: StringNullableFilter<"Account"> | string | null
    terminalId?: StringNullableFilter<"Account"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    recordId?: StringNullableFilter<"AuditLog"> | string | null
    recordType?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutCompanyInput, BeneficiaryUncheckedUpdateWithoutCompanyInput>
    create: XOR<BeneficiaryCreateWithoutCompanyInput, BeneficiaryUncheckedCreateWithoutCompanyInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutCompanyInput, BeneficiaryUncheckedUpdateWithoutCompanyInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutCompanyInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BeneficiaryScalarWhereInput = {
    AND?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
    OR?: BeneficiaryScalarWhereInput[]
    NOT?: BeneficiaryScalarWhereInput | BeneficiaryScalarWhereInput[]
    id?: StringFilter<"Beneficiary"> | string
    companyId?: StringFilter<"Beneficiary"> | string
    name?: StringFilter<"Beneficiary"> | string
    details?: StringNullableFilter<"Beneficiary"> | string | null
    phone?: StringNullableFilter<"Beneficiary"> | string | null
    email?: StringNullableFilter<"Beneficiary"> | string | null
    partnerId?: StringNullableFilter<"Beneficiary"> | string | null
  }

  export type BranchUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutCompanyInput, BranchUncheckedUpdateWithoutCompanyInput>
    create: XOR<BranchCreateWithoutCompanyInput, BranchUncheckedCreateWithoutCompanyInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutCompanyInput, BranchUncheckedUpdateWithoutCompanyInput>
  }

  export type BranchUpdateManyWithWhereWithoutCompanyInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: StringFilter<"Branch"> | string
    companyId?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    phone?: StringNullableFilter<"Branch"> | string | null
    isActive?: BoolFilter<"Branch"> | boolean
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    address?: StringNullableFilter<"Branch"> | string | null
    allowCrossBranch?: BoolFilter<"Branch"> | boolean
    cashCounterEnabled?: BoolFilter<"Branch"> | boolean
    email?: StringNullableFilter<"Branch"> | string | null
    emirate?: EnumEmirateFilter<"Branch"> | $Enums.Emirate
    googleMapLink?: StringNullableFilter<"Branch"> | string | null
    invoicePrefix?: StringNullableFilter<"Branch"> | string | null
    managerId?: StringNullableFilter<"Branch"> | string | null
    nextInvoiceNumber?: IntFilter<"Branch"> | number
    openingCashBalance?: FloatFilter<"Branch"> | number
    receiptPrefix?: StringNullableFilter<"Branch"> | string | null
    separateNumbering?: BoolFilter<"Branch"> | boolean
    type?: EnumBranchTypeFilter<"Branch"> | $Enums.BranchType
  }

  export type DailyClosingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DailyClosingWhereUniqueInput
    update: XOR<DailyClosingUpdateWithoutCompanyInput, DailyClosingUncheckedUpdateWithoutCompanyInput>
    create: XOR<DailyClosingCreateWithoutCompanyInput, DailyClosingUncheckedCreateWithoutCompanyInput>
  }

  export type DailyClosingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DailyClosingWhereUniqueInput
    data: XOR<DailyClosingUpdateWithoutCompanyInput, DailyClosingUncheckedUpdateWithoutCompanyInput>
  }

  export type DailyClosingUpdateManyWithWhereWithoutCompanyInput = {
    where: DailyClosingScalarWhereInput
    data: XOR<DailyClosingUpdateManyMutationInput, DailyClosingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DailyClosingScalarWhereInput = {
    AND?: DailyClosingScalarWhereInput | DailyClosingScalarWhereInput[]
    OR?: DailyClosingScalarWhereInput[]
    NOT?: DailyClosingScalarWhereInput | DailyClosingScalarWhereInput[]
    id?: StringFilter<"DailyClosing"> | string
    companyId?: StringFilter<"DailyClosing"> | string
    branchId?: StringFilter<"DailyClosing"> | string
    date?: DateTimeFilter<"DailyClosing"> | Date | string
    status?: EnumClosingStatusFilter<"DailyClosing"> | $Enums.ClosingStatus
    openingCash?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFilter<"DailyClosing"> | Decimal | DecimalJsLike | number | string
    closedById?: StringNullableFilter<"DailyClosing"> | string | null
    closedAt?: DateTimeNullableFilter<"DailyClosing"> | Date | string | null
    notes?: StringNullableFilter<"DailyClosing"> | string | null
    createdAt?: DateTimeFilter<"DailyClosing"> | Date | string
    updatedAt?: DateTimeFilter<"DailyClosing"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCompanyInput, ExpenseUncheckedUpdateWithoutCompanyInput>
    create: XOR<ExpenseCreateWithoutCompanyInput, ExpenseUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCompanyInput, ExpenseUncheckedUpdateWithoutCompanyInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCompanyInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    companyId?: StringFilter<"Expense"> | string
    branchId?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    categoryId?: StringFilter<"Expense"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"Expense"> | string | null
    enteredById?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type ExpenseCategoryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseCategoryWhereUniqueInput
    update: XOR<ExpenseCategoryUpdateWithoutCompanyInput, ExpenseCategoryUncheckedUpdateWithoutCompanyInput>
    create: XOR<ExpenseCategoryCreateWithoutCompanyInput, ExpenseCategoryUncheckedCreateWithoutCompanyInput>
  }

  export type ExpenseCategoryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ExpenseCategoryWhereUniqueInput
    data: XOR<ExpenseCategoryUpdateWithoutCompanyInput, ExpenseCategoryUncheckedUpdateWithoutCompanyInput>
  }

  export type ExpenseCategoryUpdateManyWithWhereWithoutCompanyInput = {
    where: ExpenseCategoryScalarWhereInput
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ExpenseCategoryScalarWhereInput = {
    AND?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    OR?: ExpenseCategoryScalarWhereInput[]
    NOT?: ExpenseCategoryScalarWhereInput | ExpenseCategoryScalarWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    companyId?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    description?: StringNullableFilter<"ExpenseCategory"> | string | null
    ledgerAccountId?: StringNullableFilter<"ExpenseCategory"> | string | null
  }

  export type FinancialPeriodUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FinancialPeriodWhereUniqueInput
    update: XOR<FinancialPeriodUpdateWithoutCompanyInput, FinancialPeriodUncheckedUpdateWithoutCompanyInput>
    create: XOR<FinancialPeriodCreateWithoutCompanyInput, FinancialPeriodUncheckedCreateWithoutCompanyInput>
  }

  export type FinancialPeriodUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FinancialPeriodWhereUniqueInput
    data: XOR<FinancialPeriodUpdateWithoutCompanyInput, FinancialPeriodUncheckedUpdateWithoutCompanyInput>
  }

  export type FinancialPeriodUpdateManyWithWhereWithoutCompanyInput = {
    where: FinancialPeriodScalarWhereInput
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FinancialPeriodScalarWhereInput = {
    AND?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
    OR?: FinancialPeriodScalarWhereInput[]
    NOT?: FinancialPeriodScalarWhereInput | FinancialPeriodScalarWhereInput[]
    id?: StringFilter<"FinancialPeriod"> | string
    companyId?: StringFilter<"FinancialPeriod"> | string
    year?: IntFilter<"FinancialPeriod"> | number
    month?: IntFilter<"FinancialPeriod"> | number
    createdAt?: DateTimeFilter<"FinancialPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialPeriod"> | Date | string
    accountingLocked?: BoolFilter<"FinancialPeriod"> | boolean
    accountingLockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    accountingLockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    isYearEndClosed?: BoolFilter<"FinancialPeriod"> | boolean
    lastUnlockReason?: StringNullableFilter<"FinancialPeriod"> | string | null
    lastUnlockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    lastUnlockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    periodEnd?: DateTimeFilter<"FinancialPeriod"> | Date | string
    periodStart?: DateTimeFilter<"FinancialPeriod"> | Date | string
    vatLocked?: BoolFilter<"FinancialPeriod"> | boolean
    vatLockedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    vatLockedById?: StringNullableFilter<"FinancialPeriod"> | string | null
    yearEndClosedAt?: DateTimeNullableFilter<"FinancialPeriod"> | Date | string | null
    yearEndClosedById?: StringNullableFilter<"FinancialPeriod"> | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCompanyInput, InvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCompanyInput, InvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNo?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: StringFilter<"Invoice"> | string
    branchId?: StringNullableFilter<"Invoice"> | string | null
    customerId?: StringNullableFilter<"Invoice"> | string | null
    customerName?: StringNullableFilter<"Invoice"> | string | null
    agentId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Invoice"> | $Enums.PaymentMethod
    paymentRef?: StringNullableFilter<"Invoice"> | string | null
    bankName?: StringNullableFilter<"Invoice"> | string | null
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    govtFeeAccountId?: StringNullableFilter<"Invoice"> | string | null
    govtFeeRef?: StringNullableFilter<"Invoice"> | string | null
    customerPhone?: StringNullableFilter<"Invoice"> | string | null
    customerEmail?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    quotationId?: StringNullableFilter<"Invoice"> | string | null
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutCompanyInput, JournalEntryUncheckedUpdateWithoutCompanyInput>
    create: XOR<JournalEntryCreateWithoutCompanyInput, JournalEntryUncheckedCreateWithoutCompanyInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutCompanyInput, JournalEntryUncheckedUpdateWithoutCompanyInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutCompanyInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type JournalEntryScalarWhereInput = {
    AND?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    OR?: JournalEntryScalarWhereInput[]
    NOT?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    companyId?: StringFilter<"JournalEntry"> | string
    branchId?: StringNullableFilter<"JournalEntry"> | string | null
    postingDate?: DateTimeFilter<"JournalEntry"> | Date | string
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    description?: StringNullableFilter<"JournalEntry"> | string | null
    type?: EnumJournalEntryTypeFilter<"JournalEntry"> | $Enums.JournalEntryType
    referenceType?: StringNullableFilter<"JournalEntry"> | string | null
    referenceId?: StringNullableFilter<"JournalEntry"> | string | null
    reversedEntryId?: StringNullableFilter<"JournalEntry"> | string | null
  }

  export type PartnerUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PartnerWhereUniqueInput
    update: XOR<PartnerUpdateWithoutCompanyInput, PartnerUncheckedUpdateWithoutCompanyInput>
    create: XOR<PartnerCreateWithoutCompanyInput, PartnerUncheckedCreateWithoutCompanyInput>
  }

  export type PartnerUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PartnerWhereUniqueInput
    data: XOR<PartnerUpdateWithoutCompanyInput, PartnerUncheckedUpdateWithoutCompanyInput>
  }

  export type PartnerUpdateManyWithWhereWithoutCompanyInput = {
    where: PartnerScalarWhereInput
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PartnerScalarWhereInput = {
    AND?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
    OR?: PartnerScalarWhereInput[]
    NOT?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
    id?: StringFilter<"Partner"> | string
    companyId?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    type?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    email?: StringNullableFilter<"Partner"> | string | null
    phone?: StringNullableFilter<"Partner"> | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCompanyInput, TransactionUncheckedUpdateWithoutCompanyInput>
    create: XOR<TransactionCreateWithoutCompanyInput, TransactionUncheckedCreateWithoutCompanyInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCompanyInput, TransactionUncheckedUpdateWithoutCompanyInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCompanyInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    companyId?: StringFilter<"Transaction"> | string
    branchId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    invNo?: StringNullableFilter<"Transaction"> | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    enteredById?: StringNullableFilter<"Transaction"> | string | null
    beneficiaryId?: StringNullableFilter<"Transaction"> | string | null
    partnerId?: StringNullableFilter<"Transaction"> | string | null
    workTypeId?: StringNullableFilter<"Transaction"> | string | null
    govFee?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    vat?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    receiptNo?: StringNullableFilter<"Transaction"> | string | null
    govtFeeAccountId?: StringNullableFilter<"Transaction"> | string | null
    govtFeeRef?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    cardId?: StringNullableFilter<"Transaction"> | string | null
    transactionId?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumPaymentStatusFilter<"Transaction"> | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFilter<"Transaction"> | $Enums.AdvanceStatus
    advanceAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    customerName?: StringNullableFilter<"Transaction"> | string | null
    applicantName?: StringNullableFilter<"Transaction"> | string | null
    details?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    isVatApplicable?: BoolFilter<"Transaction"> | boolean
    vatRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    quantity?: IntFilter<"Transaction"> | number
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    companyId?: StringFilter<"User"> | string
    branchId?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRole_LegacyFilter<"User"> | $Enums.UserRole_Legacy
    isActive?: BoolFilter<"User"> | boolean
    forcePasswordChange?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    lastLoginUserAgent?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    failedLoginResetAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type VendorUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutCompanyInput, VendorUncheckedUpdateWithoutCompanyInput>
    create: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutCompanyInput, VendorUncheckedUpdateWithoutCompanyInput>
  }

  export type VendorUpdateManyWithWhereWithoutCompanyInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    id?: StringFilter<"Vendor"> | string
    companyId?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    phone?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type VoucherUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutCompanyInput, VoucherUncheckedUpdateWithoutCompanyInput>
    create: XOR<VoucherCreateWithoutCompanyInput, VoucherUncheckedCreateWithoutCompanyInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutCompanyInput, VoucherUncheckedUpdateWithoutCompanyInput>
  }

  export type VoucherUpdateManyWithWhereWithoutCompanyInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VoucherScalarWhereInput = {
    AND?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    OR?: VoucherScalarWhereInput[]
    NOT?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    id?: StringFilter<"Voucher"> | string
    voucherNo?: StringFilter<"Voucher"> | string
    date?: DateTimeFilter<"Voucher"> | Date | string
    companyId?: StringFilter<"Voucher"> | string
    branchId?: StringNullableFilter<"Voucher"> | string | null
    description?: StringNullableFilter<"Voucher"> | string | null
    vendorId?: StringNullableFilter<"Voucher"> | string | null
    vendorName?: StringNullableFilter<"Voucher"> | string | null
    total?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFilter<"Voucher"> | $Enums.VoucherStatus
    type?: EnumVoucherTypeFilter<"Voucher"> | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFilter<"Voucher"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"Voucher"> | string | null
    enteredById?: StringFilter<"Voucher"> | string
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    billUrl?: StringNullableFilter<"Voucher"> | string | null
  }

  export type VoucherPaymentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VoucherPaymentWhereUniqueInput
    update: XOR<VoucherPaymentUpdateWithoutCompanyInput, VoucherPaymentUncheckedUpdateWithoutCompanyInput>
    create: XOR<VoucherPaymentCreateWithoutCompanyInput, VoucherPaymentUncheckedCreateWithoutCompanyInput>
  }

  export type VoucherPaymentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VoucherPaymentWhereUniqueInput
    data: XOR<VoucherPaymentUpdateWithoutCompanyInput, VoucherPaymentUncheckedUpdateWithoutCompanyInput>
  }

  export type VoucherPaymentUpdateManyWithWhereWithoutCompanyInput = {
    where: VoucherPaymentScalarWhereInput
    data: XOR<VoucherPaymentUpdateManyMutationInput, VoucherPaymentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VoucherPaymentScalarWhereInput = {
    AND?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
    OR?: VoucherPaymentScalarWhereInput[]
    NOT?: VoucherPaymentScalarWhereInput | VoucherPaymentScalarWhereInput[]
    id?: StringFilter<"VoucherPayment"> | string
    voucherId?: StringFilter<"VoucherPayment"> | string
    date?: DateTimeFilter<"VoucherPayment"> | Date | string
    amount?: DecimalFilter<"VoucherPayment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"VoucherPayment"> | $Enums.PaymentMethod
    accountId?: StringNullableFilter<"VoucherPayment"> | string | null
    receiptNo?: StringFilter<"VoucherPayment"> | string
    enteredById?: StringFilter<"VoucherPayment"> | string
    createdAt?: DateTimeFilter<"VoucherPayment"> | Date | string
    companyId?: StringFilter<"VoucherPayment"> | string
  }

  export type WorkTypeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: WorkTypeWhereUniqueInput
    update: XOR<WorkTypeUpdateWithoutCompanyInput, WorkTypeUncheckedUpdateWithoutCompanyInput>
    create: XOR<WorkTypeCreateWithoutCompanyInput, WorkTypeUncheckedCreateWithoutCompanyInput>
  }

  export type WorkTypeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: WorkTypeWhereUniqueInput
    data: XOR<WorkTypeUpdateWithoutCompanyInput, WorkTypeUncheckedUpdateWithoutCompanyInput>
  }

  export type WorkTypeUpdateManyWithWhereWithoutCompanyInput = {
    where: WorkTypeScalarWhereInput
    data: XOR<WorkTypeUpdateManyMutationInput, WorkTypeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WorkTypeScalarWhereInput = {
    AND?: WorkTypeScalarWhereInput | WorkTypeScalarWhereInput[]
    OR?: WorkTypeScalarWhereInput[]
    NOT?: WorkTypeScalarWhereInput | WorkTypeScalarWhereInput[]
    id?: StringFilter<"WorkType"> | string
    companyId?: StringFilter<"WorkType"> | string
    description?: StringFilter<"WorkType"> | string
    presetGovFee?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFilter<"WorkType"> | boolean
    vatRate?: DecimalFilter<"WorkType"> | Decimal | DecimalJsLike | number | string
  }

  export type BusinessCardUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BusinessCardWhereUniqueInput
    update: XOR<BusinessCardUpdateWithoutCompanyInput, BusinessCardUncheckedUpdateWithoutCompanyInput>
    create: XOR<BusinessCardCreateWithoutCompanyInput, BusinessCardUncheckedCreateWithoutCompanyInput>
  }

  export type BusinessCardUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BusinessCardWhereUniqueInput
    data: XOR<BusinessCardUpdateWithoutCompanyInput, BusinessCardUncheckedUpdateWithoutCompanyInput>
  }

  export type BusinessCardUpdateManyWithWhereWithoutCompanyInput = {
    where: BusinessCardScalarWhereInput
    data: XOR<BusinessCardUpdateManyMutationInput, BusinessCardUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BusinessCardScalarWhereInput = {
    AND?: BusinessCardScalarWhereInput | BusinessCardScalarWhereInput[]
    OR?: BusinessCardScalarWhereInput[]
    NOT?: BusinessCardScalarWhereInput | BusinessCardScalarWhereInput[]
    id?: StringFilter<"BusinessCard"> | string
    companyId?: StringFilter<"BusinessCard"> | string
    name?: StringFilter<"BusinessCard"> | string
    type?: EnumCardTypeFilter<"BusinessCard"> | $Enums.CardType
    issuingBank?: StringFilter<"BusinessCard"> | string
    last4Digits?: StringFilter<"BusinessCard"> | string
    creditLimit?: DecimalNullableFilter<"BusinessCard"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"BusinessCard"> | string
    statementCycleDay?: IntNullableFilter<"BusinessCard"> | number | null
    paymentDueDays?: IntNullableFilter<"BusinessCard"> | number | null
    isActive?: BoolFilter<"BusinessCard"> | boolean
    createdAt?: DateTimeFilter<"BusinessCard"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessCard"> | Date | string
    ledgerAccountId?: StringFilter<"BusinessCard"> | string
  }

  export type QuotationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutCompanyInput, QuotationUncheckedUpdateWithoutCompanyInput>
    create: XOR<QuotationCreateWithoutCompanyInput, QuotationUncheckedCreateWithoutCompanyInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutCompanyInput, QuotationUncheckedUpdateWithoutCompanyInput>
  }

  export type QuotationUpdateManyWithWhereWithoutCompanyInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutCompanyInput>
  }

  export type QuotationScalarWhereInput = {
    AND?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
    OR?: QuotationScalarWhereInput[]
    NOT?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
    id?: StringFilter<"Quotation"> | string
    quotationNo?: StringFilter<"Quotation"> | string
    date?: DateTimeFilter<"Quotation"> | Date | string
    validUntil?: DateTimeFilter<"Quotation"> | Date | string
    companyId?: StringFilter<"Quotation"> | string
    branchId?: StringNullableFilter<"Quotation"> | string | null
    partnerId?: StringNullableFilter<"Quotation"> | string | null
    beneficiaryName?: StringNullableFilter<"Quotation"> | string | null
    salespersonId?: StringFilter<"Quotation"> | string
    currency?: StringFilter<"Quotation"> | string
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    subtotal?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Quotation"> | string | null
    termsAndConditions?: StringNullableFilter<"Quotation"> | string | null
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
    sentAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    convertedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    approvedById?: StringNullableFilter<"Quotation"> | string | null
    approvedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    invoicedAmount?: DecimalFilter<"Quotation"> | Decimal | DecimalJsLike | number | string
    deletedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
  }

  export type BranchCreateWithoutDailyClosingsInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDailyClosingsInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDailyClosingsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDailyClosingsInput, BranchUncheckedCreateWithoutDailyClosingsInput>
  }

  export type UserCreateWithoutDailyClosingsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutDailyClosingsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutDailyClosingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyClosingsInput, UserUncheckedCreateWithoutDailyClosingsInput>
  }

  export type CompanyCreateWithoutDailyClosingsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDailyClosingsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDailyClosingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDailyClosingsInput, CompanyUncheckedCreateWithoutDailyClosingsInput>
  }

  export type BranchUpsertWithoutDailyClosingsInput = {
    update: XOR<BranchUpdateWithoutDailyClosingsInput, BranchUncheckedUpdateWithoutDailyClosingsInput>
    create: XOR<BranchCreateWithoutDailyClosingsInput, BranchUncheckedCreateWithoutDailyClosingsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDailyClosingsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDailyClosingsInput, BranchUncheckedUpdateWithoutDailyClosingsInput>
  }

  export type BranchUpdateWithoutDailyClosingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDailyClosingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutDailyClosingsInput = {
    update: XOR<UserUpdateWithoutDailyClosingsInput, UserUncheckedUpdateWithoutDailyClosingsInput>
    create: XOR<UserCreateWithoutDailyClosingsInput, UserUncheckedCreateWithoutDailyClosingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyClosingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyClosingsInput, UserUncheckedUpdateWithoutDailyClosingsInput>
  }

  export type UserUpdateWithoutDailyClosingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyClosingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type CompanyUpsertWithoutDailyClosingsInput = {
    update: XOR<CompanyUpdateWithoutDailyClosingsInput, CompanyUncheckedUpdateWithoutDailyClosingsInput>
    create: XOR<CompanyCreateWithoutDailyClosingsInput, CompanyUncheckedCreateWithoutDailyClosingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDailyClosingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDailyClosingsInput, CompanyUncheckedUpdateWithoutDailyClosingsInput>
  }

  export type CompanyUpdateWithoutDailyClosingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDailyClosingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutBranchesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBranchesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBranchesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
  }

  export type UserCreateWithoutManagedBranchesInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutManagedBranchesInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutManagedBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedBranchesInput, UserUncheckedCreateWithoutManagedBranchesInput>
  }

  export type DailyClosingCreateWithoutBranchInput = {
    id?: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedBy?: UserCreateNestedOneWithoutDailyClosingsInput
    company: CompanyCreateNestedOneWithoutDailyClosingsInput
  }

  export type DailyClosingUncheckedCreateWithoutBranchInput = {
    id?: string
    companyId: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyClosingCreateOrConnectWithoutBranchInput = {
    where: DailyClosingWhereUniqueInput
    create: XOR<DailyClosingCreateWithoutBranchInput, DailyClosingUncheckedCreateWithoutBranchInput>
  }

  export type DailyClosingCreateManyBranchInputEnvelope = {
    data: DailyClosingCreateManyBranchInput | DailyClosingCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutBranchInput = {
    id?: string
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutExpensesInput
    category: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    company: CompanyCreateNestedOneWithoutExpensesInput
    enteredBy: UserCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutBranchInput = {
    id?: string
    companyId: string
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput>
  }

  export type ExpenseCreateManyBranchInputEnvelope = {
    data: ExpenseCreateManyBranchInput | ExpenseCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutBranchInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: UserCreateNestedOneWithoutInvoicesInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
    govtFeeAccount?: AccountCreateNestedOneWithoutInvoicesGovtFeeInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
    quotation?: QuotationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutBranchInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput>
  }

  export type InvoiceCreateManyBranchInputEnvelope = {
    data: InvoiceCreateManyBranchInput | InvoiceCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type JournalEntryCreateWithoutBranchInput = {
    id?: string
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
    company: CompanyCreateNestedOneWithoutJournalEntriesInput
    transactions?: LedgerTransactionCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryUncheckedCreateWithoutBranchInput = {
    id?: string
    companyId: string
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
    transactions?: LedgerTransactionUncheckedCreateNestedManyWithoutJournalEntryInput
  }

  export type JournalEntryCreateOrConnectWithoutBranchInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutBranchInput, JournalEntryUncheckedCreateWithoutBranchInput>
  }

  export type JournalEntryCreateManyBranchInputEnvelope = {
    data: JournalEntryCreateManyBranchInput | JournalEntryCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type LedgerTransactionCreateWithoutBranchInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    companyId: string
    account: AccountCreateNestedOneWithoutLedgerTransactionsInput
    journalEntry: JournalEntryCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutLedgerTransactionsInput
    card?: BusinessCardCreateNestedOneWithoutLedgerTransactionsInput
  }

  export type LedgerTransactionUncheckedCreateWithoutBranchInput = {
    id?: string
    journalEntryId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    cardId?: string | null
  }

  export type LedgerTransactionCreateOrConnectWithoutBranchInput = {
    where: LedgerTransactionWhereUniqueInput
    create: XOR<LedgerTransactionCreateWithoutBranchInput, LedgerTransactionUncheckedCreateWithoutBranchInput>
  }

  export type LedgerTransactionCreateManyBranchInputEnvelope = {
    data: LedgerTransactionCreateManyBranchInput | LedgerTransactionCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutBranchInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutBranchInput = {
    id?: string
    companyId: string
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutBranchInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput>
  }

  export type TransactionCreateManyBranchInputEnvelope = {
    data: TransactionCreateManyBranchInput | TransactionCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBranchInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type VoucherCreateWithoutBranchInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    account?: AccountCreateNestedOneWithoutVouchersInput
    company: CompanyCreateNestedOneWithoutVouchersInput
    enteredBy: UserCreateNestedOneWithoutVouchersInput
    vendor?: VendorCreateNestedOneWithoutVouchersInput
    items?: VoucherItemCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutBranchInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    items?: VoucherItemUncheckedCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutBranchInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutBranchInput, VoucherUncheckedCreateWithoutBranchInput>
  }

  export type VoucherCreateManyBranchInputEnvelope = {
    data: VoucherCreateManyBranchInput | VoucherCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutBranchInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutQuotationsInput
    partner?: PartnerCreateNestedOneWithoutQuotationsInput
    salesperson: UserCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceCreateNestedManyWithoutQuotationInput
    approvedBy?: UserCreateNestedOneWithoutApprovedQuotationsInput
  }

  export type QuotationUncheckedCreateWithoutBranchInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutBranchInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutBranchInput, QuotationUncheckedCreateWithoutBranchInput>
  }

  export type QuotationCreateManyBranchInputEnvelope = {
    data: QuotationCreateManyBranchInput | QuotationCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutBranchesInput = {
    update: XOR<CompanyUpdateWithoutBranchesInput, CompanyUncheckedUpdateWithoutBranchesInput>
    create: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBranchesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBranchesInput, CompanyUncheckedUpdateWithoutBranchesInput>
  }

  export type CompanyUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutManagedBranchesInput = {
    update: XOR<UserUpdateWithoutManagedBranchesInput, UserUncheckedUpdateWithoutManagedBranchesInput>
    create: XOR<UserCreateWithoutManagedBranchesInput, UserUncheckedCreateWithoutManagedBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedBranchesInput, UserUncheckedUpdateWithoutManagedBranchesInput>
  }

  export type UserUpdateWithoutManagedBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type DailyClosingUpsertWithWhereUniqueWithoutBranchInput = {
    where: DailyClosingWhereUniqueInput
    update: XOR<DailyClosingUpdateWithoutBranchInput, DailyClosingUncheckedUpdateWithoutBranchInput>
    create: XOR<DailyClosingCreateWithoutBranchInput, DailyClosingUncheckedCreateWithoutBranchInput>
  }

  export type DailyClosingUpdateWithWhereUniqueWithoutBranchInput = {
    where: DailyClosingWhereUniqueInput
    data: XOR<DailyClosingUpdateWithoutBranchInput, DailyClosingUncheckedUpdateWithoutBranchInput>
  }

  export type DailyClosingUpdateManyWithWhereWithoutBranchInput = {
    where: DailyClosingScalarWhereInput
    data: XOR<DailyClosingUpdateManyMutationInput, DailyClosingUncheckedUpdateManyWithoutBranchInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutBranchInput, ExpenseUncheckedUpdateWithoutBranchInput>
    create: XOR<ExpenseCreateWithoutBranchInput, ExpenseUncheckedCreateWithoutBranchInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutBranchInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutBranchInput, ExpenseUncheckedUpdateWithoutBranchInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutBranchInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutBranchInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutBranchInput, InvoiceUncheckedUpdateWithoutBranchInput>
    create: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutBranchInput, InvoiceUncheckedUpdateWithoutBranchInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutBranchInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutBranchInput>
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutBranchInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutBranchInput, JournalEntryUncheckedUpdateWithoutBranchInput>
    create: XOR<JournalEntryCreateWithoutBranchInput, JournalEntryUncheckedCreateWithoutBranchInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutBranchInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutBranchInput, JournalEntryUncheckedUpdateWithoutBranchInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutBranchInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutBranchInput>
  }

  export type LedgerTransactionUpsertWithWhereUniqueWithoutBranchInput = {
    where: LedgerTransactionWhereUniqueInput
    update: XOR<LedgerTransactionUpdateWithoutBranchInput, LedgerTransactionUncheckedUpdateWithoutBranchInput>
    create: XOR<LedgerTransactionCreateWithoutBranchInput, LedgerTransactionUncheckedCreateWithoutBranchInput>
  }

  export type LedgerTransactionUpdateWithWhereUniqueWithoutBranchInput = {
    where: LedgerTransactionWhereUniqueInput
    data: XOR<LedgerTransactionUpdateWithoutBranchInput, LedgerTransactionUncheckedUpdateWithoutBranchInput>
  }

  export type LedgerTransactionUpdateManyWithWhereWithoutBranchInput = {
    where: LedgerTransactionScalarWhereInput
    data: XOR<LedgerTransactionUpdateManyMutationInput, LedgerTransactionUncheckedUpdateManyWithoutBranchInput>
  }

  export type LedgerTransactionScalarWhereInput = {
    AND?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
    OR?: LedgerTransactionScalarWhereInput[]
    NOT?: LedgerTransactionScalarWhereInput | LedgerTransactionScalarWhereInput[]
    id?: StringFilter<"LedgerTransaction"> | string
    journalEntryId?: StringFilter<"LedgerTransaction"> | string
    accountId?: StringFilter<"LedgerTransaction"> | string
    debit?: DecimalFilter<"LedgerTransaction"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"LedgerTransaction"> | Decimal | DecimalJsLike | number | string
    partnerId?: StringNullableFilter<"LedgerTransaction"> | string | null
    companyId?: StringFilter<"LedgerTransaction"> | string
    branchId?: StringNullableFilter<"LedgerTransaction"> | string | null
    cardId?: StringNullableFilter<"LedgerTransaction"> | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutBranchInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBranchInput, TransactionUncheckedUpdateWithoutBranchInput>
    create: XOR<TransactionCreateWithoutBranchInput, TransactionUncheckedCreateWithoutBranchInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBranchInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBranchInput, TransactionUncheckedUpdateWithoutBranchInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBranchInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type VoucherUpsertWithWhereUniqueWithoutBranchInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutBranchInput, VoucherUncheckedUpdateWithoutBranchInput>
    create: XOR<VoucherCreateWithoutBranchInput, VoucherUncheckedCreateWithoutBranchInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutBranchInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutBranchInput, VoucherUncheckedUpdateWithoutBranchInput>
  }

  export type VoucherUpdateManyWithWhereWithoutBranchInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutBranchInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutBranchInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutBranchInput, QuotationUncheckedUpdateWithoutBranchInput>
    create: XOR<QuotationCreateWithoutBranchInput, QuotationUncheckedCreateWithoutBranchInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutBranchInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutBranchInput, QuotationUncheckedUpdateWithoutBranchInput>
  }

  export type QuotationUpdateManyWithWhereWithoutBranchInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutBranchInput>
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    id?: string
    name: string
    module: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    module: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type ApprovalRequestCreateWithoutApproverInput = {
    id?: string
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutApprovalRequestsInput
  }

  export type ApprovalRequestUncheckedCreateWithoutApproverInput = {
    id?: string
    requesterId: string
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestCreateOrConnectWithoutApproverInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutApproverInput, ApprovalRequestUncheckedCreateWithoutApproverInput>
  }

  export type ApprovalRequestCreateManyApproverInputEnvelope = {
    data: ApprovalRequestCreateManyApproverInput | ApprovalRequestCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalRequestCreateWithoutRequesterInput = {
    id?: string
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutApprovalActionsInput
  }

  export type ApprovalRequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    approverId?: string | null
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestCreateOrConnectWithoutRequesterInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput>
  }

  export type ApprovalRequestCreateManyRequesterInputEnvelope = {
    data: ApprovalRequestCreateManyRequesterInput | ApprovalRequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BranchCreateWithoutManagerInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutManagerInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutManagerInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutManagerInput, BranchUncheckedCreateWithoutManagerInput>
  }

  export type BranchCreateManyManagerInputEnvelope = {
    data: BranchCreateManyManagerInput | BranchCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type DailyClosingCreateWithoutClosedByInput = {
    id?: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDailyClosingsInput
    company: CompanyCreateNestedOneWithoutDailyClosingsInput
  }

  export type DailyClosingUncheckedCreateWithoutClosedByInput = {
    id?: string
    companyId: string
    branchId: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyClosingCreateOrConnectWithoutClosedByInput = {
    where: DailyClosingWhereUniqueInput
    create: XOR<DailyClosingCreateWithoutClosedByInput, DailyClosingUncheckedCreateWithoutClosedByInput>
  }

  export type DailyClosingCreateManyClosedByInputEnvelope = {
    data: DailyClosingCreateManyClosedByInput | DailyClosingCreateManyClosedByInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutEnteredByInput = {
    id?: string
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutExpensesInput
    branch?: BranchCreateNestedOneWithoutExpensesInput
    category: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    company: CompanyCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutEnteredByInput = {
    id?: string
    companyId: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutEnteredByInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutEnteredByInput, ExpenseUncheckedCreateWithoutEnteredByInput>
  }

  export type ExpenseCreateManyEnteredByInputEnvelope = {
    data: ExpenseCreateManyEnteredByInput | ExpenseCreateManyEnteredByInput[]
    skipDuplicates?: boolean
  }

  export type FinancialPeriodCreateWithoutAccountingLockedByInput = {
    id?: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    yearEndClosedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutFinancialPeriodsInput
    lastUnlockedBy?: UserCreateNestedOneWithoutUnlockedPeriodsInput
    vatLockedBy?: UserCreateNestedOneWithoutVatLockedPeriodsInput
    yearEndClosedBy?: UserCreateNestedOneWithoutYearEndClosedPeriodsInput
  }

  export type FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodCreateOrConnectWithoutAccountingLockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    create: XOR<FinancialPeriodCreateWithoutAccountingLockedByInput, FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput>
  }

  export type FinancialPeriodCreateManyAccountingLockedByInputEnvelope = {
    data: FinancialPeriodCreateManyAccountingLockedByInput | FinancialPeriodCreateManyAccountingLockedByInput[]
    skipDuplicates?: boolean
  }

  export type FinancialPeriodCreateWithoutLastUnlockedByInput = {
    id?: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    yearEndClosedAt?: Date | string | null
    accountingLockedBy?: UserCreateNestedOneWithoutAccountingLockedPeriodsInput
    company: CompanyCreateNestedOneWithoutFinancialPeriodsInput
    vatLockedBy?: UserCreateNestedOneWithoutVatLockedPeriodsInput
    yearEndClosedBy?: UserCreateNestedOneWithoutYearEndClosedPeriodsInput
  }

  export type FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodCreateOrConnectWithoutLastUnlockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    create: XOR<FinancialPeriodCreateWithoutLastUnlockedByInput, FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput>
  }

  export type FinancialPeriodCreateManyLastUnlockedByInputEnvelope = {
    data: FinancialPeriodCreateManyLastUnlockedByInput | FinancialPeriodCreateManyLastUnlockedByInput[]
    skipDuplicates?: boolean
  }

  export type FinancialPeriodCreateWithoutVatLockedByInput = {
    id?: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    yearEndClosedAt?: Date | string | null
    accountingLockedBy?: UserCreateNestedOneWithoutAccountingLockedPeriodsInput
    company: CompanyCreateNestedOneWithoutFinancialPeriodsInput
    lastUnlockedBy?: UserCreateNestedOneWithoutUnlockedPeriodsInput
    yearEndClosedBy?: UserCreateNestedOneWithoutYearEndClosedPeriodsInput
  }

  export type FinancialPeriodUncheckedCreateWithoutVatLockedByInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodCreateOrConnectWithoutVatLockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    create: XOR<FinancialPeriodCreateWithoutVatLockedByInput, FinancialPeriodUncheckedCreateWithoutVatLockedByInput>
  }

  export type FinancialPeriodCreateManyVatLockedByInputEnvelope = {
    data: FinancialPeriodCreateManyVatLockedByInput | FinancialPeriodCreateManyVatLockedByInput[]
    skipDuplicates?: boolean
  }

  export type FinancialPeriodCreateWithoutYearEndClosedByInput = {
    id?: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    yearEndClosedAt?: Date | string | null
    accountingLockedBy?: UserCreateNestedOneWithoutAccountingLockedPeriodsInput
    company: CompanyCreateNestedOneWithoutFinancialPeriodsInput
    lastUnlockedBy?: UserCreateNestedOneWithoutUnlockedPeriodsInput
    vatLockedBy?: UserCreateNestedOneWithoutVatLockedPeriodsInput
  }

  export type FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
  }

  export type FinancialPeriodCreateOrConnectWithoutYearEndClosedByInput = {
    where: FinancialPeriodWhereUniqueInput
    create: XOR<FinancialPeriodCreateWithoutYearEndClosedByInput, FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput>
  }

  export type FinancialPeriodCreateManyYearEndClosedByInputEnvelope = {
    data: FinancialPeriodCreateManyYearEndClosedByInput | FinancialPeriodCreateManyYearEndClosedByInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutAgentInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
    govtFeeAccount?: AccountCreateNestedOneWithoutInvoicesGovtFeeInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
    quotation?: QuotationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutAgentInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutAgentInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAgentInput, InvoiceUncheckedCreateWithoutAgentInput>
  }

  export type InvoiceCreateManyAgentInputEnvelope = {
    data: InvoiceCreateManyAgentInput | InvoiceCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    lastActivity?: Date | string
    createdAt?: Date | string
    isValid?: boolean
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    lastActivity?: Date | string
    createdAt?: Date | string
    isValid?: boolean
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutEnteredByInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutEnteredByInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutEnteredByInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutEnteredByInput, TransactionUncheckedCreateWithoutEnteredByInput>
  }

  export type TransactionCreateManyEnteredByInputEnvelope = {
    data: TransactionCreateManyEnteredByInput | TransactionCreateManyEnteredByInput[]
    skipDuplicates?: boolean
  }

  export type BranchCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoucherCreateWithoutEnteredByInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    account?: AccountCreateNestedOneWithoutVouchersInput
    branch?: BranchCreateNestedOneWithoutVouchersInput
    company: CompanyCreateNestedOneWithoutVouchersInput
    vendor?: VendorCreateNestedOneWithoutVouchersInput
    items?: VoucherItemCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutEnteredByInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    items?: VoucherItemUncheckedCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutEnteredByInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutEnteredByInput, VoucherUncheckedCreateWithoutEnteredByInput>
  }

  export type VoucherCreateManyEnteredByInputEnvelope = {
    data: VoucherCreateManyEnteredByInput | VoucherCreateManyEnteredByInput[]
    skipDuplicates?: boolean
  }

  export type VoucherPaymentCreateWithoutEnteredByInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    receiptNo: string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutVoucherPaymentsInput
    company: CompanyCreateNestedOneWithoutVoucherPaymentsInput
    voucher: VoucherCreateNestedOneWithoutPaymentsInput
  }

  export type VoucherPaymentUncheckedCreateWithoutEnteredByInput = {
    id?: string
    voucherId: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    receiptNo: string
    createdAt?: Date | string
    companyId: string
  }

  export type VoucherPaymentCreateOrConnectWithoutEnteredByInput = {
    where: VoucherPaymentWhereUniqueInput
    create: XOR<VoucherPaymentCreateWithoutEnteredByInput, VoucherPaymentUncheckedCreateWithoutEnteredByInput>
  }

  export type VoucherPaymentCreateManyEnteredByInputEnvelope = {
    data: VoucherPaymentCreateManyEnteredByInput | VoucherPaymentCreateManyEnteredByInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutSalespersonInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutQuotationsInput
    branch?: BranchCreateNestedOneWithoutQuotationsInput
    partner?: PartnerCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceCreateNestedManyWithoutQuotationInput
    approvedBy?: UserCreateNestedOneWithoutApprovedQuotationsInput
  }

  export type QuotationUncheckedCreateWithoutSalespersonInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutSalespersonInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutSalespersonInput, QuotationUncheckedCreateWithoutSalespersonInput>
  }

  export type QuotationCreateManySalespersonInputEnvelope = {
    data: QuotationCreateManySalespersonInput | QuotationCreateManySalespersonInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutApprovedByInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutQuotationsInput
    branch?: BranchCreateNestedOneWithoutQuotationsInput
    partner?: PartnerCreateNestedOneWithoutQuotationsInput
    salesperson: UserCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutApprovedByInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutApprovedByInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput>
  }

  export type QuotationCreateManyApprovedByInputEnvelope = {
    data: QuotationCreateManyApprovedByInput | QuotationCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutApproverInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutApproverInput, ApprovalRequestUncheckedUpdateWithoutApproverInput>
    create: XOR<ApprovalRequestCreateWithoutApproverInput, ApprovalRequestUncheckedCreateWithoutApproverInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutApproverInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutApproverInput, ApprovalRequestUncheckedUpdateWithoutApproverInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutApproverInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutApproverInput>
  }

  export type ApprovalRequestScalarWhereInput = {
    AND?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
    OR?: ApprovalRequestScalarWhereInput[]
    NOT?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
    id?: StringFilter<"ApprovalRequest"> | string
    requesterId?: StringFilter<"ApprovalRequest"> | string
    approverId?: StringNullableFilter<"ApprovalRequest"> | string | null
    module?: StringFilter<"ApprovalRequest"> | string
    action?: StringFilter<"ApprovalRequest"> | string
    recordId?: StringFilter<"ApprovalRequest"> | string
    recordType?: StringFilter<"ApprovalRequest"> | string
    reason?: StringFilter<"ApprovalRequest"> | string
    status?: EnumApprovalStatusFilter<"ApprovalRequest"> | $Enums.ApprovalStatus
    approvedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    comments?: StringNullableFilter<"ApprovalRequest"> | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutRequesterInput, ApprovalRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutRequesterInput, ApprovalRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type BranchUpsertWithWhereUniqueWithoutManagerInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutManagerInput, BranchUncheckedUpdateWithoutManagerInput>
    create: XOR<BranchCreateWithoutManagerInput, BranchUncheckedCreateWithoutManagerInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutManagerInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutManagerInput, BranchUncheckedUpdateWithoutManagerInput>
  }

  export type BranchUpdateManyWithWhereWithoutManagerInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutManagerInput>
  }

  export type DailyClosingUpsertWithWhereUniqueWithoutClosedByInput = {
    where: DailyClosingWhereUniqueInput
    update: XOR<DailyClosingUpdateWithoutClosedByInput, DailyClosingUncheckedUpdateWithoutClosedByInput>
    create: XOR<DailyClosingCreateWithoutClosedByInput, DailyClosingUncheckedCreateWithoutClosedByInput>
  }

  export type DailyClosingUpdateWithWhereUniqueWithoutClosedByInput = {
    where: DailyClosingWhereUniqueInput
    data: XOR<DailyClosingUpdateWithoutClosedByInput, DailyClosingUncheckedUpdateWithoutClosedByInput>
  }

  export type DailyClosingUpdateManyWithWhereWithoutClosedByInput = {
    where: DailyClosingScalarWhereInput
    data: XOR<DailyClosingUpdateManyMutationInput, DailyClosingUncheckedUpdateManyWithoutClosedByInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutEnteredByInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutEnteredByInput, ExpenseUncheckedUpdateWithoutEnteredByInput>
    create: XOR<ExpenseCreateWithoutEnteredByInput, ExpenseUncheckedCreateWithoutEnteredByInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutEnteredByInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutEnteredByInput, ExpenseUncheckedUpdateWithoutEnteredByInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutEnteredByInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutEnteredByInput>
  }

  export type FinancialPeriodUpsertWithWhereUniqueWithoutAccountingLockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    update: XOR<FinancialPeriodUpdateWithoutAccountingLockedByInput, FinancialPeriodUncheckedUpdateWithoutAccountingLockedByInput>
    create: XOR<FinancialPeriodCreateWithoutAccountingLockedByInput, FinancialPeriodUncheckedCreateWithoutAccountingLockedByInput>
  }

  export type FinancialPeriodUpdateWithWhereUniqueWithoutAccountingLockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    data: XOR<FinancialPeriodUpdateWithoutAccountingLockedByInput, FinancialPeriodUncheckedUpdateWithoutAccountingLockedByInput>
  }

  export type FinancialPeriodUpdateManyWithWhereWithoutAccountingLockedByInput = {
    where: FinancialPeriodScalarWhereInput
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByInput>
  }

  export type FinancialPeriodUpsertWithWhereUniqueWithoutLastUnlockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    update: XOR<FinancialPeriodUpdateWithoutLastUnlockedByInput, FinancialPeriodUncheckedUpdateWithoutLastUnlockedByInput>
    create: XOR<FinancialPeriodCreateWithoutLastUnlockedByInput, FinancialPeriodUncheckedCreateWithoutLastUnlockedByInput>
  }

  export type FinancialPeriodUpdateWithWhereUniqueWithoutLastUnlockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    data: XOR<FinancialPeriodUpdateWithoutLastUnlockedByInput, FinancialPeriodUncheckedUpdateWithoutLastUnlockedByInput>
  }

  export type FinancialPeriodUpdateManyWithWhereWithoutLastUnlockedByInput = {
    where: FinancialPeriodScalarWhereInput
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByInput>
  }

  export type FinancialPeriodUpsertWithWhereUniqueWithoutVatLockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    update: XOR<FinancialPeriodUpdateWithoutVatLockedByInput, FinancialPeriodUncheckedUpdateWithoutVatLockedByInput>
    create: XOR<FinancialPeriodCreateWithoutVatLockedByInput, FinancialPeriodUncheckedCreateWithoutVatLockedByInput>
  }

  export type FinancialPeriodUpdateWithWhereUniqueWithoutVatLockedByInput = {
    where: FinancialPeriodWhereUniqueInput
    data: XOR<FinancialPeriodUpdateWithoutVatLockedByInput, FinancialPeriodUncheckedUpdateWithoutVatLockedByInput>
  }

  export type FinancialPeriodUpdateManyWithWhereWithoutVatLockedByInput = {
    where: FinancialPeriodScalarWhereInput
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyWithoutVatLockedByInput>
  }

  export type FinancialPeriodUpsertWithWhereUniqueWithoutYearEndClosedByInput = {
    where: FinancialPeriodWhereUniqueInput
    update: XOR<FinancialPeriodUpdateWithoutYearEndClosedByInput, FinancialPeriodUncheckedUpdateWithoutYearEndClosedByInput>
    create: XOR<FinancialPeriodCreateWithoutYearEndClosedByInput, FinancialPeriodUncheckedCreateWithoutYearEndClosedByInput>
  }

  export type FinancialPeriodUpdateWithWhereUniqueWithoutYearEndClosedByInput = {
    where: FinancialPeriodWhereUniqueInput
    data: XOR<FinancialPeriodUpdateWithoutYearEndClosedByInput, FinancialPeriodUncheckedUpdateWithoutYearEndClosedByInput>
  }

  export type FinancialPeriodUpdateManyWithWhereWithoutYearEndClosedByInput = {
    where: FinancialPeriodScalarWhereInput
    data: XOR<FinancialPeriodUpdateManyMutationInput, FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutAgentInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutAgentInput, InvoiceUncheckedUpdateWithoutAgentInput>
    create: XOR<InvoiceCreateWithoutAgentInput, InvoiceUncheckedCreateWithoutAgentInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutAgentInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutAgentInput, InvoiceUncheckedUpdateWithoutAgentInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutAgentInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutAgentInput>
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    ipAddress?: StringNullableFilter<"PasswordResetToken"> | string | null
    userAgent?: StringNullableFilter<"PasswordResetToken"> | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    isValid?: BoolFilter<"Session"> | boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutEnteredByInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutEnteredByInput, TransactionUncheckedUpdateWithoutEnteredByInput>
    create: XOR<TransactionCreateWithoutEnteredByInput, TransactionUncheckedCreateWithoutEnteredByInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutEnteredByInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutEnteredByInput, TransactionUncheckedUpdateWithoutEnteredByInput>
  }

  export type TransactionUpdateManyWithWhereWithoutEnteredByInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutEnteredByInput>
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type VoucherUpsertWithWhereUniqueWithoutEnteredByInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutEnteredByInput, VoucherUncheckedUpdateWithoutEnteredByInput>
    create: XOR<VoucherCreateWithoutEnteredByInput, VoucherUncheckedCreateWithoutEnteredByInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutEnteredByInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutEnteredByInput, VoucherUncheckedUpdateWithoutEnteredByInput>
  }

  export type VoucherUpdateManyWithWhereWithoutEnteredByInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutEnteredByInput>
  }

  export type VoucherPaymentUpsertWithWhereUniqueWithoutEnteredByInput = {
    where: VoucherPaymentWhereUniqueInput
    update: XOR<VoucherPaymentUpdateWithoutEnteredByInput, VoucherPaymentUncheckedUpdateWithoutEnteredByInput>
    create: XOR<VoucherPaymentCreateWithoutEnteredByInput, VoucherPaymentUncheckedCreateWithoutEnteredByInput>
  }

  export type VoucherPaymentUpdateWithWhereUniqueWithoutEnteredByInput = {
    where: VoucherPaymentWhereUniqueInput
    data: XOR<VoucherPaymentUpdateWithoutEnteredByInput, VoucherPaymentUncheckedUpdateWithoutEnteredByInput>
  }

  export type VoucherPaymentUpdateManyWithWhereWithoutEnteredByInput = {
    where: VoucherPaymentScalarWhereInput
    data: XOR<VoucherPaymentUpdateManyMutationInput, VoucherPaymentUncheckedUpdateManyWithoutEnteredByInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutSalespersonInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutSalespersonInput, QuotationUncheckedUpdateWithoutSalespersonInput>
    create: XOR<QuotationCreateWithoutSalespersonInput, QuotationUncheckedCreateWithoutSalespersonInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutSalespersonInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutSalespersonInput, QuotationUncheckedUpdateWithoutSalespersonInput>
  }

  export type QuotationUpdateManyWithWhereWithoutSalespersonInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutSalespersonInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutApprovedByInput, QuotationUncheckedUpdateWithoutApprovedByInput>
    create: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutApprovedByInput, QuotationUncheckedUpdateWithoutApprovedByInput>
  }

  export type QuotationUpdateManyWithWhereWithoutApprovedByInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type CompanyCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type CompanyUpsertWithoutAuditLogsInput = {
    update: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateWithoutApprovalActionsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutApprovalActionsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutApprovalActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalActionsInput, UserUncheckedCreateWithoutApprovalActionsInput>
  }

  export type UserCreateWithoutApprovalRequestsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutApprovalRequestsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutApprovalRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalRequestsInput, UserUncheckedCreateWithoutApprovalRequestsInput>
  }

  export type UserUpsertWithoutApprovalActionsInput = {
    update: XOR<UserUpdateWithoutApprovalActionsInput, UserUncheckedUpdateWithoutApprovalActionsInput>
    create: XOR<UserCreateWithoutApprovalActionsInput, UserUncheckedCreateWithoutApprovalActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalActionsInput, UserUncheckedUpdateWithoutApprovalActionsInput>
  }

  export type UserUpdateWithoutApprovalActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutApprovalRequestsInput = {
    update: XOR<UserUpdateWithoutApprovalRequestsInput, UserUncheckedUpdateWithoutApprovalRequestsInput>
    create: XOR<UserCreateWithoutApprovalRequestsInput, UserUncheckedCreateWithoutApprovalRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalRequestsInput, UserUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type UserUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateWithoutAccountingLockedPeriodsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutAccountingLockedPeriodsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutAccountingLockedPeriodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountingLockedPeriodsInput, UserUncheckedCreateWithoutAccountingLockedPeriodsInput>
  }

  export type CompanyCreateWithoutFinancialPeriodsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFinancialPeriodsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFinancialPeriodsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFinancialPeriodsInput, CompanyUncheckedCreateWithoutFinancialPeriodsInput>
  }

  export type UserCreateWithoutUnlockedPeriodsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutUnlockedPeriodsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutUnlockedPeriodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUnlockedPeriodsInput, UserUncheckedCreateWithoutUnlockedPeriodsInput>
  }

  export type UserCreateWithoutVatLockedPeriodsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutVatLockedPeriodsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutVatLockedPeriodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVatLockedPeriodsInput, UserUncheckedCreateWithoutVatLockedPeriodsInput>
  }

  export type UserCreateWithoutYearEndClosedPeriodsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutYearEndClosedPeriodsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutYearEndClosedPeriodsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutYearEndClosedPeriodsInput, UserUncheckedCreateWithoutYearEndClosedPeriodsInput>
  }

  export type UserUpsertWithoutAccountingLockedPeriodsInput = {
    update: XOR<UserUpdateWithoutAccountingLockedPeriodsInput, UserUncheckedUpdateWithoutAccountingLockedPeriodsInput>
    create: XOR<UserCreateWithoutAccountingLockedPeriodsInput, UserUncheckedCreateWithoutAccountingLockedPeriodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountingLockedPeriodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountingLockedPeriodsInput, UserUncheckedUpdateWithoutAccountingLockedPeriodsInput>
  }

  export type UserUpdateWithoutAccountingLockedPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountingLockedPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type CompanyUpsertWithoutFinancialPeriodsInput = {
    update: XOR<CompanyUpdateWithoutFinancialPeriodsInput, CompanyUncheckedUpdateWithoutFinancialPeriodsInput>
    create: XOR<CompanyCreateWithoutFinancialPeriodsInput, CompanyUncheckedCreateWithoutFinancialPeriodsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFinancialPeriodsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFinancialPeriodsInput, CompanyUncheckedUpdateWithoutFinancialPeriodsInput>
  }

  export type CompanyUpdateWithoutFinancialPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFinancialPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutUnlockedPeriodsInput = {
    update: XOR<UserUpdateWithoutUnlockedPeriodsInput, UserUncheckedUpdateWithoutUnlockedPeriodsInput>
    create: XOR<UserCreateWithoutUnlockedPeriodsInput, UserUncheckedCreateWithoutUnlockedPeriodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUnlockedPeriodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUnlockedPeriodsInput, UserUncheckedUpdateWithoutUnlockedPeriodsInput>
  }

  export type UserUpdateWithoutUnlockedPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUnlockedPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutVatLockedPeriodsInput = {
    update: XOR<UserUpdateWithoutVatLockedPeriodsInput, UserUncheckedUpdateWithoutVatLockedPeriodsInput>
    create: XOR<UserCreateWithoutVatLockedPeriodsInput, UserUncheckedCreateWithoutVatLockedPeriodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVatLockedPeriodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVatLockedPeriodsInput, UserUncheckedUpdateWithoutVatLockedPeriodsInput>
  }

  export type UserUpdateWithoutVatLockedPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVatLockedPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutYearEndClosedPeriodsInput = {
    update: XOR<UserUpdateWithoutYearEndClosedPeriodsInput, UserUncheckedUpdateWithoutYearEndClosedPeriodsInput>
    create: XOR<UserCreateWithoutYearEndClosedPeriodsInput, UserUncheckedCreateWithoutYearEndClosedPeriodsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutYearEndClosedPeriodsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutYearEndClosedPeriodsInput, UserUncheckedUpdateWithoutYearEndClosedPeriodsInput>
  }

  export type UserUpdateWithoutYearEndClosedPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutYearEndClosedPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateWithoutInvoicesInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type BranchCreateWithoutInvoicesInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutInvoicesInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutInvoicesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
  }

  export type CompanyCreateWithoutInvoicesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
  }

  export type AccountCreateWithoutInvoicesGovtFeeInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutInvoicesGovtFeeInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutInvoicesGovtFeeInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutInvoicesGovtFeeInput, AccountUncheckedCreateWithoutInvoicesGovtFeeInput>
  }

  export type TransactionCreateWithoutInvoiceInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutInvoiceInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionCreateManyInvoiceInputEnvelope = {
    data: TransactionCreateManyInvoiceInput | TransactionCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutInvoicesInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutQuotationsInput
    branch?: BranchCreateNestedOneWithoutQuotationsInput
    partner?: PartnerCreateNestedOneWithoutQuotationsInput
    salesperson: UserCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    approvedBy?: UserCreateNestedOneWithoutApprovedQuotationsInput
  }

  export type QuotationUncheckedCreateWithoutInvoicesInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutInvoicesInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutInvoicesInput, QuotationUncheckedCreateWithoutInvoicesInput>
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type BranchUpsertWithoutInvoicesInput = {
    update: XOR<BranchUpdateWithoutInvoicesInput, BranchUncheckedUpdateWithoutInvoicesInput>
    create: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutInvoicesInput, BranchUncheckedUpdateWithoutInvoicesInput>
  }

  export type BranchUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CompanyUpsertWithoutInvoicesInput = {
    update: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type CompanyUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AccountUpsertWithoutInvoicesGovtFeeInput = {
    update: XOR<AccountUpdateWithoutInvoicesGovtFeeInput, AccountUncheckedUpdateWithoutInvoicesGovtFeeInput>
    create: XOR<AccountCreateWithoutInvoicesGovtFeeInput, AccountUncheckedCreateWithoutInvoicesGovtFeeInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutInvoicesGovtFeeInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutInvoicesGovtFeeInput, AccountUncheckedUpdateWithoutInvoicesGovtFeeInput>
  }

  export type AccountUpdateWithoutInvoicesGovtFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutInvoicesGovtFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutInvoiceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type QuotationUpsertWithoutInvoicesInput = {
    update: XOR<QuotationUpdateWithoutInvoicesInput, QuotationUncheckedUpdateWithoutInvoicesInput>
    create: XOR<QuotationCreateWithoutInvoicesInput, QuotationUncheckedCreateWithoutInvoicesInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutInvoicesInput, QuotationUncheckedUpdateWithoutInvoicesInput>
  }

  export type QuotationUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutQuotationsNestedInput
    branch?: BranchUpdateOneWithoutQuotationsNestedInput
    partner?: PartnerUpdateOneWithoutQuotationsNestedInput
    salesperson?: UserUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedQuotationsNestedInput
  }

  export type QuotationUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type BeneficiaryCreateWithoutTransactionsInput = {
    id?: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    company: CompanyCreateNestedOneWithoutBeneficiariesInput
    partner?: PartnerCreateNestedOneWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutTransactionsInput = {
    id?: string
    companyId: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    partnerId?: string | null
  }

  export type BeneficiaryCreateOrConnectWithoutTransactionsInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutTransactionsInput, BeneficiaryUncheckedCreateWithoutTransactionsInput>
  }

  export type BranchCreateWithoutTransactionsInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutTransactionsInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutTransactionsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutTransactionsInput, BranchUncheckedCreateWithoutTransactionsInput>
  }

  export type AccountCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
  }

  export type CompanyCreateWithoutTransactionsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTransactionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTransactionsInput, CompanyUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type AccountCreateWithoutTransactionsGovtFeeInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutTransactionsGovtFeeInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutTransactionsGovtFeeInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTransactionsGovtFeeInput, AccountUncheckedCreateWithoutTransactionsGovtFeeInput>
  }

  export type InvoiceCreateWithoutTransactionsInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: UserCreateNestedOneWithoutInvoicesInput
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
    govtFeeAccount?: AccountCreateNestedOneWithoutInvoicesGovtFeeInput
    quotation?: QuotationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
  }

  export type InvoiceCreateOrConnectWithoutTransactionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
  }

  export type PartnerCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPartnerInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutPartnerInput
    company: CompanyCreateNestedOneWithoutPartnersInput
    quotations?: QuotationCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPartnerInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutPartnerInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutTransactionsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutTransactionsInput, PartnerUncheckedCreateWithoutTransactionsInput>
  }

  export type WorkTypeCreateWithoutTransactionsInput = {
    id?: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quotationItems?: QuotationItemCreateNestedManyWithoutWorkTypeInput
    company: CompanyCreateNestedOneWithoutWorkTypesInput
  }

  export type WorkTypeUncheckedCreateWithoutTransactionsInput = {
    id?: string
    companyId: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quotationItems?: QuotationItemUncheckedCreateNestedManyWithoutWorkTypeInput
  }

  export type WorkTypeCreateOrConnectWithoutTransactionsInput = {
    where: WorkTypeWhereUniqueInput
    create: XOR<WorkTypeCreateWithoutTransactionsInput, WorkTypeUncheckedCreateWithoutTransactionsInput>
  }

  export type BeneficiaryUpsertWithoutTransactionsInput = {
    update: XOR<BeneficiaryUpdateWithoutTransactionsInput, BeneficiaryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BeneficiaryCreateWithoutTransactionsInput, BeneficiaryUncheckedCreateWithoutTransactionsInput>
    where?: BeneficiaryWhereInput
  }

  export type BeneficiaryUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BeneficiaryWhereInput
    data: XOR<BeneficiaryUpdateWithoutTransactionsInput, BeneficiaryUncheckedUpdateWithoutTransactionsInput>
  }

  export type BeneficiaryUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutBeneficiariesNestedInput
    partner?: PartnerUpdateOneWithoutBeneficiariesNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchUpsertWithoutTransactionsInput = {
    update: XOR<BranchUpdateWithoutTransactionsInput, BranchUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BranchCreateWithoutTransactionsInput, BranchUncheckedCreateWithoutTransactionsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutTransactionsInput, BranchUncheckedUpdateWithoutTransactionsInput>
  }

  export type BranchUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AccountUpsertWithoutTransactionsInput = {
    update: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type CompanyUpsertWithoutTransactionsInput = {
    update: XOR<CompanyUpdateWithoutTransactionsInput, CompanyUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CompanyCreateWithoutTransactionsInput, CompanyUncheckedCreateWithoutTransactionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTransactionsInput, CompanyUncheckedUpdateWithoutTransactionsInput>
  }

  export type CompanyUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type AccountUpsertWithoutTransactionsGovtFeeInput = {
    update: XOR<AccountUpdateWithoutTransactionsGovtFeeInput, AccountUncheckedUpdateWithoutTransactionsGovtFeeInput>
    create: XOR<AccountCreateWithoutTransactionsGovtFeeInput, AccountUncheckedCreateWithoutTransactionsGovtFeeInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTransactionsGovtFeeInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTransactionsGovtFeeInput, AccountUncheckedUpdateWithoutTransactionsGovtFeeInput>
  }

  export type AccountUpdateWithoutTransactionsGovtFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutTransactionsGovtFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type InvoiceUpsertWithoutTransactionsInput = {
    update: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneWithoutInvoicesNestedInput
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutInvoicesGovtFeeNestedInput
    quotation?: QuotationUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartnerUpsertWithoutTransactionsInput = {
    update: XOR<PartnerUpdateWithoutTransactionsInput, PartnerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PartnerCreateWithoutTransactionsInput, PartnerUncheckedCreateWithoutTransactionsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutTransactionsInput, PartnerUncheckedUpdateWithoutTransactionsInput>
  }

  export type PartnerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUpdateManyWithoutPartnerNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutPartnerNestedInput
    company?: CompanyUpdateOneRequiredWithoutPartnersNestedInput
    quotations?: QuotationUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPartnerNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type WorkTypeUpsertWithoutTransactionsInput = {
    update: XOR<WorkTypeUpdateWithoutTransactionsInput, WorkTypeUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WorkTypeCreateWithoutTransactionsInput, WorkTypeUncheckedCreateWithoutTransactionsInput>
    where?: WorkTypeWhereInput
  }

  export type WorkTypeUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WorkTypeWhereInput
    data: XOR<WorkTypeUpdateWithoutTransactionsInput, WorkTypeUncheckedUpdateWithoutTransactionsInput>
  }

  export type WorkTypeUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quotationItems?: QuotationItemUpdateManyWithoutWorkTypeNestedInput
    company?: CompanyUpdateOneRequiredWithoutWorkTypesNestedInput
  }

  export type WorkTypeUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quotationItems?: QuotationItemUncheckedUpdateManyWithoutWorkTypeNestedInput
  }

  export type TransactionCreateWithoutWorkTypeInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutWorkTypeInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutWorkTypeInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWorkTypeInput, TransactionUncheckedCreateWithoutWorkTypeInput>
  }

  export type TransactionCreateManyWorkTypeInputEnvelope = {
    data: TransactionCreateManyWorkTypeInput | TransactionCreateManyWorkTypeInput[]
    skipDuplicates?: boolean
  }

  export type QuotationItemCreateWithoutWorkTypeInput = {
    id?: string
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
    quotation: QuotationCreateNestedOneWithoutItemsInput
  }

  export type QuotationItemUncheckedCreateWithoutWorkTypeInput = {
    id?: string
    quotationId: string
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
  }

  export type QuotationItemCreateOrConnectWithoutWorkTypeInput = {
    where: QuotationItemWhereUniqueInput
    create: XOR<QuotationItemCreateWithoutWorkTypeInput, QuotationItemUncheckedCreateWithoutWorkTypeInput>
  }

  export type QuotationItemCreateManyWorkTypeInputEnvelope = {
    data: QuotationItemCreateManyWorkTypeInput | QuotationItemCreateManyWorkTypeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutWorkTypesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWorkTypesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWorkTypesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWorkTypesInput, CompanyUncheckedCreateWithoutWorkTypesInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutWorkTypeInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutWorkTypeInput, TransactionUncheckedUpdateWithoutWorkTypeInput>
    create: XOR<TransactionCreateWithoutWorkTypeInput, TransactionUncheckedCreateWithoutWorkTypeInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutWorkTypeInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutWorkTypeInput, TransactionUncheckedUpdateWithoutWorkTypeInput>
  }

  export type TransactionUpdateManyWithWhereWithoutWorkTypeInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutWorkTypeInput>
  }

  export type QuotationItemUpsertWithWhereUniqueWithoutWorkTypeInput = {
    where: QuotationItemWhereUniqueInput
    update: XOR<QuotationItemUpdateWithoutWorkTypeInput, QuotationItemUncheckedUpdateWithoutWorkTypeInput>
    create: XOR<QuotationItemCreateWithoutWorkTypeInput, QuotationItemUncheckedCreateWithoutWorkTypeInput>
  }

  export type QuotationItemUpdateWithWhereUniqueWithoutWorkTypeInput = {
    where: QuotationItemWhereUniqueInput
    data: XOR<QuotationItemUpdateWithoutWorkTypeInput, QuotationItemUncheckedUpdateWithoutWorkTypeInput>
  }

  export type QuotationItemUpdateManyWithWhereWithoutWorkTypeInput = {
    where: QuotationItemScalarWhereInput
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyWithoutWorkTypeInput>
  }

  export type QuotationItemScalarWhereInput = {
    AND?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
    OR?: QuotationItemScalarWhereInput[]
    NOT?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
    id?: StringFilter<"QuotationItem"> | string
    quotationId?: StringFilter<"QuotationItem"> | string
    workTypeId?: StringNullableFilter<"QuotationItem"> | string | null
    description?: StringFilter<"QuotationItem"> | string
    govFee?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFilter<"QuotationItem"> | boolean
    quantity?: IntFilter<"QuotationItem"> | number
  }

  export type CompanyUpsertWithoutWorkTypesInput = {
    update: XOR<CompanyUpdateWithoutWorkTypesInput, CompanyUncheckedUpdateWithoutWorkTypesInput>
    create: XOR<CompanyCreateWithoutWorkTypesInput, CompanyUncheckedCreateWithoutWorkTypesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWorkTypesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWorkTypesInput, CompanyUncheckedUpdateWithoutWorkTypesInput>
  }

  export type CompanyUpdateWithoutWorkTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWorkTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutBeneficiariesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBeneficiariesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBeneficiariesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBeneficiariesInput, CompanyUncheckedCreateWithoutBeneficiariesInput>
  }

  export type PartnerCreateWithoutBeneficiariesInput = {
    id?: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutPartnerInput
    company: CompanyCreateNestedOneWithoutPartnersInput
    transactions?: TransactionCreateNestedManyWithoutPartnerInput
    quotations?: QuotationCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutBeneficiariesInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutPartnerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPartnerInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutBeneficiariesInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutBeneficiariesInput, PartnerUncheckedCreateWithoutBeneficiariesInput>
  }

  export type TransactionCreateWithoutBeneficiaryInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutBeneficiaryInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutBeneficiaryInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBeneficiaryInput, TransactionUncheckedCreateWithoutBeneficiaryInput>
  }

  export type TransactionCreateManyBeneficiaryInputEnvelope = {
    data: TransactionCreateManyBeneficiaryInput | TransactionCreateManyBeneficiaryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutBeneficiariesInput = {
    update: XOR<CompanyUpdateWithoutBeneficiariesInput, CompanyUncheckedUpdateWithoutBeneficiariesInput>
    create: XOR<CompanyCreateWithoutBeneficiariesInput, CompanyUncheckedCreateWithoutBeneficiariesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBeneficiariesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBeneficiariesInput, CompanyUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type CompanyUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PartnerUpsertWithoutBeneficiariesInput = {
    update: XOR<PartnerUpdateWithoutBeneficiariesInput, PartnerUncheckedUpdateWithoutBeneficiariesInput>
    create: XOR<PartnerCreateWithoutBeneficiariesInput, PartnerUncheckedCreateWithoutBeneficiariesInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutBeneficiariesInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutBeneficiariesInput, PartnerUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type PartnerUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutPartnerNestedInput
    company?: CompanyUpdateOneRequiredWithoutPartnersNestedInput
    transactions?: TransactionUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutPartnerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutBeneficiaryInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBeneficiaryInput, TransactionUncheckedUpdateWithoutBeneficiaryInput>
    create: XOR<TransactionCreateWithoutBeneficiaryInput, TransactionUncheckedCreateWithoutBeneficiaryInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBeneficiaryInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBeneficiaryInput, TransactionUncheckedUpdateWithoutBeneficiaryInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBeneficiaryInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBeneficiaryInput>
  }

  export type BeneficiaryCreateWithoutPartnerInput = {
    id?: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    company: CompanyCreateNestedOneWithoutBeneficiariesInput
    transactions?: TransactionCreateNestedManyWithoutBeneficiaryInput
  }

  export type BeneficiaryUncheckedCreateWithoutPartnerInput = {
    id?: string
    companyId: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutBeneficiaryInput
  }

  export type BeneficiaryCreateOrConnectWithoutPartnerInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutPartnerInput, BeneficiaryUncheckedCreateWithoutPartnerInput>
  }

  export type BeneficiaryCreateManyPartnerInputEnvelope = {
    data: BeneficiaryCreateManyPartnerInput | BeneficiaryCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type LedgerTransactionCreateWithoutPartnerInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    companyId: string
    account: AccountCreateNestedOneWithoutLedgerTransactionsInput
    branch?: BranchCreateNestedOneWithoutLedgerTransactionsInput
    journalEntry: JournalEntryCreateNestedOneWithoutTransactionsInput
    card?: BusinessCardCreateNestedOneWithoutLedgerTransactionsInput
  }

  export type LedgerTransactionUncheckedCreateWithoutPartnerInput = {
    id?: string
    journalEntryId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    companyId: string
    branchId?: string | null
    cardId?: string | null
  }

  export type LedgerTransactionCreateOrConnectWithoutPartnerInput = {
    where: LedgerTransactionWhereUniqueInput
    create: XOR<LedgerTransactionCreateWithoutPartnerInput, LedgerTransactionUncheckedCreateWithoutPartnerInput>
  }

  export type LedgerTransactionCreateManyPartnerInputEnvelope = {
    data: LedgerTransactionCreateManyPartnerInput | LedgerTransactionCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutPartnersInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPartnersInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPartnersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPartnersInput, CompanyUncheckedCreateWithoutPartnersInput>
  }

  export type TransactionCreateWithoutPartnerInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutPartnerInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutPartnerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPartnerInput, TransactionUncheckedCreateWithoutPartnerInput>
  }

  export type TransactionCreateManyPartnerInputEnvelope = {
    data: TransactionCreateManyPartnerInput | TransactionCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutPartnerInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutQuotationsInput
    branch?: BranchCreateNestedOneWithoutQuotationsInput
    salesperson: UserCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceCreateNestedManyWithoutQuotationInput
    approvedBy?: UserCreateNestedOneWithoutApprovedQuotationsInput
  }

  export type QuotationUncheckedCreateWithoutPartnerInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutPartnerInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutPartnerInput, QuotationUncheckedCreateWithoutPartnerInput>
  }

  export type QuotationCreateManyPartnerInputEnvelope = {
    data: QuotationCreateManyPartnerInput | QuotationCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutPartnerInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutPartnerInput, BeneficiaryUncheckedUpdateWithoutPartnerInput>
    create: XOR<BeneficiaryCreateWithoutPartnerInput, BeneficiaryUncheckedCreateWithoutPartnerInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutPartnerInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutPartnerInput, BeneficiaryUncheckedUpdateWithoutPartnerInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutPartnerInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutPartnerInput>
  }

  export type LedgerTransactionUpsertWithWhereUniqueWithoutPartnerInput = {
    where: LedgerTransactionWhereUniqueInput
    update: XOR<LedgerTransactionUpdateWithoutPartnerInput, LedgerTransactionUncheckedUpdateWithoutPartnerInput>
    create: XOR<LedgerTransactionCreateWithoutPartnerInput, LedgerTransactionUncheckedCreateWithoutPartnerInput>
  }

  export type LedgerTransactionUpdateWithWhereUniqueWithoutPartnerInput = {
    where: LedgerTransactionWhereUniqueInput
    data: XOR<LedgerTransactionUpdateWithoutPartnerInput, LedgerTransactionUncheckedUpdateWithoutPartnerInput>
  }

  export type LedgerTransactionUpdateManyWithWhereWithoutPartnerInput = {
    where: LedgerTransactionScalarWhereInput
    data: XOR<LedgerTransactionUpdateManyMutationInput, LedgerTransactionUncheckedUpdateManyWithoutPartnerInput>
  }

  export type CompanyUpsertWithoutPartnersInput = {
    update: XOR<CompanyUpdateWithoutPartnersInput, CompanyUncheckedUpdateWithoutPartnersInput>
    create: XOR<CompanyCreateWithoutPartnersInput, CompanyUncheckedCreateWithoutPartnersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPartnersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPartnersInput, CompanyUncheckedUpdateWithoutPartnersInput>
  }

  export type CompanyUpdateWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutPartnerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPartnerInput, TransactionUncheckedUpdateWithoutPartnerInput>
    create: XOR<TransactionCreateWithoutPartnerInput, TransactionUncheckedCreateWithoutPartnerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPartnerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPartnerInput, TransactionUncheckedUpdateWithoutPartnerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPartnerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPartnerInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutPartnerInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutPartnerInput, QuotationUncheckedUpdateWithoutPartnerInput>
    create: XOR<QuotationCreateWithoutPartnerInput, QuotationUncheckedCreateWithoutPartnerInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutPartnerInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutPartnerInput, QuotationUncheckedUpdateWithoutPartnerInput>
  }

  export type QuotationUpdateManyWithWhereWithoutPartnerInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutPartnerInput>
  }

  export type AccountCreateWithoutExpensesInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutExpensesInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutExpensesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutExpensesInput, AccountUncheckedCreateWithoutExpensesInput>
  }

  export type BranchCreateWithoutExpensesInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutExpensesInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutExpensesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
  }

  export type ExpenseCategoryCreateWithoutExpensesInput = {
    id?: string
    name: string
    description?: string | null
    company: CompanyCreateNestedOneWithoutExpenseCategoriesInput
    ledgerAccount?: AccountCreateNestedOneWithoutExpenseCategoriesInput
    voucherItems?: VoucherItemCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutExpensesInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    ledgerAccountId?: string | null
    voucherItems?: VoucherItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutExpensesInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
  }

  export type CompanyCreateWithoutExpensesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutExpensesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutExpensesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
  }

  export type UserCreateWithoutExpensesInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutExpensesInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutExpensesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
  }

  export type AccountUpsertWithoutExpensesInput = {
    update: XOR<AccountUpdateWithoutExpensesInput, AccountUncheckedUpdateWithoutExpensesInput>
    create: XOR<AccountCreateWithoutExpensesInput, AccountUncheckedCreateWithoutExpensesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutExpensesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutExpensesInput, AccountUncheckedUpdateWithoutExpensesInput>
  }

  export type AccountUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type BranchUpsertWithoutExpensesInput = {
    update: XOR<BranchUpdateWithoutExpensesInput, BranchUncheckedUpdateWithoutExpensesInput>
    create: XOR<BranchCreateWithoutExpensesInput, BranchUncheckedCreateWithoutExpensesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutExpensesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutExpensesInput, BranchUncheckedUpdateWithoutExpensesInput>
  }

  export type BranchUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ExpenseCategoryUpsertWithoutExpensesInput = {
    update: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutExpenseCategoriesNestedInput
    ledgerAccount?: AccountUpdateOneWithoutExpenseCategoriesNestedInput
    voucherItems?: VoucherItemUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ledgerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    voucherItems?: VoucherItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CompanyUpsertWithoutExpensesInput = {
    update: XOR<CompanyUpdateWithoutExpensesInput, CompanyUncheckedUpdateWithoutExpensesInput>
    create: XOR<CompanyCreateWithoutExpensesInput, CompanyUncheckedCreateWithoutExpensesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutExpensesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutExpensesInput, CompanyUncheckedUpdateWithoutExpensesInput>
  }

  export type CompanyUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutExpensesInput = {
    update: XOR<UserUpdateWithoutExpensesInput, UserUncheckedUpdateWithoutExpensesInput>
    create: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpensesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpensesInput, UserUncheckedUpdateWithoutExpensesInput>
  }

  export type UserUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type ExpenseCreateWithoutCategoryInput = {
    id?: string
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutExpensesInput
    branch?: BranchCreateNestedOneWithoutExpensesInput
    company: CompanyCreateNestedOneWithoutExpensesInput
    enteredBy: UserCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutCategoryInput = {
    id?: string
    companyId: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseCreateManyCategoryInputEnvelope = {
    data: ExpenseCreateManyCategoryInput | ExpenseCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutExpenseCategoriesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutExpenseCategoriesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutExpenseCategoriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutExpenseCategoriesInput, CompanyUncheckedCreateWithoutExpenseCategoriesInput>
  }

  export type AccountCreateWithoutExpenseCategoriesInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutExpenseCategoriesInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutExpenseCategoriesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutExpenseCategoriesInput, AccountUncheckedCreateWithoutExpenseCategoriesInput>
  }

  export type VoucherItemCreateWithoutCategoryInput = {
    id?: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
    voucher: VoucherCreateNestedOneWithoutItemsInput
  }

  export type VoucherItemUncheckedCreateWithoutCategoryInput = {
    id?: string
    voucherId: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
  }

  export type VoucherItemCreateOrConnectWithoutCategoryInput = {
    where: VoucherItemWhereUniqueInput
    create: XOR<VoucherItemCreateWithoutCategoryInput, VoucherItemUncheckedCreateWithoutCategoryInput>
  }

  export type VoucherItemCreateManyCategoryInputEnvelope = {
    data: VoucherItemCreateManyCategoryInput | VoucherItemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCategoryInput, ExpenseUncheckedUpdateWithoutCategoryInput>
    create: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCategoryInput, ExpenseUncheckedUpdateWithoutCategoryInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCategoryInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CompanyUpsertWithoutExpenseCategoriesInput = {
    update: XOR<CompanyUpdateWithoutExpenseCategoriesInput, CompanyUncheckedUpdateWithoutExpenseCategoriesInput>
    create: XOR<CompanyCreateWithoutExpenseCategoriesInput, CompanyUncheckedCreateWithoutExpenseCategoriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutExpenseCategoriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutExpenseCategoriesInput, CompanyUncheckedUpdateWithoutExpenseCategoriesInput>
  }

  export type CompanyUpdateWithoutExpenseCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutExpenseCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AccountUpsertWithoutExpenseCategoriesInput = {
    update: XOR<AccountUpdateWithoutExpenseCategoriesInput, AccountUncheckedUpdateWithoutExpenseCategoriesInput>
    create: XOR<AccountCreateWithoutExpenseCategoriesInput, AccountUncheckedCreateWithoutExpenseCategoriesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutExpenseCategoriesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutExpenseCategoriesInput, AccountUncheckedUpdateWithoutExpenseCategoriesInput>
  }

  export type AccountUpdateWithoutExpenseCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutExpenseCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type VoucherItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: VoucherItemWhereUniqueInput
    update: XOR<VoucherItemUpdateWithoutCategoryInput, VoucherItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<VoucherItemCreateWithoutCategoryInput, VoucherItemUncheckedCreateWithoutCategoryInput>
  }

  export type VoucherItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: VoucherItemWhereUniqueInput
    data: XOR<VoucherItemUpdateWithoutCategoryInput, VoucherItemUncheckedUpdateWithoutCategoryInput>
  }

  export type VoucherItemUpdateManyWithWhereWithoutCategoryInput = {
    where: VoucherItemScalarWhereInput
    data: XOR<VoucherItemUpdateManyMutationInput, VoucherItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type VoucherItemScalarWhereInput = {
    AND?: VoucherItemScalarWhereInput | VoucherItemScalarWhereInput[]
    OR?: VoucherItemScalarWhereInput[]
    NOT?: VoucherItemScalarWhereInput | VoucherItemScalarWhereInput[]
    id?: StringFilter<"VoucherItem"> | string
    voucherId?: StringFilter<"VoucherItem"> | string
    categoryId?: StringFilter<"VoucherItem"> | string
    quantity?: IntFilter<"VoucherItem"> | number
    amount?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"VoucherItem"> | string | null
    isVatApplicable?: BoolFilter<"VoucherItem"> | boolean
    vatAmount?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFilter<"VoucherItem"> | Decimal | DecimalJsLike | number | string
  }

  export type CompanyCreateWithoutAccountsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAccountsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
  }

  export type AccountCreateWithoutChildAccountsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutChildAccountsInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutChildAccountsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutChildAccountsInput, AccountUncheckedCreateWithoutChildAccountsInput>
  }

  export type AccountCreateWithoutParentAccountInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutParentAccountInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutParentAccountInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutParentAccountInput, AccountUncheckedCreateWithoutParentAccountInput>
  }

  export type AccountCreateManyParentAccountInputEnvelope = {
    data: AccountCreateManyParentAccountInput | AccountCreateManyParentAccountInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutAccountInput = {
    id?: string
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutExpensesInput
    category: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    company: CompanyCreateNestedOneWithoutExpensesInput
    enteredBy: UserCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutAccountInput = {
    id?: string
    companyId: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutAccountInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutAccountInput, ExpenseUncheckedCreateWithoutAccountInput>
  }

  export type ExpenseCreateManyAccountInputEnvelope = {
    data: ExpenseCreateManyAccountInput | ExpenseCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCategoryCreateWithoutLedgerAccountInput = {
    id?: string
    name: string
    description?: string | null
    expenses?: ExpenseCreateNestedManyWithoutCategoryInput
    company: CompanyCreateNestedOneWithoutExpenseCategoriesInput
    voucherItems?: VoucherItemCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCategoryInput
    voucherItems?: VoucherItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutLedgerAccountInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutLedgerAccountInput, ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput>
  }

  export type ExpenseCategoryCreateManyLedgerAccountInputEnvelope = {
    data: ExpenseCategoryCreateManyLedgerAccountInput | ExpenseCategoryCreateManyLedgerAccountInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutGovtFeeAccountInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: UserCreateNestedOneWithoutInvoicesInput
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
    quotation?: QuotationCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutGovtFeeAccountInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutGovtFeeAccountInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutGovtFeeAccountInput, InvoiceUncheckedCreateWithoutGovtFeeAccountInput>
  }

  export type InvoiceCreateManyGovtFeeAccountInputEnvelope = {
    data: InvoiceCreateManyGovtFeeAccountInput | InvoiceCreateManyGovtFeeAccountInput[]
    skipDuplicates?: boolean
  }

  export type LedgerTransactionCreateWithoutAccountInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    companyId: string
    branch?: BranchCreateNestedOneWithoutLedgerTransactionsInput
    journalEntry: JournalEntryCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutLedgerTransactionsInput
    card?: BusinessCardCreateNestedOneWithoutLedgerTransactionsInput
  }

  export type LedgerTransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    journalEntryId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    branchId?: string | null
    cardId?: string | null
  }

  export type LedgerTransactionCreateOrConnectWithoutAccountInput = {
    where: LedgerTransactionWhereUniqueInput
    create: XOR<LedgerTransactionCreateWithoutAccountInput, LedgerTransactionUncheckedCreateWithoutAccountInput>
  }

  export type LedgerTransactionCreateManyAccountInputEnvelope = {
    data: LedgerTransactionCreateManyAccountInput | LedgerTransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutAccountInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    govtFeeAccount?: AccountCreateNestedOneWithoutTransactionsGovtFeeInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateManyAccountInputEnvelope = {
    data: TransactionCreateManyAccountInput | TransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutGovtFeeAccountInput = {
    id?: string
    invNo?: string | null
    date?: Date | string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
    beneficiary?: BeneficiaryCreateNestedOneWithoutTransactionsInput
    branch?: BranchCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    company: CompanyCreateNestedOneWithoutTransactionsInput
    enteredBy?: UserCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutTransactionsInput
    workType?: WorkTypeCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutGovtFeeAccountInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateOrConnectWithoutGovtFeeAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutGovtFeeAccountInput, TransactionUncheckedCreateWithoutGovtFeeAccountInput>
  }

  export type TransactionCreateManyGovtFeeAccountInputEnvelope = {
    data: TransactionCreateManyGovtFeeAccountInput | TransactionCreateManyGovtFeeAccountInput[]
    skipDuplicates?: boolean
  }

  export type VoucherCreateWithoutAccountInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    branch?: BranchCreateNestedOneWithoutVouchersInput
    company: CompanyCreateNestedOneWithoutVouchersInput
    enteredBy: UserCreateNestedOneWithoutVouchersInput
    vendor?: VendorCreateNestedOneWithoutVouchersInput
    items?: VoucherItemCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutAccountInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    items?: VoucherItemUncheckedCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutAccountInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutAccountInput, VoucherUncheckedCreateWithoutAccountInput>
  }

  export type VoucherCreateManyAccountInputEnvelope = {
    data: VoucherCreateManyAccountInput | VoucherCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type VoucherPaymentCreateWithoutAccountInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    receiptNo: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutVoucherPaymentsInput
    enteredBy: UserCreateNestedOneWithoutVoucherPaymentsInput
    voucher: VoucherCreateNestedOneWithoutPaymentsInput
  }

  export type VoucherPaymentUncheckedCreateWithoutAccountInput = {
    id?: string
    voucherId: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    receiptNo: string
    enteredById: string
    createdAt?: Date | string
    companyId: string
  }

  export type VoucherPaymentCreateOrConnectWithoutAccountInput = {
    where: VoucherPaymentWhereUniqueInput
    create: XOR<VoucherPaymentCreateWithoutAccountInput, VoucherPaymentUncheckedCreateWithoutAccountInput>
  }

  export type VoucherPaymentCreateManyAccountInputEnvelope = {
    data: VoucherPaymentCreateManyAccountInput | VoucherPaymentCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type BusinessCardCreateWithoutLedgerAccountInput = {
    id?: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBusinessCardsInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutCardInput
  }

  export type BusinessCardUncheckedCreateWithoutLedgerAccountInput = {
    id?: string
    companyId: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutCardInput
  }

  export type BusinessCardCreateOrConnectWithoutLedgerAccountInput = {
    where: BusinessCardWhereUniqueInput
    create: XOR<BusinessCardCreateWithoutLedgerAccountInput, BusinessCardUncheckedCreateWithoutLedgerAccountInput>
  }

  export type BusinessCardCreateManyLedgerAccountInputEnvelope = {
    data: BusinessCardCreateManyLedgerAccountInput | BusinessCardCreateManyLedgerAccountInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutAccountsInput = {
    update: XOR<CompanyUpdateWithoutAccountsInput, CompanyUncheckedUpdateWithoutAccountsInput>
    create: XOR<CompanyCreateWithoutAccountsInput, CompanyUncheckedCreateWithoutAccountsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAccountsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAccountsInput, CompanyUncheckedUpdateWithoutAccountsInput>
  }

  export type CompanyUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AccountUpsertWithoutChildAccountsInput = {
    update: XOR<AccountUpdateWithoutChildAccountsInput, AccountUncheckedUpdateWithoutChildAccountsInput>
    create: XOR<AccountCreateWithoutChildAccountsInput, AccountUncheckedCreateWithoutChildAccountsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutChildAccountsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutChildAccountsInput, AccountUncheckedUpdateWithoutChildAccountsInput>
  }

  export type AccountUpdateWithoutChildAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutChildAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutParentAccountInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutParentAccountInput, AccountUncheckedUpdateWithoutParentAccountInput>
    create: XOR<AccountCreateWithoutParentAccountInput, AccountUncheckedCreateWithoutParentAccountInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutParentAccountInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutParentAccountInput, AccountUncheckedUpdateWithoutParentAccountInput>
  }

  export type AccountUpdateManyWithWhereWithoutParentAccountInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutParentAccountInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutAccountInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutAccountInput, ExpenseUncheckedUpdateWithoutAccountInput>
    create: XOR<ExpenseCreateWithoutAccountInput, ExpenseUncheckedCreateWithoutAccountInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutAccountInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutAccountInput, ExpenseUncheckedUpdateWithoutAccountInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutAccountInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutAccountInput>
  }

  export type ExpenseCategoryUpsertWithWhereUniqueWithoutLedgerAccountInput = {
    where: ExpenseCategoryWhereUniqueInput
    update: XOR<ExpenseCategoryUpdateWithoutLedgerAccountInput, ExpenseCategoryUncheckedUpdateWithoutLedgerAccountInput>
    create: XOR<ExpenseCategoryCreateWithoutLedgerAccountInput, ExpenseCategoryUncheckedCreateWithoutLedgerAccountInput>
  }

  export type ExpenseCategoryUpdateWithWhereUniqueWithoutLedgerAccountInput = {
    where: ExpenseCategoryWhereUniqueInput
    data: XOR<ExpenseCategoryUpdateWithoutLedgerAccountInput, ExpenseCategoryUncheckedUpdateWithoutLedgerAccountInput>
  }

  export type ExpenseCategoryUpdateManyWithWhereWithoutLedgerAccountInput = {
    where: ExpenseCategoryScalarWhereInput
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutGovtFeeAccountInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutGovtFeeAccountInput, InvoiceUncheckedUpdateWithoutGovtFeeAccountInput>
    create: XOR<InvoiceCreateWithoutGovtFeeAccountInput, InvoiceUncheckedCreateWithoutGovtFeeAccountInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutGovtFeeAccountInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutGovtFeeAccountInput, InvoiceUncheckedUpdateWithoutGovtFeeAccountInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutGovtFeeAccountInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutGovtFeeAccountInput>
  }

  export type LedgerTransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: LedgerTransactionWhereUniqueInput
    update: XOR<LedgerTransactionUpdateWithoutAccountInput, LedgerTransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<LedgerTransactionCreateWithoutAccountInput, LedgerTransactionUncheckedCreateWithoutAccountInput>
  }

  export type LedgerTransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: LedgerTransactionWhereUniqueInput
    data: XOR<LedgerTransactionUpdateWithoutAccountInput, LedgerTransactionUncheckedUpdateWithoutAccountInput>
  }

  export type LedgerTransactionUpdateManyWithWhereWithoutAccountInput = {
    where: LedgerTransactionScalarWhereInput
    data: XOR<LedgerTransactionUpdateManyMutationInput, LedgerTransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutGovtFeeAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutGovtFeeAccountInput, TransactionUncheckedUpdateWithoutGovtFeeAccountInput>
    create: XOR<TransactionCreateWithoutGovtFeeAccountInput, TransactionUncheckedCreateWithoutGovtFeeAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutGovtFeeAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutGovtFeeAccountInput, TransactionUncheckedUpdateWithoutGovtFeeAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutGovtFeeAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutGovtFeeAccountInput>
  }

  export type VoucherUpsertWithWhereUniqueWithoutAccountInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutAccountInput, VoucherUncheckedUpdateWithoutAccountInput>
    create: XOR<VoucherCreateWithoutAccountInput, VoucherUncheckedCreateWithoutAccountInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutAccountInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutAccountInput, VoucherUncheckedUpdateWithoutAccountInput>
  }

  export type VoucherUpdateManyWithWhereWithoutAccountInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutAccountInput>
  }

  export type VoucherPaymentUpsertWithWhereUniqueWithoutAccountInput = {
    where: VoucherPaymentWhereUniqueInput
    update: XOR<VoucherPaymentUpdateWithoutAccountInput, VoucherPaymentUncheckedUpdateWithoutAccountInput>
    create: XOR<VoucherPaymentCreateWithoutAccountInput, VoucherPaymentUncheckedCreateWithoutAccountInput>
  }

  export type VoucherPaymentUpdateWithWhereUniqueWithoutAccountInput = {
    where: VoucherPaymentWhereUniqueInput
    data: XOR<VoucherPaymentUpdateWithoutAccountInput, VoucherPaymentUncheckedUpdateWithoutAccountInput>
  }

  export type VoucherPaymentUpdateManyWithWhereWithoutAccountInput = {
    where: VoucherPaymentScalarWhereInput
    data: XOR<VoucherPaymentUpdateManyMutationInput, VoucherPaymentUncheckedUpdateManyWithoutAccountInput>
  }

  export type BusinessCardUpsertWithWhereUniqueWithoutLedgerAccountInput = {
    where: BusinessCardWhereUniqueInput
    update: XOR<BusinessCardUpdateWithoutLedgerAccountInput, BusinessCardUncheckedUpdateWithoutLedgerAccountInput>
    create: XOR<BusinessCardCreateWithoutLedgerAccountInput, BusinessCardUncheckedCreateWithoutLedgerAccountInput>
  }

  export type BusinessCardUpdateWithWhereUniqueWithoutLedgerAccountInput = {
    where: BusinessCardWhereUniqueInput
    data: XOR<BusinessCardUpdateWithoutLedgerAccountInput, BusinessCardUncheckedUpdateWithoutLedgerAccountInput>
  }

  export type BusinessCardUpdateManyWithWhereWithoutLedgerAccountInput = {
    where: BusinessCardScalarWhereInput
    data: XOR<BusinessCardUpdateManyMutationInput, BusinessCardUncheckedUpdateManyWithoutLedgerAccountInput>
  }

  export type BranchCreateWithoutJournalEntriesInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutJournalEntriesInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutJournalEntriesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutJournalEntriesInput, BranchUncheckedCreateWithoutJournalEntriesInput>
  }

  export type CompanyCreateWithoutJournalEntriesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutJournalEntriesInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutJournalEntriesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
  }

  export type LedgerTransactionCreateWithoutJournalEntryInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    companyId: string
    account: AccountCreateNestedOneWithoutLedgerTransactionsInput
    branch?: BranchCreateNestedOneWithoutLedgerTransactionsInput
    partner?: PartnerCreateNestedOneWithoutLedgerTransactionsInput
    card?: BusinessCardCreateNestedOneWithoutLedgerTransactionsInput
  }

  export type LedgerTransactionUncheckedCreateWithoutJournalEntryInput = {
    id?: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    branchId?: string | null
    cardId?: string | null
  }

  export type LedgerTransactionCreateOrConnectWithoutJournalEntryInput = {
    where: LedgerTransactionWhereUniqueInput
    create: XOR<LedgerTransactionCreateWithoutJournalEntryInput, LedgerTransactionUncheckedCreateWithoutJournalEntryInput>
  }

  export type LedgerTransactionCreateManyJournalEntryInputEnvelope = {
    data: LedgerTransactionCreateManyJournalEntryInput | LedgerTransactionCreateManyJournalEntryInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutJournalEntriesInput = {
    update: XOR<BranchUpdateWithoutJournalEntriesInput, BranchUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<BranchCreateWithoutJournalEntriesInput, BranchUncheckedCreateWithoutJournalEntriesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutJournalEntriesInput, BranchUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type BranchUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CompanyUpsertWithoutJournalEntriesInput = {
    update: XOR<CompanyUpdateWithoutJournalEntriesInput, CompanyUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<CompanyCreateWithoutJournalEntriesInput, CompanyUncheckedCreateWithoutJournalEntriesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutJournalEntriesInput, CompanyUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type CompanyUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type LedgerTransactionUpsertWithWhereUniqueWithoutJournalEntryInput = {
    where: LedgerTransactionWhereUniqueInput
    update: XOR<LedgerTransactionUpdateWithoutJournalEntryInput, LedgerTransactionUncheckedUpdateWithoutJournalEntryInput>
    create: XOR<LedgerTransactionCreateWithoutJournalEntryInput, LedgerTransactionUncheckedCreateWithoutJournalEntryInput>
  }

  export type LedgerTransactionUpdateWithWhereUniqueWithoutJournalEntryInput = {
    where: LedgerTransactionWhereUniqueInput
    data: XOR<LedgerTransactionUpdateWithoutJournalEntryInput, LedgerTransactionUncheckedUpdateWithoutJournalEntryInput>
  }

  export type LedgerTransactionUpdateManyWithWhereWithoutJournalEntryInput = {
    where: LedgerTransactionScalarWhereInput
    data: XOR<LedgerTransactionUpdateManyMutationInput, LedgerTransactionUncheckedUpdateManyWithoutJournalEntryInput>
  }

  export type AccountCreateWithoutLedgerTransactionsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutLedgerTransactionsInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutLedgerTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutLedgerTransactionsInput, AccountUncheckedCreateWithoutLedgerTransactionsInput>
  }

  export type BranchCreateWithoutLedgerTransactionsInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutLedgerTransactionsInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutLedgerTransactionsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutLedgerTransactionsInput, BranchUncheckedCreateWithoutLedgerTransactionsInput>
  }

  export type JournalEntryCreateWithoutTransactionsInput = {
    id?: string
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
    branch?: BranchCreateNestedOneWithoutJournalEntriesInput
    company: CompanyCreateNestedOneWithoutJournalEntriesInput
  }

  export type JournalEntryUncheckedCreateWithoutTransactionsInput = {
    id?: string
    companyId: string
    branchId?: string | null
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
  }

  export type JournalEntryCreateOrConnectWithoutTransactionsInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutTransactionsInput, JournalEntryUncheckedCreateWithoutTransactionsInput>
  }

  export type PartnerCreateWithoutLedgerTransactionsInput = {
    id?: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPartnerInput
    company: CompanyCreateNestedOneWithoutPartnersInput
    transactions?: TransactionCreateNestedManyWithoutPartnerInput
    quotations?: QuotationCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutLedgerTransactionsInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPartnerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPartnerInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutLedgerTransactionsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutLedgerTransactionsInput, PartnerUncheckedCreateWithoutLedgerTransactionsInput>
  }

  export type BusinessCardCreateWithoutLedgerTransactionsInput = {
    id?: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerAccount: AccountCreateNestedOneWithoutBusinessCardsInput
    company: CompanyCreateNestedOneWithoutBusinessCardsInput
  }

  export type BusinessCardUncheckedCreateWithoutLedgerTransactionsInput = {
    id?: string
    companyId: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerAccountId: string
  }

  export type BusinessCardCreateOrConnectWithoutLedgerTransactionsInput = {
    where: BusinessCardWhereUniqueInput
    create: XOR<BusinessCardCreateWithoutLedgerTransactionsInput, BusinessCardUncheckedCreateWithoutLedgerTransactionsInput>
  }

  export type AccountUpsertWithoutLedgerTransactionsInput = {
    update: XOR<AccountUpdateWithoutLedgerTransactionsInput, AccountUncheckedUpdateWithoutLedgerTransactionsInput>
    create: XOR<AccountCreateWithoutLedgerTransactionsInput, AccountUncheckedCreateWithoutLedgerTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutLedgerTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutLedgerTransactionsInput, AccountUncheckedUpdateWithoutLedgerTransactionsInput>
  }

  export type AccountUpdateWithoutLedgerTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutLedgerTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type BranchUpsertWithoutLedgerTransactionsInput = {
    update: XOR<BranchUpdateWithoutLedgerTransactionsInput, BranchUncheckedUpdateWithoutLedgerTransactionsInput>
    create: XOR<BranchCreateWithoutLedgerTransactionsInput, BranchUncheckedCreateWithoutLedgerTransactionsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutLedgerTransactionsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutLedgerTransactionsInput, BranchUncheckedUpdateWithoutLedgerTransactionsInput>
  }

  export type BranchUpdateWithoutLedgerTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutLedgerTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type JournalEntryUpsertWithoutTransactionsInput = {
    update: XOR<JournalEntryUpdateWithoutTransactionsInput, JournalEntryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<JournalEntryCreateWithoutTransactionsInput, JournalEntryUncheckedCreateWithoutTransactionsInput>
    where?: JournalEntryWhereInput
  }

  export type JournalEntryUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: JournalEntryWhereInput
    data: XOR<JournalEntryUpdateWithoutTransactionsInput, JournalEntryUncheckedUpdateWithoutTransactionsInput>
  }

  export type JournalEntryUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutJournalEntriesNestedInput
    company?: CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartnerUpsertWithoutLedgerTransactionsInput = {
    update: XOR<PartnerUpdateWithoutLedgerTransactionsInput, PartnerUncheckedUpdateWithoutLedgerTransactionsInput>
    create: XOR<PartnerCreateWithoutLedgerTransactionsInput, PartnerUncheckedCreateWithoutLedgerTransactionsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutLedgerTransactionsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutLedgerTransactionsInput, PartnerUncheckedUpdateWithoutLedgerTransactionsInput>
  }

  export type PartnerUpdateWithoutLedgerTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUpdateManyWithoutPartnerNestedInput
    company?: CompanyUpdateOneRequiredWithoutPartnersNestedInput
    transactions?: TransactionUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutLedgerTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPartnerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type BusinessCardUpsertWithoutLedgerTransactionsInput = {
    update: XOR<BusinessCardUpdateWithoutLedgerTransactionsInput, BusinessCardUncheckedUpdateWithoutLedgerTransactionsInput>
    create: XOR<BusinessCardCreateWithoutLedgerTransactionsInput, BusinessCardUncheckedCreateWithoutLedgerTransactionsInput>
    where?: BusinessCardWhereInput
  }

  export type BusinessCardUpdateToOneWithWhereWithoutLedgerTransactionsInput = {
    where?: BusinessCardWhereInput
    data: XOR<BusinessCardUpdateWithoutLedgerTransactionsInput, BusinessCardUncheckedUpdateWithoutLedgerTransactionsInput>
  }

  export type BusinessCardUpdateWithoutLedgerTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerAccount?: AccountUpdateOneRequiredWithoutBusinessCardsNestedInput
    company?: CompanyUpdateOneRequiredWithoutBusinessCardsNestedInput
  }

  export type BusinessCardUncheckedUpdateWithoutLedgerTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateWithoutVouchersInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutVouchersInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutVouchersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutVouchersInput, AccountUncheckedCreateWithoutVouchersInput>
  }

  export type BranchCreateWithoutVouchersInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    quotations?: QuotationCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutVouchersInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutVouchersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutVouchersInput, BranchUncheckedCreateWithoutVouchersInput>
  }

  export type CompanyCreateWithoutVouchersInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVouchersInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVouchersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVouchersInput, CompanyUncheckedCreateWithoutVouchersInput>
  }

  export type UserCreateWithoutVouchersInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutVouchersInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutVouchersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVouchersInput, UserUncheckedCreateWithoutVouchersInput>
  }

  export type VendorCreateWithoutVouchersInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVendorsInput
  }

  export type VendorUncheckedCreateWithoutVouchersInput = {
    id?: string
    companyId: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCreateOrConnectWithoutVouchersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVouchersInput, VendorUncheckedCreateWithoutVouchersInput>
  }

  export type VoucherItemCreateWithoutVoucherInput = {
    id?: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
    category: ExpenseCategoryCreateNestedOneWithoutVoucherItemsInput
  }

  export type VoucherItemUncheckedCreateWithoutVoucherInput = {
    id?: string
    categoryId: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
  }

  export type VoucherItemCreateOrConnectWithoutVoucherInput = {
    where: VoucherItemWhereUniqueInput
    create: XOR<VoucherItemCreateWithoutVoucherInput, VoucherItemUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherItemCreateManyVoucherInputEnvelope = {
    data: VoucherItemCreateManyVoucherInput | VoucherItemCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type VoucherPaymentCreateWithoutVoucherInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    receiptNo: string
    createdAt?: Date | string
    account?: AccountCreateNestedOneWithoutVoucherPaymentsInput
    company: CompanyCreateNestedOneWithoutVoucherPaymentsInput
    enteredBy: UserCreateNestedOneWithoutVoucherPaymentsInput
  }

  export type VoucherPaymentUncheckedCreateWithoutVoucherInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    receiptNo: string
    enteredById: string
    createdAt?: Date | string
    companyId: string
  }

  export type VoucherPaymentCreateOrConnectWithoutVoucherInput = {
    where: VoucherPaymentWhereUniqueInput
    create: XOR<VoucherPaymentCreateWithoutVoucherInput, VoucherPaymentUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherPaymentCreateManyVoucherInputEnvelope = {
    data: VoucherPaymentCreateManyVoucherInput | VoucherPaymentCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutVouchersInput = {
    update: XOR<AccountUpdateWithoutVouchersInput, AccountUncheckedUpdateWithoutVouchersInput>
    create: XOR<AccountCreateWithoutVouchersInput, AccountUncheckedCreateWithoutVouchersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutVouchersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutVouchersInput, AccountUncheckedUpdateWithoutVouchersInput>
  }

  export type AccountUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type BranchUpsertWithoutVouchersInput = {
    update: XOR<BranchUpdateWithoutVouchersInput, BranchUncheckedUpdateWithoutVouchersInput>
    create: XOR<BranchCreateWithoutVouchersInput, BranchUncheckedCreateWithoutVouchersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutVouchersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutVouchersInput, BranchUncheckedUpdateWithoutVouchersInput>
  }

  export type BranchUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type CompanyUpsertWithoutVouchersInput = {
    update: XOR<CompanyUpdateWithoutVouchersInput, CompanyUncheckedUpdateWithoutVouchersInput>
    create: XOR<CompanyCreateWithoutVouchersInput, CompanyUncheckedCreateWithoutVouchersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVouchersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVouchersInput, CompanyUncheckedUpdateWithoutVouchersInput>
  }

  export type CompanyUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutVouchersInput = {
    update: XOR<UserUpdateWithoutVouchersInput, UserUncheckedUpdateWithoutVouchersInput>
    create: XOR<UserCreateWithoutVouchersInput, UserUncheckedCreateWithoutVouchersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVouchersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVouchersInput, UserUncheckedUpdateWithoutVouchersInput>
  }

  export type UserUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type VendorUpsertWithoutVouchersInput = {
    update: XOR<VendorUpdateWithoutVouchersInput, VendorUncheckedUpdateWithoutVouchersInput>
    create: XOR<VendorCreateWithoutVouchersInput, VendorUncheckedCreateWithoutVouchersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVouchersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVouchersInput, VendorUncheckedUpdateWithoutVouchersInput>
  }

  export type VendorUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateWithoutVouchersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherItemUpsertWithWhereUniqueWithoutVoucherInput = {
    where: VoucherItemWhereUniqueInput
    update: XOR<VoucherItemUpdateWithoutVoucherInput, VoucherItemUncheckedUpdateWithoutVoucherInput>
    create: XOR<VoucherItemCreateWithoutVoucherInput, VoucherItemUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherItemUpdateWithWhereUniqueWithoutVoucherInput = {
    where: VoucherItemWhereUniqueInput
    data: XOR<VoucherItemUpdateWithoutVoucherInput, VoucherItemUncheckedUpdateWithoutVoucherInput>
  }

  export type VoucherItemUpdateManyWithWhereWithoutVoucherInput = {
    where: VoucherItemScalarWhereInput
    data: XOR<VoucherItemUpdateManyMutationInput, VoucherItemUncheckedUpdateManyWithoutVoucherInput>
  }

  export type VoucherPaymentUpsertWithWhereUniqueWithoutVoucherInput = {
    where: VoucherPaymentWhereUniqueInput
    update: XOR<VoucherPaymentUpdateWithoutVoucherInput, VoucherPaymentUncheckedUpdateWithoutVoucherInput>
    create: XOR<VoucherPaymentCreateWithoutVoucherInput, VoucherPaymentUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherPaymentUpdateWithWhereUniqueWithoutVoucherInput = {
    where: VoucherPaymentWhereUniqueInput
    data: XOR<VoucherPaymentUpdateWithoutVoucherInput, VoucherPaymentUncheckedUpdateWithoutVoucherInput>
  }

  export type VoucherPaymentUpdateManyWithWhereWithoutVoucherInput = {
    where: VoucherPaymentScalarWhereInput
    data: XOR<VoucherPaymentUpdateManyMutationInput, VoucherPaymentUncheckedUpdateManyWithoutVoucherInput>
  }

  export type ExpenseCategoryCreateWithoutVoucherItemsInput = {
    id?: string
    name: string
    description?: string | null
    expenses?: ExpenseCreateNestedManyWithoutCategoryInput
    company: CompanyCreateNestedOneWithoutExpenseCategoriesInput
    ledgerAccount?: AccountCreateNestedOneWithoutExpenseCategoriesInput
  }

  export type ExpenseCategoryUncheckedCreateWithoutVoucherItemsInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
    ledgerAccountId?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryCreateOrConnectWithoutVoucherItemsInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutVoucherItemsInput, ExpenseCategoryUncheckedCreateWithoutVoucherItemsInput>
  }

  export type VoucherCreateWithoutItemsInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    account?: AccountCreateNestedOneWithoutVouchersInput
    branch?: BranchCreateNestedOneWithoutVouchersInput
    company: CompanyCreateNestedOneWithoutVouchersInput
    enteredBy: UserCreateNestedOneWithoutVouchersInput
    vendor?: VendorCreateNestedOneWithoutVouchersInput
    payments?: VoucherPaymentCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutItemsInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    payments?: VoucherPaymentUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutItemsInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutItemsInput, VoucherUncheckedCreateWithoutItemsInput>
  }

  export type ExpenseCategoryUpsertWithoutVoucherItemsInput = {
    update: XOR<ExpenseCategoryUpdateWithoutVoucherItemsInput, ExpenseCategoryUncheckedUpdateWithoutVoucherItemsInput>
    create: XOR<ExpenseCategoryCreateWithoutVoucherItemsInput, ExpenseCategoryUncheckedCreateWithoutVoucherItemsInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutVoucherItemsInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutVoucherItemsInput, ExpenseCategoryUncheckedUpdateWithoutVoucherItemsInput>
  }

  export type ExpenseCategoryUpdateWithoutVoucherItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutCategoryNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpenseCategoriesNestedInput
    ledgerAccount?: AccountUpdateOneWithoutExpenseCategoriesNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutVoucherItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ledgerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type VoucherUpsertWithoutItemsInput = {
    update: XOR<VoucherUpdateWithoutItemsInput, VoucherUncheckedUpdateWithoutItemsInput>
    create: XOR<VoucherCreateWithoutItemsInput, VoucherUncheckedCreateWithoutItemsInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutItemsInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutItemsInput, VoucherUncheckedUpdateWithoutItemsInput>
  }

  export type VoucherUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutVouchersNestedInput
    branch?: BranchUpdateOneWithoutVouchersNestedInput
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVouchersNestedInput
    vendor?: VendorUpdateOneWithoutVouchersNestedInput
    payments?: VoucherPaymentUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: VoucherPaymentUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type CompanyCreateWithoutVendorsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVendorsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVendorsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
  }

  export type VoucherCreateWithoutVendorInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    account?: AccountCreateNestedOneWithoutVouchersInput
    branch?: BranchCreateNestedOneWithoutVouchersInput
    company: CompanyCreateNestedOneWithoutVouchersInput
    enteredBy: UserCreateNestedOneWithoutVouchersInput
    items?: VoucherItemCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutVendorInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    items?: VoucherItemUncheckedCreateNestedManyWithoutVoucherInput
    payments?: VoucherPaymentUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutVendorInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutVendorInput, VoucherUncheckedCreateWithoutVendorInput>
  }

  export type VoucherCreateManyVendorInputEnvelope = {
    data: VoucherCreateManyVendorInput | VoucherCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutVendorsInput = {
    update: XOR<CompanyUpdateWithoutVendorsInput, CompanyUncheckedUpdateWithoutVendorsInput>
    create: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVendorsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVendorsInput, CompanyUncheckedUpdateWithoutVendorsInput>
  }

  export type CompanyUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VoucherUpsertWithWhereUniqueWithoutVendorInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutVendorInput, VoucherUncheckedUpdateWithoutVendorInput>
    create: XOR<VoucherCreateWithoutVendorInput, VoucherUncheckedCreateWithoutVendorInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutVendorInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutVendorInput, VoucherUncheckedUpdateWithoutVendorInput>
  }

  export type VoucherUpdateManyWithWhereWithoutVendorInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutVendorInput>
  }

  export type AccountCreateWithoutVoucherPaymentsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountUncheckedCreateWithoutVoucherPaymentsInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutLedgerAccountInput
  }

  export type AccountCreateOrConnectWithoutVoucherPaymentsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutVoucherPaymentsInput, AccountUncheckedCreateWithoutVoucherPaymentsInput>
  }

  export type CompanyCreateWithoutVoucherPaymentsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVoucherPaymentsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVoucherPaymentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVoucherPaymentsInput, CompanyUncheckedCreateWithoutVoucherPaymentsInput>
  }

  export type UserCreateWithoutVoucherPaymentsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutVoucherPaymentsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutVoucherPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoucherPaymentsInput, UserUncheckedCreateWithoutVoucherPaymentsInput>
  }

  export type VoucherCreateWithoutPaymentsInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    account?: AccountCreateNestedOneWithoutVouchersInput
    branch?: BranchCreateNestedOneWithoutVouchersInput
    company: CompanyCreateNestedOneWithoutVouchersInput
    enteredBy: UserCreateNestedOneWithoutVouchersInput
    vendor?: VendorCreateNestedOneWithoutVouchersInput
    items?: VoucherItemCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutPaymentsInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
    items?: VoucherItemUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutPaymentsInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutPaymentsInput, VoucherUncheckedCreateWithoutPaymentsInput>
  }

  export type AccountUpsertWithoutVoucherPaymentsInput = {
    update: XOR<AccountUpdateWithoutVoucherPaymentsInput, AccountUncheckedUpdateWithoutVoucherPaymentsInput>
    create: XOR<AccountCreateWithoutVoucherPaymentsInput, AccountUncheckedCreateWithoutVoucherPaymentsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutVoucherPaymentsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutVoucherPaymentsInput, AccountUncheckedUpdateWithoutVoucherPaymentsInput>
  }

  export type AccountUpdateWithoutVoucherPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutVoucherPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type CompanyUpsertWithoutVoucherPaymentsInput = {
    update: XOR<CompanyUpdateWithoutVoucherPaymentsInput, CompanyUncheckedUpdateWithoutVoucherPaymentsInput>
    create: XOR<CompanyCreateWithoutVoucherPaymentsInput, CompanyUncheckedCreateWithoutVoucherPaymentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVoucherPaymentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVoucherPaymentsInput, CompanyUncheckedUpdateWithoutVoucherPaymentsInput>
  }

  export type CompanyUpdateWithoutVoucherPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVoucherPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutVoucherPaymentsInput = {
    update: XOR<UserUpdateWithoutVoucherPaymentsInput, UserUncheckedUpdateWithoutVoucherPaymentsInput>
    create: XOR<UserCreateWithoutVoucherPaymentsInput, UserUncheckedCreateWithoutVoucherPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoucherPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoucherPaymentsInput, UserUncheckedUpdateWithoutVoucherPaymentsInput>
  }

  export type UserUpdateWithoutVoucherPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVoucherPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type VoucherUpsertWithoutPaymentsInput = {
    update: XOR<VoucherUpdateWithoutPaymentsInput, VoucherUncheckedUpdateWithoutPaymentsInput>
    create: XOR<VoucherCreateWithoutPaymentsInput, VoucherUncheckedCreateWithoutPaymentsInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutPaymentsInput, VoucherUncheckedUpdateWithoutPaymentsInput>
  }

  export type VoucherUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutVouchersNestedInput
    branch?: BranchUpdateOneWithoutVouchersNestedInput
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVouchersNestedInput
    vendor?: VendorUpdateOneWithoutVouchersNestedInput
    items?: VoucherItemUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: VoucherItemUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type AccountCreateWithoutBusinessCardsInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    company: CompanyCreateNestedOneWithoutAccountsInput
    parentAccount?: AccountCreateNestedOneWithoutChildAccountsInput
    childAccounts?: AccountCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutBusinessCardsInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
    childAccounts?: AccountUncheckedCreateNestedManyWithoutParentAccountInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutAccountInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutLedgerAccountInput
    invoicesGovtFee?: InvoiceUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    transactionsGovtFee?: TransactionUncheckedCreateNestedManyWithoutGovtFeeAccountInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutAccountInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutBusinessCardsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBusinessCardsInput, AccountUncheckedCreateWithoutBusinessCardsInput>
  }

  export type CompanyCreateWithoutBusinessCardsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    quotations?: QuotationCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBusinessCardsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBusinessCardsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBusinessCardsInput, CompanyUncheckedCreateWithoutBusinessCardsInput>
  }

  export type LedgerTransactionCreateWithoutCardInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    companyId: string
    account: AccountCreateNestedOneWithoutLedgerTransactionsInput
    branch?: BranchCreateNestedOneWithoutLedgerTransactionsInput
    journalEntry: JournalEntryCreateNestedOneWithoutTransactionsInput
    partner?: PartnerCreateNestedOneWithoutLedgerTransactionsInput
  }

  export type LedgerTransactionUncheckedCreateWithoutCardInput = {
    id?: string
    journalEntryId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    branchId?: string | null
  }

  export type LedgerTransactionCreateOrConnectWithoutCardInput = {
    where: LedgerTransactionWhereUniqueInput
    create: XOR<LedgerTransactionCreateWithoutCardInput, LedgerTransactionUncheckedCreateWithoutCardInput>
  }

  export type LedgerTransactionCreateManyCardInputEnvelope = {
    data: LedgerTransactionCreateManyCardInput | LedgerTransactionCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutBusinessCardsInput = {
    update: XOR<AccountUpdateWithoutBusinessCardsInput, AccountUncheckedUpdateWithoutBusinessCardsInput>
    create: XOR<AccountCreateWithoutBusinessCardsInput, AccountUncheckedCreateWithoutBusinessCardsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutBusinessCardsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutBusinessCardsInput, AccountUncheckedUpdateWithoutBusinessCardsInput>
  }

  export type AccountUpdateWithoutBusinessCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutBusinessCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CompanyUpsertWithoutBusinessCardsInput = {
    update: XOR<CompanyUpdateWithoutBusinessCardsInput, CompanyUncheckedUpdateWithoutBusinessCardsInput>
    create: XOR<CompanyCreateWithoutBusinessCardsInput, CompanyUncheckedCreateWithoutBusinessCardsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBusinessCardsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBusinessCardsInput, CompanyUncheckedUpdateWithoutBusinessCardsInput>
  }

  export type CompanyUpdateWithoutBusinessCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBusinessCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type LedgerTransactionUpsertWithWhereUniqueWithoutCardInput = {
    where: LedgerTransactionWhereUniqueInput
    update: XOR<LedgerTransactionUpdateWithoutCardInput, LedgerTransactionUncheckedUpdateWithoutCardInput>
    create: XOR<LedgerTransactionCreateWithoutCardInput, LedgerTransactionUncheckedCreateWithoutCardInput>
  }

  export type LedgerTransactionUpdateWithWhereUniqueWithoutCardInput = {
    where: LedgerTransactionWhereUniqueInput
    data: XOR<LedgerTransactionUpdateWithoutCardInput, LedgerTransactionUncheckedUpdateWithoutCardInput>
  }

  export type LedgerTransactionUpdateManyWithWhereWithoutCardInput = {
    where: LedgerTransactionScalarWhereInput
    data: XOR<LedgerTransactionUpdateManyMutationInput, LedgerTransactionUncheckedUpdateManyWithoutCardInput>
  }

  export type CompanyCreateWithoutQuotationsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
    branches?: BranchCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryCreateNestedManyWithoutCompanyInput
    partners?: PartnerCreateNestedManyWithoutCompanyInput
    transactions?: TransactionCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutQuotationsInput = {
    id?: string
    name: string
    code: string
    email?: string | null
    phone?: string | null
    address?: string | null
    trn?: string | null
    isActive?: boolean
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingMethod?: $Enums.AccountingMethod
    accountingModel?: $Enums.AccountingModel
    allowBackDated?: boolean
    auditRetentionDays?: number
    baseCurrency?: string
    decimalPrecision?: number
    emirate?: $Enums.Emirate
    establishmentCard?: string | null
    fiscalYearStart?: number
    invoiceFooter?: string | null
    invoiceHeader?: string | null
    legalType?: $Enums.LegalType
    logo?: string | null
    nameAr?: string | null
    stampImage?: string | null
    startDate?: Date | string
    tradeLicense?: string | null
    vatFilingStart?: Date | string | null
    vatRate?: number
    vatRegistered?: boolean
    vatRegistrationDate?: Date | string | null
    vatReturnFreq?: $Enums.VatFrequency
    website?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
    branches?: BranchUncheckedCreateNestedManyWithoutCompanyInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutCompanyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCompanyInput
    expenseCategories?: ExpenseCategoryUncheckedCreateNestedManyWithoutCompanyInput
    financialPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutCompanyInput
    partners?: PartnerUncheckedCreateNestedManyWithoutCompanyInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutCompanyInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutCompanyInput
    workTypes?: WorkTypeUncheckedCreateNestedManyWithoutCompanyInput
    businessCards?: BusinessCardUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutQuotationsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutQuotationsInput, CompanyUncheckedCreateWithoutQuotationsInput>
  }

  export type BranchCreateWithoutQuotationsInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    company: CompanyCreateNestedOneWithoutBranchesInput
    manager?: UserCreateNestedOneWithoutManagedBranchesInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutBranchInput
    expenses?: ExpenseCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutBranchInput
    transactions?: TransactionCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    vouchers?: VoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutQuotationsInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutBranchInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutBranchInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutBranchInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutQuotationsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutQuotationsInput, BranchUncheckedCreateWithoutQuotationsInput>
  }

  export type PartnerCreateWithoutQuotationsInput = {
    id?: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPartnerInput
    ledgerTransactions?: LedgerTransactionCreateNestedManyWithoutPartnerInput
    company: CompanyCreateNestedOneWithoutPartnersInput
    transactions?: TransactionCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutQuotationsInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPartnerInput
    ledgerTransactions?: LedgerTransactionUncheckedCreateNestedManyWithoutPartnerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutQuotationsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutQuotationsInput, PartnerUncheckedCreateWithoutQuotationsInput>
  }

  export type UserCreateWithoutQuotationsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutQuotationsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutQuotationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuotationsInput, UserUncheckedCreateWithoutQuotationsInput>
  }

  export type QuotationItemCreateWithoutQuotationInput = {
    id?: string
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
    workType?: WorkTypeCreateNestedOneWithoutQuotationItemsInput
  }

  export type QuotationItemUncheckedCreateWithoutQuotationInput = {
    id?: string
    workTypeId?: string | null
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
  }

  export type QuotationItemCreateOrConnectWithoutQuotationInput = {
    where: QuotationItemWhereUniqueInput
    create: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput>
  }

  export type QuotationItemCreateManyQuotationInputEnvelope = {
    data: QuotationItemCreateManyQuotationInput | QuotationItemCreateManyQuotationInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutQuotationInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: UserCreateNestedOneWithoutInvoicesInput
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    company: CompanyCreateNestedOneWithoutInvoicesInput
    govtFeeAccount?: AccountCreateNestedOneWithoutInvoicesGovtFeeInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutQuotationInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutQuotationInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutQuotationInput, InvoiceUncheckedCreateWithoutQuotationInput>
  }

  export type InvoiceCreateManyQuotationInputEnvelope = {
    data: InvoiceCreateManyQuotationInput | InvoiceCreateManyQuotationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutApprovedQuotationsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    managedBranches?: BranchCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutEnteredByInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    company: CompanyCreateNestedOneWithoutUsersInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    vouchers?: VoucherCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationCreateNestedManyWithoutSalespersonInput
  }

  export type UserUncheckedCreateWithoutApprovedQuotationsInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvalActions?: ApprovalRequestUncheckedCreateNestedManyWithoutApproverInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    managedBranches?: BranchUncheckedCreateNestedManyWithoutManagerInput
    dailyClosings?: DailyClosingUncheckedCreateNestedManyWithoutClosedByInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEnteredByInput
    accountingLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutAccountingLockedByInput
    unlockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutLastUnlockedByInput
    vatLockedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutVatLockedByInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedCreateNestedManyWithoutYearEndClosedByInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAgentInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutEnteredByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    vouchers?: VoucherUncheckedCreateNestedManyWithoutEnteredByInput
    voucherPayments?: VoucherPaymentUncheckedCreateNestedManyWithoutEnteredByInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutSalespersonInput
  }

  export type UserCreateOrConnectWithoutApprovedQuotationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedQuotationsInput, UserUncheckedCreateWithoutApprovedQuotationsInput>
  }

  export type CompanyUpsertWithoutQuotationsInput = {
    update: XOR<CompanyUpdateWithoutQuotationsInput, CompanyUncheckedUpdateWithoutQuotationsInput>
    create: XOR<CompanyCreateWithoutQuotationsInput, CompanyUncheckedCreateWithoutQuotationsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutQuotationsInput, CompanyUncheckedUpdateWithoutQuotationsInput>
  }

  export type CompanyUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyNestedInput
    branches?: BranchUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    trn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingMethod?: EnumAccountingMethodFieldUpdateOperationsInput | $Enums.AccountingMethod
    accountingModel?: EnumAccountingModelFieldUpdateOperationsInput | $Enums.AccountingModel
    allowBackDated?: BoolFieldUpdateOperationsInput | boolean
    auditRetentionDays?: IntFieldUpdateOperationsInput | number
    baseCurrency?: StringFieldUpdateOperationsInput | string
    decimalPrecision?: IntFieldUpdateOperationsInput | number
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    establishmentCard?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearStart?: IntFieldUpdateOperationsInput | number
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceHeader?: NullableStringFieldUpdateOperationsInput | string | null
    legalType?: EnumLegalTypeFieldUpdateOperationsInput | $Enums.LegalType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    stampImage?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeLicense?: NullableStringFieldUpdateOperationsInput | string | null
    vatFilingStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatRate?: FloatFieldUpdateOperationsInput | number
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatRegistrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatReturnFreq?: EnumVatFrequencyFieldUpdateOperationsInput | $Enums.VatFrequency
    website?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyNestedInput
    branches?: BranchUncheckedUpdateManyWithoutCompanyNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutCompanyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCompanyNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutCompanyNestedInput
    financialPeriods?: FinancialPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutCompanyNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutCompanyNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutCompanyNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutCompanyNestedInput
    workTypes?: WorkTypeUncheckedUpdateManyWithoutCompanyNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type BranchUpsertWithoutQuotationsInput = {
    update: XOR<BranchUpdateWithoutQuotationsInput, BranchUncheckedUpdateWithoutQuotationsInput>
    create: XOR<BranchCreateWithoutQuotationsInput, BranchUncheckedCreateWithoutQuotationsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutQuotationsInput, BranchUncheckedUpdateWithoutQuotationsInput>
  }

  export type BranchUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PartnerUpsertWithoutQuotationsInput = {
    update: XOR<PartnerUpdateWithoutQuotationsInput, PartnerUncheckedUpdateWithoutQuotationsInput>
    create: XOR<PartnerCreateWithoutQuotationsInput, PartnerUncheckedCreateWithoutQuotationsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutQuotationsInput, PartnerUncheckedUpdateWithoutQuotationsInput>
  }

  export type PartnerUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUpdateManyWithoutPartnerNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutPartnerNestedInput
    company?: CompanyUpdateOneRequiredWithoutPartnersNestedInput
    transactions?: TransactionUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPartnerNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutPartnerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutQuotationsInput = {
    update: XOR<UserUpdateWithoutQuotationsInput, UserUncheckedUpdateWithoutQuotationsInput>
    create: XOR<UserCreateWithoutQuotationsInput, UserUncheckedCreateWithoutQuotationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuotationsInput, UserUncheckedUpdateWithoutQuotationsInput>
  }

  export type UserUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type QuotationItemUpsertWithWhereUniqueWithoutQuotationInput = {
    where: QuotationItemWhereUniqueInput
    update: XOR<QuotationItemUpdateWithoutQuotationInput, QuotationItemUncheckedUpdateWithoutQuotationInput>
    create: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput>
  }

  export type QuotationItemUpdateWithWhereUniqueWithoutQuotationInput = {
    where: QuotationItemWhereUniqueInput
    data: XOR<QuotationItemUpdateWithoutQuotationInput, QuotationItemUncheckedUpdateWithoutQuotationInput>
  }

  export type QuotationItemUpdateManyWithWhereWithoutQuotationInput = {
    where: QuotationItemScalarWhereInput
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyWithoutQuotationInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutQuotationInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutQuotationInput, InvoiceUncheckedUpdateWithoutQuotationInput>
    create: XOR<InvoiceCreateWithoutQuotationInput, InvoiceUncheckedCreateWithoutQuotationInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutQuotationInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutQuotationInput, InvoiceUncheckedUpdateWithoutQuotationInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutQuotationInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutQuotationInput>
  }

  export type UserUpsertWithoutApprovedQuotationsInput = {
    update: XOR<UserUpdateWithoutApprovedQuotationsInput, UserUncheckedUpdateWithoutApprovedQuotationsInput>
    create: XOR<UserCreateWithoutApprovedQuotationsInput, UserUncheckedCreateWithoutApprovedQuotationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedQuotationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedQuotationsInput, UserUncheckedUpdateWithoutApprovedQuotationsInput>
  }

  export type UserUpdateWithoutApprovedQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
  }

  export type QuotationCreateWithoutItemsInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutQuotationsInput
    branch?: BranchCreateNestedOneWithoutQuotationsInput
    partner?: PartnerCreateNestedOneWithoutQuotationsInput
    salesperson: UserCreateNestedOneWithoutQuotationsInput
    invoices?: InvoiceCreateNestedManyWithoutQuotationInput
    approvedBy?: UserCreateNestedOneWithoutApprovedQuotationsInput
  }

  export type QuotationUncheckedCreateWithoutItemsInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutItemsInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
  }

  export type WorkTypeCreateWithoutQuotationItemsInput = {
    id?: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionCreateNestedManyWithoutWorkTypeInput
    company: CompanyCreateNestedOneWithoutWorkTypesInput
  }

  export type WorkTypeUncheckedCreateWithoutQuotationItemsInput = {
    id?: string
    companyId: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutWorkTypeInput
  }

  export type WorkTypeCreateOrConnectWithoutQuotationItemsInput = {
    where: WorkTypeWhereUniqueInput
    create: XOR<WorkTypeCreateWithoutQuotationItemsInput, WorkTypeUncheckedCreateWithoutQuotationItemsInput>
  }

  export type QuotationUpsertWithoutItemsInput = {
    update: XOR<QuotationUpdateWithoutItemsInput, QuotationUncheckedUpdateWithoutItemsInput>
    create: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutItemsInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutItemsInput, QuotationUncheckedUpdateWithoutItemsInput>
  }

  export type QuotationUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutQuotationsNestedInput
    branch?: BranchUpdateOneWithoutQuotationsNestedInput
    partner?: PartnerUpdateOneWithoutQuotationsNestedInput
    salesperson?: UserUpdateOneRequiredWithoutQuotationsNestedInput
    invoices?: InvoiceUpdateManyWithoutQuotationNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedQuotationsNestedInput
  }

  export type QuotationUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type WorkTypeUpsertWithoutQuotationItemsInput = {
    update: XOR<WorkTypeUpdateWithoutQuotationItemsInput, WorkTypeUncheckedUpdateWithoutQuotationItemsInput>
    create: XOR<WorkTypeCreateWithoutQuotationItemsInput, WorkTypeUncheckedCreateWithoutQuotationItemsInput>
    where?: WorkTypeWhereInput
  }

  export type WorkTypeUpdateToOneWithWhereWithoutQuotationItemsInput = {
    where?: WorkTypeWhereInput
    data: XOR<WorkTypeUpdateWithoutQuotationItemsInput, WorkTypeUncheckedUpdateWithoutQuotationItemsInput>
  }

  export type WorkTypeUpdateWithoutQuotationItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUpdateManyWithoutWorkTypeNestedInput
    company?: CompanyUpdateOneRequiredWithoutWorkTypesNestedInput
  }

  export type WorkTypeUncheckedUpdateWithoutQuotationItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedUpdateManyWithoutWorkTypeNestedInput
  }

  export type AccountCreateManyCompanyInput = {
    id?: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    parentAccountId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
  }

  export type AuditLogCreateManyCompanyInput = {
    id?: string
    userId?: string | null
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type BeneficiaryCreateManyCompanyInput = {
    id?: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
    partnerId?: string | null
  }

  export type BranchCreateManyCompanyInput = {
    id?: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    managerId?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
  }

  export type DailyClosingCreateManyCompanyInput = {
    id?: string
    branchId: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyCompanyInput = {
    id?: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    ledgerAccountId?: string | null
  }

  export type FinancialPeriodCreateManyCompanyInput = {
    id?: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type InvoiceCreateManyCompanyInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
  }

  export type JournalEntryCreateManyCompanyInput = {
    id?: string
    branchId?: string | null
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
  }

  export type PartnerCreateManyCompanyInput = {
    id?: string
    name: string
    type: $Enums.PartnerType
    email?: string | null
    phone?: string | null
  }

  export type TransactionCreateManyCompanyInput = {
    id?: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    branchId?: string | null
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCreateManyCompanyInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherCreateManyCompanyInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
  }

  export type VoucherPaymentCreateManyCompanyInput = {
    id?: string
    voucherId: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    receiptNo: string
    enteredById: string
    createdAt?: Date | string
  }

  export type WorkTypeCreateManyCompanyInput = {
    id?: string
    description: string
    presetGovFee?: Decimal | DecimalJsLike | number | string
    presetTypingCharge?: Decimal | DecimalJsLike | number | string
    vatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
  }

  export type BusinessCardCreateManyCompanyInput = {
    id?: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerAccountId: string
  }

  export type QuotationCreateManyCompanyInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
  }

  export type AccountUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccount?: AccountUpdateOneWithoutChildAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    parentAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeneficiaryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneWithoutBeneficiariesNestedInput
    transactions?: TransactionUpdateManyWithoutBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    manager?: UserUpdateOneWithoutManagedBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
  }

  export type DailyClosingUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDailyClosingsNestedInput
    closedBy?: UserUpdateOneWithoutDailyClosingsNestedInput
  }

  export type DailyClosingUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyClosingUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutExpensesNestedInput
    branch?: BranchUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutCategoryNestedInput
    ledgerAccount?: AccountUpdateOneWithoutExpenseCategoriesNestedInput
    voucherItems?: VoucherItemUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ledgerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutCategoryNestedInput
    voucherItems?: VoucherItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ledgerAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedBy?: UserUpdateOneWithoutAccountingLockedPeriodsNestedInput
    lastUnlockedBy?: UserUpdateOneWithoutUnlockedPeriodsNestedInput
    vatLockedBy?: UserUpdateOneWithoutVatLockedPeriodsNestedInput
    yearEndClosedBy?: UserUpdateOneWithoutYearEndClosedPeriodsNestedInput
  }

  export type FinancialPeriodUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneWithoutInvoicesNestedInput
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutInvoicesGovtFeeNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
    quotation?: QuotationUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalEntryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutJournalEntriesNestedInput
    transactions?: LedgerTransactionUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LedgerTransactionUncheckedUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartnerUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUpdateManyWithoutPartnerNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutPartnerNestedInput
    transactions?: TransactionUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPartnerNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutPartnerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPartnerNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vouchers?: VoucherUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vouchers?: VoucherUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutVouchersNestedInput
    branch?: BranchUpdateOneWithoutVouchersNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVouchersNestedInput
    vendor?: VendorUpdateOneWithoutVouchersNestedInput
    items?: VoucherItemUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: VoucherItemUncheckedUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherPaymentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    receiptNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutVoucherPaymentsNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVoucherPaymentsNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type VoucherPaymentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNo?: StringFieldUpdateOperationsInput | string
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherPaymentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNo?: StringFieldUpdateOperationsInput | string
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkTypeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUpdateManyWithoutWorkTypeNestedInput
    quotationItems?: QuotationItemUpdateManyWithoutWorkTypeNestedInput
  }

  export type WorkTypeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedUpdateManyWithoutWorkTypeNestedInput
    quotationItems?: QuotationItemUncheckedUpdateManyWithoutWorkTypeNestedInput
  }

  export type WorkTypeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    presetGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    presetTypingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BusinessCardUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerAccount?: AccountUpdateOneRequiredWithoutBusinessCardsNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutCardNestedInput
  }

  export type BusinessCardUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerAccountId?: StringFieldUpdateOperationsInput | string
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutCardNestedInput
  }

  export type BusinessCardUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type QuotationUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    branch?: BranchUpdateOneWithoutQuotationsNestedInput
    partner?: PartnerUpdateOneWithoutQuotationsNestedInput
    salesperson?: UserUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUpdateManyWithoutQuotationNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedQuotationsNestedInput
  }

  export type QuotationUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyClosingCreateManyBranchInput = {
    id?: string
    companyId: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedById?: string | null
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyBranchInput = {
    id?: string
    companyId: string
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyBranchInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
  }

  export type JournalEntryCreateManyBranchInput = {
    id?: string
    companyId: string
    postingDate?: Date | string
    createdAt?: Date | string
    description?: string | null
    type: $Enums.JournalEntryType
    referenceType?: string | null
    referenceId?: string | null
    reversedEntryId?: string | null
  }

  export type LedgerTransactionCreateManyBranchInput = {
    id?: string
    journalEntryId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    cardId?: string | null
  }

  export type TransactionCreateManyBranchInput = {
    id?: string
    companyId: string
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type UserCreateManyBranchInput = {
    id?: string
    email: string
    username: string
    password: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    companyId: string
    role?: $Enums.UserRole_Legacy
    isActive?: boolean
    forcePasswordChange?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    lastLoginUserAgent?: string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    failedLoginResetAt?: Date | string | null
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherCreateManyBranchInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
  }

  export type QuotationCreateManyBranchInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
  }

  export type DailyClosingUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedBy?: UserUpdateOneWithoutDailyClosingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDailyClosingsNestedInput
  }

  export type DailyClosingUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyClosingUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneWithoutInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutInvoicesGovtFeeNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
    quotation?: QuotationUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalEntryUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutJournalEntriesNestedInput
    transactions?: LedgerTransactionUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LedgerTransactionUncheckedUpdateManyWithoutJournalEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    postingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumJournalEntryTypeFieldUpdateOperationsInput | $Enums.JournalEntryType
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    reversedEntryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutLedgerTransactionsNestedInput
    journalEntry?: JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutLedgerTransactionsNestedInput
    card?: BusinessCardUpdateOneWithoutLedgerTransactionsNestedInput
  }

  export type LedgerTransactionUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutEnteredByNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalActions?: ApprovalRequestUncheckedUpdateManyWithoutApproverNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    managedBranches?: BranchUncheckedUpdateManyWithoutManagerNestedInput
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutClosedByNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEnteredByNestedInput
    accountingLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByNestedInput
    unlockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByNestedInput
    vatLockedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutVatLockedByNestedInput
    yearEndClosedPeriods?: FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAgentNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutEnteredByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutEnteredByNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutEnteredByNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutSalespersonNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRole_LegacyFieldUpdateOperationsInput | $Enums.UserRole_Legacy
    isActive?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    failedLoginResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutVouchersNestedInput
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVouchersNestedInput
    vendor?: VendorUpdateOneWithoutVouchersNestedInput
    items?: VoucherItemUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: VoucherItemUncheckedUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutQuotationsNestedInput
    partner?: PartnerUpdateOneWithoutQuotationsNestedInput
    salesperson?: UserUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUpdateManyWithoutQuotationNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedQuotationsNestedInput
  }

  export type QuotationUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestCreateManyApproverInput = {
    id?: string
    requesterId: string
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestCreateManyRequesterInput = {
    id?: string
    approverId?: string | null
    module: string
    action: string
    recordId: string
    recordType: string
    reason: string
    status?: $Enums.ApprovalStatus
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    companyId: string
    action: string
    module: string
    recordId?: string | null
    recordType?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type BranchCreateManyManagerInput = {
    id?: string
    companyId: string
    name: string
    code: string
    location?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: string | null
    allowCrossBranch?: boolean
    cashCounterEnabled?: boolean
    email?: string | null
    emirate?: $Enums.Emirate
    googleMapLink?: string | null
    invoicePrefix?: string | null
    nextInvoiceNumber?: number
    openingCashBalance?: number
    receiptPrefix?: string | null
    separateNumbering?: boolean
    type?: $Enums.BranchType
  }

  export type DailyClosingCreateManyClosedByInput = {
    id?: string
    companyId: string
    branchId: string
    date: Date | string
    status?: $Enums.ClosingStatus
    openingCash?: Decimal | DecimalJsLike | number | string
    cashIn?: Decimal | DecimalJsLike | number | string
    cashOut?: Decimal | DecimalJsLike | number | string
    closingCash?: Decimal | DecimalJsLike | number | string
    bankIn?: Decimal | DecimalJsLike | number | string
    posIn?: Decimal | DecimalJsLike | number | string
    totalSales?: Decimal | DecimalJsLike | number | string
    totalVat?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyEnteredByInput = {
    id?: string
    companyId: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialPeriodCreateManyAccountingLockedByInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodCreateManyLastUnlockedByInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodCreateManyVatLockedByInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    yearEndClosedAt?: Date | string | null
    yearEndClosedById?: string | null
  }

  export type FinancialPeriodCreateManyYearEndClosedByInput = {
    id?: string
    companyId: string
    year: number
    month: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingLocked?: boolean
    accountingLockedAt?: Date | string | null
    accountingLockedById?: string | null
    isYearEndClosed?: boolean
    lastUnlockReason?: string | null
    lastUnlockedAt?: Date | string | null
    lastUnlockedById?: string | null
    periodEnd: Date | string
    periodStart: Date | string
    vatLocked?: boolean
    vatLockedAt?: Date | string | null
    vatLockedById?: string | null
    yearEndClosedAt?: Date | string | null
  }

  export type InvoiceCreateManyAgentInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    lastActivity?: Date | string
    createdAt?: Date | string
    isValid?: boolean
  }

  export type TransactionCreateManyEnteredByInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type VoucherCreateManyEnteredByInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
  }

  export type VoucherPaymentCreateManyEnteredByInput = {
    id?: string
    voucherId: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    receiptNo: string
    createdAt?: Date | string
    companyId: string
  }

  export type QuotationCreateManySalespersonInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
  }

  export type QuotationCreateManyApprovedByInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    partnerId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
  }

  export type ApprovalRequestUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutApprovalRequestsNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutApprovalActionsNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    recordId?: NullableStringFieldUpdateOperationsInput | string | null
    recordType?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    dailyClosings?: DailyClosingUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
    dailyClosings?: DailyClosingUncheckedUpdateManyWithoutBranchNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutBranchNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutBranchNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutBranchNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    allowCrossBranch?: BoolFieldUpdateOperationsInput | boolean
    cashCounterEnabled?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emirate?: EnumEmirateFieldUpdateOperationsInput | $Enums.Emirate
    googleMapLink?: NullableStringFieldUpdateOperationsInput | string | null
    invoicePrefix?: NullableStringFieldUpdateOperationsInput | string | null
    nextInvoiceNumber?: IntFieldUpdateOperationsInput | number
    openingCashBalance?: FloatFieldUpdateOperationsInput | number
    receiptPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    separateNumbering?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumBranchTypeFieldUpdateOperationsInput | $Enums.BranchType
  }

  export type DailyClosingUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDailyClosingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutDailyClosingsNestedInput
  }

  export type DailyClosingUncheckedUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyClosingUncheckedUpdateManyWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClosingStatusFieldUpdateOperationsInput | $Enums.ClosingStatus
    openingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingCash?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bankIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    posIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalVat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutExpensesNestedInput
    branch?: BranchUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialPeriodUpdateWithoutAccountingLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutFinancialPeriodsNestedInput
    lastUnlockedBy?: UserUpdateOneWithoutUnlockedPeriodsNestedInput
    vatLockedBy?: UserUpdateOneWithoutVatLockedPeriodsNestedInput
    yearEndClosedBy?: UserUpdateOneWithoutYearEndClosedPeriodsNestedInput
  }

  export type FinancialPeriodUncheckedUpdateWithoutAccountingLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutAccountingLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodUpdateWithoutLastUnlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedBy?: UserUpdateOneWithoutAccountingLockedPeriodsNestedInput
    company?: CompanyUpdateOneRequiredWithoutFinancialPeriodsNestedInput
    vatLockedBy?: UserUpdateOneWithoutVatLockedPeriodsNestedInput
    yearEndClosedBy?: UserUpdateOneWithoutYearEndClosedPeriodsNestedInput
  }

  export type FinancialPeriodUncheckedUpdateWithoutLastUnlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutLastUnlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodUpdateWithoutVatLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedBy?: UserUpdateOneWithoutAccountingLockedPeriodsNestedInput
    company?: CompanyUpdateOneRequiredWithoutFinancialPeriodsNestedInput
    lastUnlockedBy?: UserUpdateOneWithoutUnlockedPeriodsNestedInput
    yearEndClosedBy?: UserUpdateOneWithoutYearEndClosedPeriodsNestedInput
  }

  export type FinancialPeriodUncheckedUpdateWithoutVatLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutVatLockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialPeriodUpdateWithoutYearEndClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedBy?: UserUpdateOneWithoutAccountingLockedPeriodsNestedInput
    company?: CompanyUpdateOneRequiredWithoutFinancialPeriodsNestedInput
    lastUnlockedBy?: UserUpdateOneWithoutUnlockedPeriodsNestedInput
    vatLockedBy?: UserUpdateOneWithoutVatLockedPeriodsNestedInput
  }

  export type FinancialPeriodUncheckedUpdateWithoutYearEndClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinancialPeriodUncheckedUpdateManyWithoutYearEndClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingLocked?: BoolFieldUpdateOperationsInput | boolean
    accountingLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountingLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    isYearEndClosed?: BoolFieldUpdateOperationsInput | boolean
    lastUnlockReason?: NullableStringFieldUpdateOperationsInput | string | null
    lastUnlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUnlockedById?: NullableStringFieldUpdateOperationsInput | string | null
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    vatLocked?: BoolFieldUpdateOperationsInput | boolean
    vatLockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatLockedById?: NullableStringFieldUpdateOperationsInput | string | null
    yearEndClosedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutInvoicesGovtFeeNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
    quotation?: QuotationUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isValid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionUpdateWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUpdateWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutVouchersNestedInput
    branch?: BranchUpdateOneWithoutVouchersNestedInput
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    vendor?: VendorUpdateOneWithoutVouchersNestedInput
    items?: VoucherItemUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: VoucherItemUncheckedUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherPaymentUpdateWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    receiptNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutVoucherPaymentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutVoucherPaymentsNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type VoucherPaymentUncheckedUpdateWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherPaymentUncheckedUpdateManyWithoutEnteredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type QuotationUpdateWithoutSalespersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutQuotationsNestedInput
    branch?: BranchUpdateOneWithoutQuotationsNestedInput
    partner?: PartnerUpdateOneWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUpdateManyWithoutQuotationNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedQuotationsNestedInput
  }

  export type QuotationUncheckedUpdateWithoutSalespersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutSalespersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuotationUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutQuotationsNestedInput
    branch?: BranchUpdateOneWithoutQuotationsNestedInput
    partner?: PartnerUpdateOneWithoutQuotationsNestedInput
    salesperson?: UserUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyInvoiceInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyWorkTypeInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type QuotationItemCreateManyWorkTypeInput = {
    id?: string
    quotationId: string
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
  }

  export type TransactionUpdateWithoutWorkTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWorkTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutWorkTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type QuotationItemUpdateWithoutWorkTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quotation?: QuotationUpdateOneRequiredWithoutItemsNestedInput
  }

  export type QuotationItemUncheckedUpdateWithoutWorkTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type QuotationItemUncheckedUpdateManyWithoutWorkTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyBeneficiaryInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionUpdateWithoutBeneficiaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBeneficiaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutBeneficiaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type BeneficiaryCreateManyPartnerInput = {
    id?: string
    companyId: string
    name: string
    details?: string | null
    phone?: string | null
    email?: string | null
  }

  export type LedgerTransactionCreateManyPartnerInput = {
    id?: string
    journalEntryId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    companyId: string
    branchId?: string | null
    cardId?: string | null
  }

  export type TransactionCreateManyPartnerInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type QuotationCreateManyPartnerInput = {
    id?: string
    quotationNo: string
    date?: Date | string
    validUntil: Date | string
    companyId: string
    branchId?: string | null
    beneficiaryName?: string | null
    salespersonId: string
    currency?: string
    status?: $Enums.QuotationStatus
    subtotal?: Decimal | DecimalJsLike | number | string
    totalGovFee?: Decimal | DecimalJsLike | number | string
    totalTax?: Decimal | DecimalJsLike | number | string
    grandTotal?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    termsAndConditions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    convertedAt?: Date | string | null
    approvedById?: string | null
    approvedAt?: Date | string | null
    invoicedAmount?: Decimal | DecimalJsLike | number | string
    deletedAt?: Date | string | null
  }

  export type BeneficiaryUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutBeneficiariesNestedInput
    transactions?: TransactionUpdateManyWithoutBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutBeneficiaryNestedInput
  }

  export type BeneficiaryUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutLedgerTransactionsNestedInput
    branch?: BranchUpdateOneWithoutLedgerTransactionsNestedInput
    journalEntry?: JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput
    card?: BusinessCardUpdateOneWithoutLedgerTransactionsNestedInput
  }

  export type LedgerTransactionUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type QuotationUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutQuotationsNestedInput
    branch?: BranchUpdateOneWithoutQuotationsNestedInput
    salesperson?: UserUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUpdateManyWithoutQuotationNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedQuotationsNestedInput
  }

  export type QuotationUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryName?: NullableStringFieldUpdateOperationsInput | string | null
    salespersonId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalGovFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grandTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    termsAndConditions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseCreateManyCategoryInput = {
    id?: string
    companyId: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherItemCreateManyCategoryInput = {
    id?: string
    voucherId: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
  }

  export type ExpenseUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutExpensesNestedInput
    branch?: BranchUpdateOneWithoutExpensesNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherItemUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    voucher?: VoucherUpdateOneRequiredWithoutItemsNestedInput
  }

  export type VoucherItemUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherItemUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AccountCreateManyParentAccountInput = {
    id?: string
    companyId: string
    name: string
    type: $Enums.AccountType
    balance?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    bankName?: string | null
    branchId?: string | null
    category: $Enums.AccountCategory
    code: string
    iban?: string | null
    isPostable?: boolean
    isSystem?: boolean
    linkedBranchIds?: AccountCreatelinkedBranchIdsInput | string[]
    merchantId?: string | null
    swiftCode?: string | null
    terminalId?: string | null
  }

  export type ExpenseCreateManyAccountInput = {
    id?: string
    companyId: string
    branchId?: string | null
    date?: Date | string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    categoryId: string
    paymentMethod: $Enums.PaymentMethod
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCategoryCreateManyLedgerAccountInput = {
    id?: string
    companyId: string
    name: string
    description?: string | null
  }

  export type InvoiceCreateManyGovtFeeAccountInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId?: string | null
  }

  export type LedgerTransactionCreateManyAccountInput = {
    id?: string
    journalEntryId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    branchId?: string | null
    cardId?: string | null
  }

  export type TransactionCreateManyAccountInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type TransactionCreateManyGovtFeeAccountInput = {
    id?: string
    companyId: string
    branchId?: string | null
    invoiceId?: string | null
    invNo?: string | null
    date?: Date | string
    enteredById?: string | null
    beneficiaryId?: string | null
    partnerId?: string | null
    workTypeId?: string | null
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    vat?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    type?: $Enums.TransactionType
    receiptNo?: string | null
    govtFeeRef?: string | null
    paymentMethod: $Enums.PaymentMethod
    cardId?: string | null
    transactionId?: string | null
    status?: $Enums.PaymentStatus
    advanceStatus?: $Enums.AdvanceStatus
    advanceAmount?: Decimal | DecimalJsLike | number | string
    customerName?: string | null
    applicantName?: string | null
    details?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isVatApplicable?: boolean
    vatRate?: Decimal | DecimalJsLike | number | string
    quantity?: number
  }

  export type VoucherCreateManyAccountInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorId?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
  }

  export type VoucherPaymentCreateManyAccountInput = {
    id?: string
    voucherId: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    receiptNo: string
    enteredById: string
    createdAt?: Date | string
    companyId: string
  }

  export type BusinessCardCreateManyLedgerAccountInput = {
    id?: string
    companyId: string
    name: string
    type?: $Enums.CardType
    issuingBank: string
    last4Digits: string
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    statementCycleDay?: number | null
    paymentDueDays?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutParentAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutAccountsNestedInput
    childAccounts?: AccountUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutParentAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    childAccounts?: AccountUncheckedUpdateManyWithoutParentAccountNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutAccountNestedInput
    expenseCategories?: ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountNestedInput
    invoicesGovtFee?: InvoiceUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    transactionsGovtFee?: TransactionUncheckedUpdateManyWithoutGovtFeeAccountNestedInput
    vouchers?: VoucherUncheckedUpdateManyWithoutAccountNestedInput
    voucherPayments?: VoucherPaymentUncheckedUpdateManyWithoutAccountNestedInput
    businessCards?: BusinessCardUncheckedUpdateManyWithoutLedgerAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutParentAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAccountCategoryFieldUpdateOperationsInput | $Enums.AccountCategory
    code?: StringFieldUpdateOperationsInput | string
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    isPostable?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    linkedBranchIds?: AccountUpdatelinkedBranchIdsInput | string[]
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneRequiredWithoutExpensesNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpensesNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCategoryUpdateWithoutLedgerAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutCategoryNestedInput
    company?: CompanyUpdateOneRequiredWithoutExpenseCategoriesNestedInput
    voucherItems?: VoucherItemUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateWithoutLedgerAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutCategoryNestedInput
    voucherItems?: VoucherItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateManyWithoutLedgerAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutGovtFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneWithoutInvoicesNestedInput
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
    quotation?: QuotationUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutGovtFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutGovtFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneWithoutLedgerTransactionsNestedInput
    journalEntry?: JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutLedgerTransactionsNestedInput
    card?: BusinessCardUpdateOneWithoutLedgerTransactionsNestedInput
  }

  export type LedgerTransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutTransactionsGovtFeeNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUpdateWithoutGovtFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    beneficiary?: BeneficiaryUpdateOneWithoutTransactionsNestedInput
    branch?: BranchUpdateOneWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTransactionsNestedInput
    enteredBy?: UserUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutTransactionsNestedInput
    workType?: WorkTypeUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutGovtFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUncheckedUpdateManyWithoutGovtFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    invNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredById?: NullableStringFieldUpdateOperationsInput | string | null
    beneficiaryId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    receiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    advanceStatus?: EnumAdvanceStatusFieldUpdateOperationsInput | $Enums.AdvanceStatus
    advanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type VoucherUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneWithoutVouchersNestedInput
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVouchersNestedInput
    vendor?: VendorUpdateOneWithoutVouchersNestedInput
    items?: VoucherItemUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: VoucherItemUncheckedUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherPaymentUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    receiptNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVoucherPaymentsNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVoucherPaymentsNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type VoucherPaymentUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    receiptNo?: StringFieldUpdateOperationsInput | string
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherPaymentUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    receiptNo?: StringFieldUpdateOperationsInput | string
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCardUpdateWithoutLedgerAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBusinessCardsNestedInput
    ledgerTransactions?: LedgerTransactionUpdateManyWithoutCardNestedInput
  }

  export type BusinessCardUncheckedUpdateWithoutLedgerAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerTransactions?: LedgerTransactionUncheckedUpdateManyWithoutCardNestedInput
  }

  export type BusinessCardUncheckedUpdateManyWithoutLedgerAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    issuingBank?: StringFieldUpdateOperationsInput | string
    last4Digits?: StringFieldUpdateOperationsInput | string
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    statementCycleDay?: NullableIntFieldUpdateOperationsInput | number | null
    paymentDueDays?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerTransactionCreateManyJournalEntryInput = {
    id?: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    branchId?: string | null
    cardId?: string | null
  }

  export type LedgerTransactionUpdateWithoutJournalEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutLedgerTransactionsNestedInput
    branch?: BranchUpdateOneWithoutLedgerTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutLedgerTransactionsNestedInput
    card?: BusinessCardUpdateOneWithoutLedgerTransactionsNestedInput
  }

  export type LedgerTransactionUncheckedUpdateWithoutJournalEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutJournalEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    cardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherItemCreateManyVoucherInput = {
    id?: string
    categoryId: string
    quantity?: number
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    isVatApplicable?: boolean
    vatAmount?: Decimal | DecimalJsLike | number | string
    vatRate?: Decimal | DecimalJsLike | number | string
  }

  export type VoucherPaymentCreateManyVoucherInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    accountId?: string | null
    receiptNo: string
    enteredById: string
    createdAt?: Date | string
    companyId: string
  }

  export type VoucherItemUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: ExpenseCategoryUpdateOneRequiredWithoutVoucherItemsNestedInput
  }

  export type VoucherItemUncheckedUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherItemUncheckedUpdateManyWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    vatAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vatRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherPaymentUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    receiptNo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutVoucherPaymentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutVoucherPaymentsNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVoucherPaymentsNestedInput
  }

  export type VoucherPaymentUncheckedUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNo?: StringFieldUpdateOperationsInput | string
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherPaymentUncheckedUpdateManyWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNo?: StringFieldUpdateOperationsInput | string
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherCreateManyVendorInput = {
    id?: string
    voucherNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    description?: string | null
    vendorName?: string | null
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    status?: $Enums.VoucherStatus
    type?: $Enums.VoucherType
    paymentMethod?: $Enums.PaymentMethod
    accountId?: string | null
    enteredById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billUrl?: string | null
  }

  export type VoucherUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneWithoutVouchersNestedInput
    branch?: BranchUpdateOneWithoutVouchersNestedInput
    company?: CompanyUpdateOneRequiredWithoutVouchersNestedInput
    enteredBy?: UserUpdateOneRequiredWithoutVouchersNestedInput
    items?: VoucherItemUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
    items?: VoucherItemUncheckedUpdateManyWithoutVoucherNestedInput
    payments?: VoucherPaymentUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumVoucherStatusFieldUpdateOperationsInput | $Enums.VoucherStatus
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    enteredById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionCreateManyCardInput = {
    id?: string
    journalEntryId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    partnerId?: string | null
    companyId: string
    branchId?: string | null
  }

  export type LedgerTransactionUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyId?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutLedgerTransactionsNestedInput
    branch?: BranchUpdateOneWithoutLedgerTransactionsNestedInput
    journalEntry?: JournalEntryUpdateOneRequiredWithoutTransactionsNestedInput
    partner?: PartnerUpdateOneWithoutLedgerTransactionsNestedInput
  }

  export type LedgerTransactionUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LedgerTransactionUncheckedUpdateManyWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalEntryId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationItemCreateManyQuotationInput = {
    id?: string
    workTypeId?: string | null
    description: string
    govFee?: Decimal | DecimalJsLike | number | string
    typingCharge?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isVatApplicable?: boolean
    quantity?: number
  }

  export type InvoiceCreateManyQuotationInput = {
    id?: string
    invoiceNo: string
    date?: Date | string
    companyId: string
    branchId?: string | null
    customerId?: string | null
    customerName?: string | null
    agentId?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paymentRef?: string | null
    bankName?: string | null
    status?: $Enums.InvoiceStatus
    govtFeeAccountId?: string | null
    govtFeeRef?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    workType?: WorkTypeUpdateOneWithoutQuotationItemsNestedInput
  }

  export type QuotationItemUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type QuotationItemUncheckedUpdateManyWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    govFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    typingCharge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isVatApplicable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneWithoutInvoicesNestedInput
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    govtFeeAccount?: AccountUpdateOneWithoutInvoicesGovtFeeNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentRef?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    govtFeeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    govtFeeRef?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkTypeCountOutputTypeDefaultArgs instead
     */
    export type WorkTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeneficiaryCountOutputTypeDefaultArgs instead
     */
    export type BeneficiaryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeneficiaryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerCountOutputTypeDefaultArgs instead
     */
    export type PartnerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartnerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseCategoryCountOutputTypeDefaultArgs instead
     */
    export type ExpenseCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalEntryCountOutputTypeDefaultArgs instead
     */
    export type JournalEntryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoucherCountOutputTypeDefaultArgs instead
     */
    export type VoucherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoucherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorCountOutputTypeDefaultArgs instead
     */
    export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessCardCountOutputTypeDefaultArgs instead
     */
    export type BusinessCardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessCardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuotationCountOutputTypeDefaultArgs instead
     */
    export type QuotationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuotationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyClosingDefaultArgs instead
     */
    export type DailyClosingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyClosingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalRequestDefaultArgs instead
     */
    export type ApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancialPeriodDefaultArgs instead
     */
    export type FinancialPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancialPeriodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkTypeDefaultArgs instead
     */
    export type WorkTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeneficiaryDefaultArgs instead
     */
    export type BeneficiaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeneficiaryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerDefaultArgs instead
     */
    export type PartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseCategoryDefaultArgs instead
     */
    export type ExpenseCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalEntryDefaultArgs instead
     */
    export type JournalEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerTransactionDefaultArgs instead
     */
    export type LedgerTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoucherDefaultArgs instead
     */
    export type VoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoucherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoucherItemDefaultArgs instead
     */
    export type VoucherItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoucherItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorDefaultArgs instead
     */
    export type VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoucherPaymentDefaultArgs instead
     */
    export type VoucherPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoucherPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessCardDefaultArgs instead
     */
    export type BusinessCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuotationDefaultArgs instead
     */
    export type QuotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuotationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuotationItemDefaultArgs instead
     */
    export type QuotationItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuotationItemDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}